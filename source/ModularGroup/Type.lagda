Lane Biocini 17 October 2023

Our formalization of PSL₂Z (called 𝓜 here) uses a mutual inductive type
to represent S ＝ [0 -1; 1 1] and R = [0 -1; 1 1] matrices that generate
PSL₂Z, with orders 2 and 3 respectively. As is well known, this group is
quotiented by the relation I₂ ∼ -I₂.

First we have Keith Conrad's expository summary of the literature;
his paper /SL2(Z)/, among many other results, proves the uniqueness and
irreducibility of elements of PSL2Z. The second, which was eventually more
formative for the approach taken here, was Robin Alperin's paper "Rationals
and the Modular Group" in which he derives an inductive generation of the
possible words in 𝓜.

Alperin's paper is primarily concerned with defining a representation of the
extended rationals through the image formed by projections from the point
at infinity. Alperin's paper proceeds by considering the cosets of 𝓜, and
he settles on the following subgroup of 𝓜 (which he calls 𝓡) as suitable
for his purposes of representing the projective extended rationals 𝓟¹(ℚ):

 𝓟¹(ℚ) ≃ (𝓡 ＝ {I} ∪ {R} ∪ 𝓕𝓢(SR,SR²)∘SR² ∪ 𝓕𝓢(RS,RS²)∘R²)

where 𝓕𝓢 specifies the free semigroup composed of the elements listed in
parenthesis. Let us note briefly that in Alperin's paper S is A and R is
B; we instead follow Conrad's notation of S and R because A and B are very
useful letters to have in Agda.

The influence taken here from Alperin's paper derives from how he
eventually made this subgroup 𝓡, at one stage utilizing a mutual induction
procedure to generate words that are formed from the possible morphisms
formed by S and R. What is key is that one either composes a word with the
morphisms S , (R ∨ R²) such that an S does not touch a word starting with
S, and an R does not touch a word also starting with R, as these are
stabilitizer subgroups and allowing these generators to freely compose
on the type constructor level will thwart the canonicity of words.

Taking some influence from Escardo's InitialBinarySystem2 module, we
settle on a simple mutually inductive type which will only allow an
R or R² from an S, and vice versa. We then embed these into a master type
that encapsulates these sets. Escardo's influence stems from the use
of helper functions which stand in as general versions of the canonical
constructions which instead act across all of 𝓜. This is an approach also
used by Sneap in the Integer module for a version of succ native to ℤ. Where
I expand upon this is the use of the pattern keyword to greatly simplify
working with this type's pattern matching. Some thought was put into a
consistent system for this labeling, which I will summarize in the heading
for that section.

On the use of helper functions, if our type correctly represents morphisms
of PSL₂ℤ, then we ought to be able to write functions corresponding to each
morphism (canonically appearing as the constructors 𝑠, 𝑟, 𝑟²) that faithfully
represent their actions in the group, displaying the quotienting
properties determined by their order as representatives of the stabilitizer
subgroups of 𝓜. This was achieved quite easily once the construction was
devised, I was struck how smooth this type's computational properties were
handled by Agda. These functions also gives nice computational behaviors
to the functions mirroring constructors of 𝓢 and 𝓡 within 𝓜, because these
perform quotienting actions and hence can be used to reduce proof terms with
ap. For another example, the fact that 𝓜 collects terms which differ
depending on the η and θ constructors embedding 𝓢 and 𝓡 respectively allows
us to make proofs which take advantage of this type difference to establish
decidability for 𝓜, similar to how one does so in ℕ. Observe this method of
proof in both the Properties/Composition modules. Overall it was a pleasure
to work with this type, I was quite pleased by how smoothly it all turned out.

To summarize the construction, we have E and S on the 𝓢 side, with little S
taking elements from the other type 𝓡. Then we have little R and R² in 𝓡,
taking elements from 𝓢 to construct its members; hence 𝓡 is strictly
dependent on 𝓢, and 𝓢 has the zero-level constructors, while successors for
both must be strictly alternating between types. Having a canonical S and E,
we obtain canonical representations of the words R/R² by right-composition
with the identity element. Thus we can form SR/SR² and R²S/RS evidently,
and achieve the ability to form every possible word in PSL₂ℤ generated by
the elements S and R in this type in irreducible form. Also to note, we can
interpret the action of η and θ constructors as essentially a representation
of the identity element from the left rather than the right side. The overall
methodology I pursued was to keep as few cases as possible for each branch
of pattern matching, so as to express the most efficient construction possible.

My overall intentions for this series of modules is as follows:
 1. Provide a base for research into the formalization of the Modular Group
  by purely synthetic/symbolic methods; 𝓜 can then be composed with other
  types to research specific fields of interest
 2. Studying the relationship between modular forms and Gosper's bihomographic
  algorithm originally presented in his continued fraction arithmetic paper
 3. On the basis of (2), develop a new formalization of rational and real
  arbitrary-precision arithmetic with a type formalized along the lines of
  Bertot and Niqui's work in the QArith libraries. Where the approach will
  differ here is the use of symbolic rather than analytic methods of
  computing that arithmetic, acting directly upon symbolic representations
  of matrices in 𝓜 and canonical representatives in ℚ or ℝ rather than
  translating between them and natural number or integer types.
 4. Investigate whatever connections are appropriate for the subjects pursued
  above with Univalent mathematics in general.

\begin{code}

{-# OPTIONS --without-K --exact-split --safe #-}

module ModularGroup.Type where

open import MLTT.Spartan

data 𝓜 : 𝓤₀ ̇
data 𝓢 : 𝓤₀ ̇
data 𝓡 : 𝓤₀ ̇

data 𝓢 where
  𝐸 : 𝓢
  𝑆 : 𝓢
  𝑠 : 𝓡 → 𝓢

data 𝓡 where
  𝑟 : 𝓢 → 𝓡
  𝑟² : 𝓢 → 𝓡

data 𝓜 where
  η : 𝓢 → 𝓜
  θ : 𝓡 → 𝓜

\end{code}

These will be useful for cleaning up the syntax of pattern matching,
and for giving ergonomic names to common expressions in 𝓜. The basic rules
for this system are as follows:
 - \Mi<letter> characters (i.e. 𝑆, 𝑅) are used for canonical constructors
  of the base type.
 - \MI<letter> characters are used specifically for patterns which mimic
  base type successors while also absorbing the η or θ constructors.
  This makes the case matching more readable and keeps case sections within
  character line limits.
 - Plain text capital letters are used for constants that are typed as
  𝓜
 - Plain text lowercase letters are used for functions which mimic
  successor constructors of 𝓢 or 𝓡. Additionally, we conjugate the
  letters together to form condensed versions of functions that are
  ergonomic for the purpose of identity unification in proofs.

\begin{code}

pattern 𝑅 = 𝑟 𝐸
pattern 𝑅² = 𝑟² 𝐸
pattern 𝑅𝑆 = 𝑟 𝑆
pattern 𝑅²𝑆 = 𝑟² 𝑆
pattern 𝑆𝑅 = 𝑠 𝑅
pattern 𝑆𝑅² = 𝑠 𝑅²

pattern 𝒔 x = η (𝑠 x)
pattern 𝒓 x = θ (𝑟 x)
pattern 𝒓² x = θ (𝑟² x)

pattern RS = 𝒓 𝑆
pattern R²S = 𝒓² 𝑆
pattern SR = 𝒔 𝑅
pattern SR² = 𝒔 𝑅²
pattern SRS = 𝒔 𝑅𝑆
pattern SR²S = 𝒔 𝑅²𝑆
pattern RSR = 𝒓 𝑆𝑅
pattern R²SR = 𝒓² 𝑆𝑅
pattern R²SR² = 𝒓² 𝑆𝑅²

pattern E = η 𝐸
pattern S = η 𝑆
pattern R = θ 𝑅
pattern R² = θ 𝑅²

r s : 𝓜 → 𝓜
r (η x) = 𝒓 x
r (𝒓 x) = 𝒓² x
r (𝒓² x) = η x
s E = S
s S = E
s (𝒔 x) = θ x
s (θ x) = 𝒔 x

sr rs r² : 𝓜 → 𝓜
sr x = s (r x)
rs x = r (s x)
r² x = r (r x)

srs sr² rsr r²s : 𝓜 → 𝓜
srs x = s (r (s x))
sr² x = s (r (r x))
rsr x = r (s (r x))
r²s x = r (r (s x))

sr²s rsr² r²sr r²sr² : 𝓜 → 𝓜
sr²s x = s (r (r (s x)))
rsr² x = r (s (r (r x)))
r²sr x = r (r (s (r x)))
r²sr² x = r (r (s (r (r x))))

head tail : 𝓜 → 𝓜
head E = E
head S = S
head (𝒔 x) = S
head (𝒓 x) = R
head (𝒓² x) = R
tail E = E
tail S = E
tail (𝒔 x) = θ x
tail (𝒓 x) = η x
tail (𝒓² x) = 𝒓 x

𝓜-induction : {A : 𝓜 → 𝓤 ̇ }
            → A E
            → ((x : 𝓜) → A x → A (s x))
            → ((x : 𝓜) → A x → A (r x))
            → (x : 𝓜) → A x
𝓜-induction base f g E = base
𝓜-induction base f g S = f E base
𝓜-induction base f g (𝒔 x) = f (θ x) (𝓜-induction base f g (θ x))
𝓜-induction base f g (𝒓 x) = g (η x) (𝓜-induction base f g (η x))
𝓜-induction base f g (𝒓² x) = g (𝒓 x) (g (η x) (𝓜-induction base f g (η x)))

𝓜-rec : {X : 𝓤 ̇ } → X → (f g : 𝓜 → X → X) → 𝓜 → X
𝓜-rec = 𝓜-induction

𝓜-iter : {X : 𝓤 ̇ } → X → (f g : X → X) → 𝓜 → X
𝓜-iter base f g x = 𝓜-rec base (λ _ → f) (λ _ → g) x

\end{code}
