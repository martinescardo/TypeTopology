1\begin{code}

{-# OPTIONS --without-K --exact-split --safe --auto-inline #-}

open import MLTT.Spartan renaming (_+_ to _‚àî_)

open import Integers.Type
open import Integers.Multiplication
open import Integers.Order
open import Integers.Parity
open import Rationals.Fractions hiding (_‚âà_ ; ‚âà-sym ; ‚âà-trans ; ‚âà-refl)
open import Rationals.Multiplication renaming (_*_ to _‚Ñö*_)
open import Rationals.Type
open import Naturals.Addition
open import Naturals.Division
open import Naturals.Exponents
open import Naturals.HCF
open import Naturals.Multiplication renaming (_*_ to _‚Ñï*_)
open import Naturals.Order
open import Naturals.Parity
open import Naturals.Properties
open import Notation.Order
open import UF.Base hiding (_‚âà_)
open import UF.Miscelanea
open import UF.Subsingletons
open import TypeTopology.DiscreteAndSeparated
open import TypeTopology.SigmaDiscreteAndTotallySeparated

module Dyadics.Rationals where

\end{code}

We will define the dyadics as a sigma type. Hence, we begin by stating
the type of the property which defines a dyadic. The condition is that
either the denominator is zero, or the denominator is greater than
zero, but the numerator is odd. This type contains "simplified"
dyadics. 

By properties of order, naturals, integers it follows that the dyadics
are a set.

\begin{code}

‚Ñ§[1/2]-cond : (z : ‚Ñ§) (n : ‚Ñï) ‚Üí ùì§‚ÇÄ Ãá
‚Ñ§[1/2]-cond z n = (n Ôºù 0) ‚àî (n > 0 √ó ‚Ñ§odd z)

‚Ñ§[1/2]-cond-is-prop : (z : ‚Ñ§) (n : ‚Ñï) ‚Üí is-prop (‚Ñ§[1/2]-cond z n)
‚Ñ§[1/2]-cond-is-prop z n = +-is-prop ‚Ñï-is-set (√ó-is-prop (<-is-prop-valued 0 n) (‚Ñ§odd-is-prop z)) I
 where
  I : n Ôºù 0 ‚Üí ¬¨ (0 < n √ó ‚Ñ§odd z)
  I nÔºù0 (0<n , odd-z) = not-less-than-itself 0 (transport (0 <_) nÔºù0 0<n)

‚Ñ§[1/2]-cond-is-discrete : ((z , n) : ‚Ñ§ √ó ‚Ñï) ‚Üí is-discrete (‚Ñ§[1/2]-cond z n)
‚Ñ§[1/2]-cond-is-discrete (z , n) = +-is-discrete (Œª x y ‚Üí inl (‚Ñï-is-set x y))
                                   (√ó-is-discrete (Œª x y ‚Üí inl (<-is-prop-valued 0 n x y))
                                                  (Œª x y ‚Üí inl (‚Ñ§odd-is-prop z x y)))
‚Ñ§[1/2] : ùì§‚ÇÄ Ãá
‚Ñ§[1/2] = Œ£ (z , n) Íûâ ‚Ñ§ √ó ‚Ñï , ‚Ñ§[1/2]-cond z n

‚Ñ§[1/2]-is-discrete : is-discrete ‚Ñ§[1/2]
‚Ñ§[1/2]-is-discrete = Œ£-is-discrete (√ó-is-discrete ‚Ñ§-is-discrete ‚Ñï-is-discrete) ‚Ñ§[1/2]-cond-is-discrete

‚Ñ§[1/2]-is-set : is-set ‚Ñ§[1/2]
‚Ñ§[1/2]-is-set = discrete-types-are-sets ‚Ñ§[1/2]-is-discrete

0‚Ñ§[1/2] : ‚Ñ§[1/2]
0‚Ñ§[1/2] = (pos 0 , 0) , (inl refl)

1‚Ñ§[1/2] : ‚Ñ§[1/2]
1‚Ñ§[1/2] = (pos 1 , 0) , (inl refl)

\end{code}

To define operations on dyadics, we need to consider how to normalise
dyadics into their simplified forms. For example, multiplication of
dyadics using standard rational multiplication gives
numerator/denominator combinations which are not always in lowest
terms. Hence, we must factor our operations through a "normalisation",
similarly to our approach to standard rationals.

Due to this normalisation, we introduce an equivalence relation, and
prove that equivalent dyadics are equal. In order to prove properties
of dyadic operations, we will prove that dyadics are equivalent.

\begin{code}

normalise-pos-lemma : (z : ‚Ñ§) (n : ‚Ñï) ‚Üí ‚Ñ§[1/2]
normalise-pos-lemma z 0        = (z , 0) , (inl refl)
normalise-pos-lemma z (succ n) =
 Cases (‚Ñ§even-or-odd z) (Œª ez ‚Üí (Œª (k , e) ‚Üí normalise-pos-lemma k n) (‚Ñ§even-is-multiple-of-two z ez))
                        (Œª oz ‚Üí (z , succ n) , inr (‚ãÜ , oz))

normalise-pos : ‚Ñ§ √ó ‚Ñï ‚Üí ‚Ñ§[1/2]
normalise-pos (z , n) = normalise-pos-lemma z n

normalise-neg-lemma : (z : ‚Ñ§) (n : ‚Ñï) ‚Üí ‚Ñ§[1/2]
normalise-neg-lemma z 0        = (z * pos 2 , 0) , (inl refl)
normalise-neg-lemma z (succ n) = normalise-neg-lemma (z * pos 2) n

normalise-neg : ‚Ñ§ √ó ‚Ñï ‚Üí ‚Ñ§[1/2]
normalise-neg (z , n) = normalise-neg-lemma z n

normalise : ‚Ñ§ √ó ‚Ñ§ ‚Üí ‚Ñ§[1/2]
normalise (z , pos n)     = normalise-pos (z , n)
normalise (z , negsucc n) = normalise-neg (z , n)

exponents-not-zero' : (m : ‚Ñï) ‚Üí not-zero (pos (2^ m))
exponents-not-zero' m iz = exponents-not-zero m (pos-lc I)
 where
  I : pos (2^ m) Ôºù pos 0
  I = from-is-zero (pos (2^ m)) iz

{-
from-normalise-pos : (x : ‚Ñ§) (n : ‚Ñï) ‚Üí Œ£ ((x' , n') , p) Íûâ ‚Ñ§[1/2] , (Œ£ k Íûâ ‚Ñï , (x Ôºù x' * pos (2^ k))
                                                                             √ó (n Ôºù n' + k))
from-normalise-pos x n = q , ({!!} , {!!})
 where
  q : ‚Ñ§[1/2]
  q = normalise-pos (x , n)
-}

_‚âà'_ : (x y : ‚Ñ§ √ó ‚Ñï) ‚Üí ùì§‚ÇÄ Ãá
(x , n) ‚âà' (y , m) = x * pos (2^ m) Ôºù y * pos (2^ n)

_‚âà_ : (x y : ‚Ñ§[1/2]) ‚Üí ùì§‚ÇÄ Ãá
(x , _) ‚âà (y , _) = x ‚âà' y

infix 0 _‚âà_

‚âà-sym : (x y : ‚Ñ§[1/2]) ‚Üí x ‚âà y ‚Üí y ‚âà x
‚âà-sym x y e = e ‚Åª¬π

‚âà-trans : (x y z : ‚Ñ§[1/2]) ‚Üí x ‚âà y ‚Üí y ‚âà z ‚Üí x ‚âà z
‚âà-trans ((x , n) , _) ((y , m) , _) ((z , p) , _) e‚ÇÅ e‚ÇÇ = Œ≥
 where
  p' m' n' : ‚Ñ§
  p' = pos (2^ p)
  m' = pos (2^ m)
  n' = pos (2^ n)

  I : x * p' * m' Ôºù z * n' * m'
  I = x * p' * m' Ôºù‚ü® ‚Ñ§-mult-rearrangement x p' m' ‚ü©
      x * m' * p' Ôºù‚ü® ap (_* p') e‚ÇÅ ‚ü©
      y * n' * p' Ôºù‚ü® ‚Ñ§-mult-rearrangement y n' p' ‚ü©
      y * p' * n' Ôºù‚ü® ap (_* n') e‚ÇÇ ‚ü©
      z * m' * n' Ôºù‚ü® ‚Ñ§-mult-rearrangement z m' n' ‚ü©
      z * n' * m' ‚àé

  VI : not-zero m'
  VI = exponents-not-zero' m

  Œ≥ : x * p' Ôºù z * n'
  Œ≥ = ‚Ñ§-mult-right-cancellable (x * p') (z * n') m' VI I

‚âà-refl : (x : ‚Ñ§[1/2]) ‚Üí x ‚âà x
‚âà-refl x = refl

‚âà-to-Ôºù-lemma-sub-proof‚ÇÅ : ((x , m) (y , n) : ‚Ñ§ √ó ‚Ñï)
              ‚Üí (x , m) ‚âà' (y , n)
              ‚Üí m Ôºù 0
              ‚Üí n Ôºù 0
              ‚Üí (x , m) Ôºù (y , n)
‚âà-to-Ôºù-lemma-sub-proof‚ÇÅ (x , m) (y , n) e mÔºù0 nÔºù0 = to-√ó-Ôºù I (mÔºù0 ‚àô nÔºù0 ‚Åª¬π)
 where
  I : x Ôºù y
  I = x              Ôºù‚ü® refl                                  ‚ü©
      x * pos (2^ 0) Ôºù‚ü® ap (Œª z ‚Üí x * (pos (2^ z))) (nÔºù0 ‚Åª¬π) ‚ü©
      x * pos (2^ n) Ôºù‚ü® e                                     ‚ü©
      y * pos (2^ m) Ôºù‚ü® ap (Œª z ‚Üí y * (pos (2^ z))) mÔºù0      ‚ü©
      y * pos (2^ 0) Ôºù‚ü® refl                                  ‚ü©
      y              ‚àé

‚âà-to-Ôºù-lemma-sub-proof‚ÇÇ : ((x , m) (y , n) : ‚Ñ§ √ó ‚Ñï) ‚Üí (x , m) ‚âà' (y , n) ‚Üí m Ôºù 0 ‚Üí ¬¨ (n > 0 √ó ‚Ñ§odd y)
‚âà-to-Ôºù-lemma-sub-proof‚ÇÇ (x , m) (y , 0)      e mÔºù0 (n>0 , oy) = ùüò-elim n>0
‚âà-to-Ôºù-lemma-sub-proof‚ÇÇ (x , m) (y , succ n) e mÔºù0 (n>0 , oy) = ‚Ñ§odd-not-even y oy (transport ‚Ñ§even I II)
 where
  I : x * pos (2^ (succ n)) Ôºù y
  I = x * pos (2^ (succ n)) Ôºù‚ü® e ‚ü©
      y * pos (2^ m)        Ôºù‚ü® ap (Œª - ‚Üí y * pos (2^ -)) mÔºù0 ‚ü©
      y * pos (2^ 0)        Ôºù‚ü® refl ‚ü©
      y ‚àé
  II : ‚Ñ§even (x * pos (2^ (succ n)))
  II = ‚Ñ§times-even-is-even' x (pos (2^ (succ n))) (2-exponents-even n)

‚âà-to-Ôºù-cancellation-lemma : (x y : ‚Ñ§) (n : ‚Ñï) ‚Üí (x , 1) ‚âà' (y , succ (succ n)) ‚Üí (x , 0) ‚âà' (y , succ n)
‚âà-to-Ôºù-cancellation-lemma x y n e = ‚Ñ§-mult-right-cancellable (x * pos (2^ (succ n))) (y * pos (2^ 0)) (pos 2) id I
 where
  I : x * pos (2^ (succ n)) * pos 2 Ôºù y * pos (2^ 0) * pos 2
  I = x * pos (2^ (succ n)) * pos 2   Ôºù‚ü® ‚Ñ§*-assoc x (pos (2^ (succ n))) (pos 2)                       ‚ü©
      x * (pos (2^ (succ n)) * pos 2) Ôºù‚ü® ap (x *_) (pos-multiplication-equiv-to-‚Ñï (2^ (succ n)) 2)    ‚ü©
      x * pos (2^ (succ n) ‚Ñï* 2)      Ôºù‚ü® ap (Œª - ‚Üí x * pos -) (mult-commutativity (2^ (succ n)) 2)    ‚ü©
      x * pos (2^ (succ (succ n)))    Ôºù‚ü® e                                                            ‚ü©
      y * pos (2^ 1)                  Ôºù‚ü® ap (y *_) (pos-multiplication-equiv-to-‚Ñï 2 1) ‚Åª¬π             ‚ü©
      y * (pos 2 * pos 1)             Ôºù‚ü® refl                                                         ‚ü©
      y * pos (2^ 0) * pos 2          ‚àé

‚âà-to-Ôºù-lemma-sub-proof‚ÇÉ : (x : ‚Ñ§) (m : ‚Ñï) (y : ‚Ñ§) (n : ‚Ñï) ‚Üí (x , m) ‚âà' (y , n) ‚Üí m > 0 √ó ‚Ñ§odd x ‚Üí n > 0 √ó ‚Ñ§odd y ‚Üí (x , m) Ôºù (y , n)
‚âà-to-Ôºù-lemma-sub-proof‚ÇÉ x  m               y  0               e (m>0 , ox) (n>0 , on) = ùüò-elim n>0
‚âà-to-Ôºù-lemma-sub-proof‚ÇÉ x  0               y  (succ n)        e (m>0 , ox) (n>0 , on) = ùüò-elim m>0
‚âà-to-Ôºù-lemma-sub-proof‚ÇÉ x  1               y  1               e (m>0 , ox) (n>0 , on) = to-√ó-Ôºù (‚Ñ§-mult-right-cancellable x y (pos (2^ 1)) id e) refl
‚âà-to-Ôºù-lemma-sub-proof‚ÇÉ x  1               y  (succ (succ n)) e (m>0 , ox) (n>0 , on) = ùüò-elim (‚âà-to-Ôºù-lemma-sub-proof‚ÇÇ (x , 0) (y , succ n) (‚âà-to-Ôºù-cancellation-lemma x y n e) refl (‚ãÜ , on))
‚âà-to-Ôºù-lemma-sub-proof‚ÇÉ x  (succ (succ m)) y  1               e (m>0 , ox) (n>0 , on) = ùüò-elim (‚âà-to-Ôºù-lemma-sub-proof‚ÇÇ (y , 0) (x , succ m) (‚âà-to-Ôºù-cancellation-lemma y x m (e ‚Åª¬π)) refl (‚ãÜ , ox))
‚âà-to-Ôºù-lemma-sub-proof‚ÇÉ x  (succ (succ m)) y  (succ (succ n)) e (m>0 , ox) (n>0 , on) = III (from-√ó-Ôºù' (‚âà-to-Ôºù-lemma-sub-proof‚ÇÉ x (succ m) y (succ n) II (‚ãÜ , ox) (‚ãÜ , on)))
 where
  I : x * pos (2^ (succ n)) * pos 2 Ôºù y * pos (2^ (succ m)) * pos 2
  I = x * pos (2^ (succ n)) * pos 2   Ôºù‚ü® ‚Ñ§*-assoc x (pos (2^ (succ n))) (pos 2)                       ‚ü©
      x * (pos (2^ (succ n)) * pos 2) Ôºù‚ü® ap (x *_) (pos-multiplication-equiv-to-‚Ñï (2^ (succ n)) 2)    ‚ü©
      x * pos (2^ (succ n) ‚Ñï* 2)      Ôºù‚ü® ap (Œª - ‚Üí x * pos -) (mult-commutativity (2^ (succ n)) 2)    ‚ü©
      x * pos (2^ (succ (succ n)))    Ôºù‚ü® e                                                            ‚ü©
      y * pos (2^ (succ (succ m)))    Ôºù‚ü® ap (Œª - ‚Üí y * pos -) (mult-commutativity 2 (2^ (succ m)))    ‚ü©
      y * pos (2^ (succ m) ‚Ñï* 2)      Ôºù‚ü® ap (y *_) (pos-multiplication-equiv-to-‚Ñï (2^ (succ m)) 2 ‚Åª¬π) ‚ü©
      y * (pos (2^ (succ m)) * pos 2) Ôºù‚ü® ‚Ñ§*-assoc y (pos (2^ (succ m))) (pos 2) ‚Åª¬π ‚ü©
      y * pos (2^ (succ m)) * pos 2   ‚àé

  II : x * pos (2^ (succ n)) Ôºù y * pos (2^ (succ m))
  II = ‚Ñ§-mult-right-cancellable (x * pos (2^ (succ n))) (y * pos (2^ (succ m))) (pos 2) id I

  III : (x Ôºù y) √ó (succ m Ôºù succ n) ‚Üí x , succ (succ m) Ôºù y , succ (succ n)
  III (xÔºùy , mÔºùn) = to-√ó-Ôºù xÔºùy (ap succ mÔºùn)

‚âà-to-Ôºù-lemma-sub-proof‚ÇÑ : ((x , m) (y , n) : ‚Ñ§ √ó ‚Ñï) ‚Üí (x , m) ‚âà' (y , n) ‚Üí m > 0 √ó ‚Ñ§odd x ‚Üí n > 0 √ó ‚Ñ§odd y ‚Üí (x , m) Ôºù (y , n)
‚âà-to-Ôºù-lemma-sub-proof‚ÇÑ (x , m) (y , n) e p q = ‚âà-to-Ôºù-lemma-sub-proof‚ÇÉ x m y n e p q

‚âà-to-Ôºù-lemma : ((x , m) (y , n) : ‚Ñ§ √ó ‚Ñï)
              ‚Üí (x , m) ‚âà' (y , n)
              ‚Üí ‚Ñ§[1/2]-cond x m
              ‚Üí ‚Ñ§[1/2]-cond y n
              ‚Üí (x , m) Ôºù (y , n)
‚âà-to-Ôºù-lemma x y e (inl p) (inl q) = ‚âà-to-Ôºù-lemma-sub-proof‚ÇÅ x y e p q
‚âà-to-Ôºù-lemma x y e (inl p) (inr q) = ùüò-elim (‚âà-to-Ôºù-lemma-sub-proof‚ÇÇ x y e p q)
‚âà-to-Ôºù-lemma x y e (inr p) (inl q) = ùüò-elim (‚âà-to-Ôºù-lemma-sub-proof‚ÇÇ y x (e ‚Åª¬π) q p)
‚âà-to-Ôºù-lemma x y e (inr p) (inr q) = ‚âà-to-Ôºù-lemma-sub-proof‚ÇÑ x y e p q

‚âà-to-Ôºù : (x y : ‚Ñ§[1/2]) ‚Üí x ‚âà y ‚Üí x Ôºù y
‚âà-to-Ôºù ((x , n) , p) ((y , m) , q) eq =
 to-subtype-Ôºù (Œª (x , n) ‚Üí ‚Ñ§[1/2]-cond-is-prop x n) (‚âà-to-Ôºù-lemma (x , n) (y , m) eq p q)

Ôºù-to-‚âà : (x y : ‚Ñ§[1/2]) ‚Üí x Ôºù y ‚Üí x ‚âà y
Ôºù-to-‚âà ((x , a) , Œ±) ((y , b) , Œ≤) e = Œ≥
 where
  Œ≥‚ÇÅ : x Ôºù y
  Œ≥‚ÇÅ = ap (pr‚ÇÅ ‚àò pr‚ÇÅ) e
  Œ≥‚ÇÇ : b Ôºù a
  Œ≥‚ÇÇ = ap (pr‚ÇÇ ‚àò pr‚ÇÅ) (e ‚Åª¬π)
  Œ≥ : ((x , a) , Œ±) ‚âà ((y , b) , Œ≤)
  Œ≥ = x * pos (2^ b) Ôºù‚ü® ap (_* pos (2^ b)) Œ≥‚ÇÅ ‚ü©
      y * pos (2^ b) Ôºù‚ü® ap (Œª - ‚Üí y * pos (2^ -)) Œ≥‚ÇÇ ‚ü©
      y * pos (2^ a) ‚àé

‚Ñ§[1/2]-to-normalise-pos : (((x , n) , e) : ‚Ñ§[1/2]) ‚Üí ((x , n) , e) Ôºù normalise-pos (x , n)
‚Ñ§[1/2]-to-normalise-pos ((x , 0)        , inl nÔºù0)       = to-subtype-Ôºù (Œª (x , n) ‚Üí ‚Ñ§[1/2]-cond-is-prop x n) refl
‚Ñ§[1/2]-to-normalise-pos ((x , (succ n)) , inl nÔºù0)       = ùüò-elim (positive-not-zero n nÔºù0)
‚Ñ§[1/2]-to-normalise-pos ((x , 0)        , inr (0<0 , oz)) = ùüò-elim (not-less-than-itself 0 0<0)
‚Ñ§[1/2]-to-normalise-pos ((x , succ n)   , inr (0<n , oz)) =
 ap (Œª zzz ‚Üí dep-cases
     (Œª ez ‚Üí normalise-pos-lemma (pr‚ÇÅ (‚Ñ§even-is-multiple-of-two x ez)) n)
     (Œª oz‚ÇÅ ‚Üí (x , succ n) , inr (‚ãÜ , oz‚ÇÅ)) zzz)
      (‚Ñ§even-or-odd-is-prop x (inr oz) (‚Ñ§even-or-odd x))

‚Ñ§[1/2]-from-normalise-pos : (z : ‚Ñ§) ‚Üí (n : ‚Ñï) ‚Üí Œ£ q Íûâ ‚Ñ§[1/2] , q Ôºù normalise-pos (z , n)
‚Ñ§[1/2]-from-normalise-pos z n = (normalise-pos (z , n)) , refl

‚âà-normalise-pos : (((z , a) , p) : ‚Ñ§[1/2]) ‚Üí (((z , a) , p)) ‚âà normalise-pos (z , a)
‚âà-normalise-pos (z , Œ±) = Ôºù-to-‚âà (z , Œ±) (normalise-pos z) (‚Ñ§[1/2]-to-normalise-pos (z , Œ±))

‚âà-ap : (f : ‚Ñ§[1/2] ‚Üí ‚Ñ§[1/2]) (x y : ‚Ñ§[1/2]) ‚Üí x ‚âà y ‚Üí f x ‚âà f y
‚âà-ap f x y e = Ôºù-to-‚âà (f x) (f y) (ap f (‚âà-to-Ôºù x y e))

‚âà-transport : (A : ‚Ñ§[1/2] ‚Üí ùì§ Ãá) {x y : ‚Ñ§[1/2]} ‚Üí x ‚âà y ‚Üí A x ‚Üí A y
‚âà-transport A {x} {y} e = transport A (‚âà-to-Ôºù x y e)
  
\end{code}

The following proofs relate dyadic rationals to rationals.

\begin{code}

‚Ñ§[1/2]-lt-lemma : (x : ‚Ñ§) ‚Üí (n : ‚Ñï) ‚Üí ‚Ñ§odd x ‚Üí is-in-lowest-terms (x , pred (2^ (succ n)))
‚Ñ§[1/2]-lt-lemma x n ox = (1-divides-all (abs x) , 1-divides-all (succ (pred (2^ (succ n))))) , I
 where
  I : (d : ‚Ñï) ‚Üí is-common-divisor d (abs x) (succ (pred (2^ (succ n)))) ‚Üí d ‚à£ 1
  I d icd-d = III II
   where
    II : is-common-divisor d (abs x) (2^ (succ n))
    II = transport (Œª - ‚Üí is-common-divisor d (abs x) -) (succ-pred' (2^ (succ n)) (exponents-not-zero (succ n))) icd-d
    III : is-common-divisor d (abs x) (2^ (succ n)) ‚Üí d ‚à£ 1
    III (d|x , d|2^sn) = odd-power-of-two-coprime d (abs x) (succ n) ox d|x d|2^sn

‚Ñ§[1/2]-to-‚Ñö : ‚Ñ§[1/2] ‚Üí ‚Ñö
‚Ñ§[1/2]-to-‚Ñö ((x , n)      , inl nÔºù0)       = (x , 0) , (denom-zero-lt x)
‚Ñ§[1/2]-to-‚Ñö ((x , 0)      , inr (0<n , ox)) = ùüò-elim 0<n
‚Ñ§[1/2]-to-‚Ñö ((x , succ n) , inr (0<n , ox)) = (x , pred (2^ (succ n))) , (‚Ñ§[1/2]-lt-lemma x n ox)

\end{code}

Boilerplate

\begin{code}

‚âà-trans‚ÇÇ : (x y z a : ‚Ñ§[1/2]) ‚Üí x ‚âà y ‚Üí y ‚âà z ‚Üí z ‚âà a ‚Üí x ‚âà a
‚âà-trans‚ÇÇ x y z a p q r = ‚âà-trans x y a p (‚âà-trans y z a q r)

‚âà-trans‚ÇÉ : (x y z a b : ‚Ñ§[1/2]) ‚Üí x ‚âà y ‚Üí y ‚âà z ‚Üí z ‚âà a ‚Üí a ‚âà b ‚Üí x ‚âà b
‚âà-trans‚ÇÉ x y z a b p q r s = ‚âà-trans‚ÇÇ x y z b p q (‚âà-trans z a b r s)

‚âà-trans‚ÇÑ : (x y z a b c : ‚Ñ§[1/2]) ‚Üí x ‚âà y ‚Üí y ‚âà z ‚Üí z ‚âà a ‚Üí a ‚âà b ‚Üí b ‚âà c ‚Üí x ‚âà c
‚âà-trans‚ÇÑ x y z a b c p q r s t = ‚âà-trans‚ÇÉ x y z a c p q r (‚âà-trans a b c s t)

‚âà-trans‚ÇÖ : (x y z a b c d : ‚Ñ§[1/2]) ‚Üí x ‚âà y ‚Üí y ‚âà z ‚Üí z ‚âà a ‚Üí a ‚âà b ‚Üí b ‚âà c ‚Üí c ‚âà d ‚Üí x ‚âà d
‚âà-trans‚ÇÖ x y z a b c d p q r s t u = ‚âà-trans‚ÇÑ x y z a b d p q r s (‚âà-trans b c d t u)

{-
‚âà-normalise-pos' : (x : ‚Ñ§) (n : ‚Ñï) (y : ‚Ñ§) (m : ‚Ñï)
                 ‚Üí x * pos (2^ m) Ôºù y * pos (2^ n)
                 ‚Üí normalise-pos (x , n) ‚âà normalise-pos (y , m)
‚âà-normalise-pos' x n y m e = I (‚Ñ§[1/2]-from-normalise-pos x n) (‚Ñ§[1/2]-from-normalise-pos y m)
 where
  I : Œ£ p Íûâ ‚Ñ§[1/2] , p Ôºù normalise-pos (x , n)
    ‚Üí Œ£ q Íûâ ‚Ñ§[1/2] , q Ôºù normalise-pos (y , m)
    ‚Üí normalise-pos (x , n) ‚âà normalise-pos (y , m)
  I (p , Œ±) (q , Œ≤) = Œ≥
   where
    i : p ‚âà normalise-pos (x , n)
    i = Ôºù-to-‚âà p (normalise-pos (x , n)) Œ±

    i‚Åª¬π : normalise-pos (x , n) ‚âà p
    i‚Åª¬π = ‚âà-sym p (normalise-pos (x , n)) i 

    ii : q ‚âà normalise-pos (y , m)
    ii = Ôºù-to-‚âà q (normalise-pos (y , m)) Œ≤

-- (x' , n')


-- (y' , m')

    iii : p ‚âà q
    iii = {!!}
    
    Œ≥ : normalise-pos (x , n) ‚âà normalise-pos (y , m)
    Œ≥ = ‚âà-trans‚ÇÇ (normalise-pos (x , n)) p q (normalise-pos (y , m))
        i‚Åª¬π iii ii

    Œ≥‚ÇÇ : normalise-pos (x , n) ‚âà normalise-pos (y , m)
    Œ≥‚ÇÇ = {!!}
-}

\end{code}
