Martin Escardo
January - February 2021.

In collaboration with Marc Bezem, Thierry Coquand and Peter Dybjer

We construct free groups in HoTT/UF in Agda without HIT's other than
propositional truncation, and with no consequence of univalence other
than function extensionality and propositional extensionality.

This is based on the book "A course in constructive algebra" by Ray
Mines, Fred Richman and Wim Ruitenburg, 1988. In particular, this
construction shows that the inclusion of generators is injective (and
hence an embedding in the sense of HoTT/UF). It is noteworthy and
surprising that the set of generators is not required to have
decidable equality.

This is part of Martin Escardo's Agda development TypeTopology,
whose philosophy is to be Spartan. At the moment we are a little bit
Athenian, though, with the use of Agda lists rather than Spartan-MLTT
constructed lists, although we intend to fix this in the future. (The
way to do it is already present in the module Fin.lagda.)

\begin{code}

{-# OPTIONS --without-K --safe --auto-inline #-} -- --exact-split

\end{code}

NB. This repository is supposed to use exact-split, but even though
everything has been developed using case-split, the exact-split check
fails (in Agda 2.6.1) in the helper function f of the function
church-rosser. This seems to be a bug, but we are not sure.

\begin{code}

module FreeGroup where

open import SpartanMLTT
open import Groups
open import Two
open import Two-Properties
open import List

open import UF-PropTrunc
open import UF-Univalence
open import UF-Base
open import UF-Subsingletons
open import UF-Subsingletons-FunExt
open import UF-Embeddings
open import UF-Equiv
open import UF-UA-FunExt
open import UF-FunExt

\end{code}

We now construct the group freely generated by a set A. The set-hood
requirement is needed later only, and so we don't include it as an
assumption in the following anonymous module:

\begin{code}

module free-group-construction
        {ùì§ : Universe}
        (A : ùì§ Ãá )
       where

 X : ùì§ Ãá
 X = ùüö √ó A

 _‚Åª : X ‚Üí X
 (n , a)‚Åª = (complement n , a)

 inv-invol : (x : X) ‚Üí (x ‚Åª)‚Åª ‚â° x
 inv-invol (n , a) = ap (_, a) (complement-involutive n)

\end{code}

The idea is that list concatenation _++_ will be the group operation
after suitable quotienting, with the empty list [] as the neutral
element.

We will quotient the following type FA to get the undelying type of
the free group:

\begin{code}

 FA : ùì§ Ãá
 FA = List X

 Œ∑ : A ‚Üí FA
 Œ∑ a = [ (‚ÇÄ , a) ]

\end{code}

The type ùüö has two elements ‚ÇÄ and ‚ÇÅ, and a prefix ‚ÇÅ to an element a of
the type A means it is formally inverted. So in the inclusion of
generators Œ∑ we indicate that the element a is not inverted by
prefixing it with ‚ÇÄ.

We will quotient by the equivalence relation generated by the
following reduction relation:

\begin{code}

 _‚ñ∑_ : FA ‚Üí FA ‚Üí ùì§ Ãá
 s ‚ñ∑ t = Œ£ u Íûâ FA , Œ£ v Íûâ FA , Œ£ x Íûâ X , (s ‚â° u ++ [ x ] ++ [ x ‚Åª ] ++ v)
                                       √ó (t ‚â° u ++ v)

 infix 1 _‚ñ∑_

 ‚à∑-‚ñ∑ : {s t : FA} (x : X) ‚Üí s ‚ñ∑ t ‚Üí x ‚à∑ s ‚ñ∑ x ‚à∑ t
 ‚à∑-‚ñ∑ x (u , v , y , p , q) = (x ‚à∑ u) , v , y , ap (x ‚à∑_) p , ap (x ‚à∑_) q

\end{code}

The following is a lemma for the Church-Rosser property, proved by
induction on u‚ÇÄ and u‚ÇÅ:

\begin{code}

 church-rosser : (u‚ÇÄ v‚ÇÄ u‚ÇÅ v‚ÇÅ : FA) (x‚ÇÄ x‚ÇÅ : X)

               ‚Üí u‚ÇÄ ++  [ x‚ÇÄ ] ++ [ x‚ÇÄ ‚Åª ] ++ v‚ÇÄ
               ‚â° u‚ÇÅ ++  [ x‚ÇÅ ] ++ [ x‚ÇÅ ‚Åª ] ++ v‚ÇÅ

               ‚Üí (u‚ÇÄ ++ v‚ÇÄ ‚â° u‚ÇÅ ++ v‚ÇÅ)
               + (Œ£ t Íûâ FA , (u‚ÇÄ ++ v‚ÇÄ ‚ñ∑ t) √ó (u‚ÇÅ ++ v‚ÇÅ ‚ñ∑ t))

 church-rosser u‚ÇÄ v‚ÇÄ u‚ÇÅ v‚ÇÅ x‚ÇÄ x‚ÇÅ = f u‚ÇÄ u‚ÇÅ
  where
   f : (u‚ÇÄ u‚ÇÅ : FA)
     ‚Üí u‚ÇÄ ++  [ x‚ÇÄ ] ++ [ x‚ÇÄ ‚Åª ] ++ v‚ÇÄ ‚â° u‚ÇÅ ++  [ x‚ÇÅ ] ++ [ x‚ÇÅ ‚Åª ] ++ v‚ÇÅ
     ‚Üí (u‚ÇÄ ++ v‚ÇÄ ‚â° u‚ÇÅ ++ v‚ÇÅ) + (Œ£ t Íûâ FA , (u‚ÇÄ ++ v‚ÇÄ ‚ñ∑ t) √ó (u‚ÇÅ ++ v‚ÇÅ ‚ñ∑ t))

   f [] [] p = inl Œ≥
    where
     have : x‚ÇÄ ‚à∑ x‚ÇÄ ‚Åª  ‚à∑ v‚ÇÄ
          ‚â° x‚ÇÅ ‚à∑ x‚ÇÅ ‚Åª  ‚à∑ v‚ÇÅ
     have = p

     Œ≥ : v‚ÇÄ ‚â° v‚ÇÅ
     Œ≥ = equal-tails (equal-tails p)

   f [] (y‚ÇÅ ‚à∑ []) p = inl Œ≥
    where
     have : x‚ÇÄ ‚à∑ x‚ÇÄ ‚Åª ‚à∑ v‚ÇÄ
          ‚â° y‚ÇÅ ‚à∑ x‚ÇÅ   ‚à∑ x‚ÇÅ ‚Åª ‚à∑ v‚ÇÅ
     have = p

     q = x‚ÇÅ ‚Åª    ‚â°‚ü® ap _‚Åª ((equal-heads (equal-tails p))‚Åª¬π) ‚ü©
         (x‚ÇÄ ‚Åª)‚Åª ‚â°‚ü® inv-invol x‚ÇÄ ‚ü©
         x‚ÇÄ      ‚â°‚ü® equal-heads p ‚ü©
         y‚ÇÅ      ‚àé

     Œ≥ : v‚ÇÄ ‚â° y‚ÇÅ ‚à∑ v‚ÇÅ
     Œ≥ = transport (Œª - ‚Üí v‚ÇÄ ‚â° - ‚à∑ v‚ÇÅ) q (equal-tails (equal-tails p))

   f [] (y‚ÇÅ ‚à∑ z‚ÇÅ ‚à∑ u‚ÇÅ) p = inr Œ≥
    where
     have : x‚ÇÄ ‚à∑ x‚ÇÄ ‚Åª ‚à∑ v‚ÇÄ
          ‚â° y‚ÇÅ ‚à∑ z‚ÇÅ   ‚à∑ u‚ÇÅ ++ [ x‚ÇÅ ] ++ [ x‚ÇÅ ‚Åª ] ++ v‚ÇÅ
     have = p

     d' : u‚ÇÅ ++ [ x‚ÇÅ ] ++ [ x‚ÇÅ ‚Åª ] ++ v‚ÇÅ ‚ñ∑ u‚ÇÅ ++ v‚ÇÅ
     d' = u‚ÇÅ , v‚ÇÅ , x‚ÇÅ , refl , refl

     d : v‚ÇÄ ‚ñ∑ u‚ÇÅ ++ v‚ÇÅ
     d = transport (_‚ñ∑ u‚ÇÅ ++ v‚ÇÅ) ((equal-tails (equal-tails p))‚Åª¬π) d'

     q = y‚ÇÅ ‚Åª ‚â°‚ü® (ap (_‚Åª) (equal-heads p)‚Åª¬π) ‚ü©
         x‚ÇÄ ‚Åª ‚â°‚ü® equal-heads (equal-tails p) ‚ü©
         z‚ÇÅ   ‚àé

     e' : y‚ÇÅ ‚à∑ y‚ÇÅ ‚Åª ‚à∑ u‚ÇÅ ++ v‚ÇÅ ‚ñ∑ u‚ÇÅ ++ v‚ÇÅ
     e' = [] , (u‚ÇÅ ++ v‚ÇÅ) , y‚ÇÅ , refl , refl

     e : y‚ÇÅ ‚à∑ z‚ÇÅ ‚à∑ u‚ÇÅ ++ v‚ÇÅ ‚ñ∑ u‚ÇÅ ++ v‚ÇÅ
     e = transport (Œª - ‚Üí y‚ÇÅ ‚à∑ - ‚à∑ u‚ÇÅ ++ v‚ÇÅ ‚ñ∑ u‚ÇÅ ++ v‚ÇÅ) q e'

     Œ≥ : Œ£ t Íûâ FA , (v‚ÇÄ ‚ñ∑ t) √ó (y‚ÇÅ ‚à∑ z‚ÇÅ ‚à∑ u‚ÇÅ ++ v‚ÇÅ ‚ñ∑ t)
     Œ≥ = (u‚ÇÅ ++ v‚ÇÅ) , d , e

   f (y‚ÇÄ ‚à∑ []) [] p = inl Œ≥
    where
     have : y‚ÇÄ ‚à∑ x‚ÇÄ   ‚à∑ x‚ÇÄ ‚Åª ‚à∑ v‚ÇÄ
          ‚â° x‚ÇÅ ‚à∑ x‚ÇÅ ‚Åª ‚à∑ v‚ÇÅ
     have = p

     Œ≥ = y‚ÇÄ ‚à∑ v‚ÇÄ      ‚â°‚ü® ap (_‚à∑ v‚ÇÄ) (equal-heads p) ‚ü©
         x‚ÇÅ ‚à∑ v‚ÇÄ      ‚â°‚ü® ap (_‚à∑ v‚ÇÄ) ((inv-invol x‚ÇÅ)‚Åª¬π) ‚ü©
         (x‚ÇÅ ‚Åª)‚Åª ‚à∑ v‚ÇÄ ‚â°‚ü® ap (Œª - ‚Üí - ‚Åª ‚à∑ v‚ÇÄ) ((equal-heads (equal-tails p))‚Åª¬π) ‚ü©
         x‚ÇÄ ‚Åª ‚à∑ v‚ÇÄ    ‚â°‚ü® equal-tails (equal-tails p) ‚ü©
         v‚ÇÅ           ‚àé

   f (y‚ÇÄ ‚à∑ z‚ÇÄ ‚à∑ u‚ÇÄ) [] p = inr Œ≥
    where
     have : y‚ÇÄ ‚à∑ z‚ÇÄ   ‚à∑ u‚ÇÄ ++ [ x‚ÇÄ ] ++ [ x‚ÇÄ ‚Åª ] ++ v‚ÇÄ
          ‚â° x‚ÇÅ ‚à∑ x‚ÇÅ ‚Åª ‚à∑ v‚ÇÅ
     have = p

     q = y‚ÇÄ ‚Åª ‚â°‚ü® ap (_‚Åª) (equal-heads p) ‚ü©
         x‚ÇÅ ‚Åª ‚â°‚ü® (equal-heads (equal-tails p))‚Åª¬π ‚ü©
         z‚ÇÄ   ‚àé

     d' : y‚ÇÄ ‚à∑ y‚ÇÄ ‚Åª ‚à∑ u‚ÇÄ ++ v‚ÇÄ ‚ñ∑ u‚ÇÄ ++ v‚ÇÄ
     d' = [] , (u‚ÇÄ ++ v‚ÇÄ) , y‚ÇÄ , refl , refl

     d : y‚ÇÄ ‚à∑ z‚ÇÄ ‚à∑ u‚ÇÄ ++ v‚ÇÄ ‚ñ∑ u‚ÇÄ ++ v‚ÇÄ
     d = transport (Œª - ‚Üí y‚ÇÄ ‚à∑ - ‚à∑ u‚ÇÄ ++ v‚ÇÄ ‚ñ∑ u‚ÇÄ ++ v‚ÇÄ) q d'

     e' : u‚ÇÄ ++ [ x‚ÇÄ ] ++ [ x‚ÇÄ ‚Åª ] ++ v‚ÇÄ ‚ñ∑ u‚ÇÄ ++ v‚ÇÄ
     e' = u‚ÇÄ , v‚ÇÄ , x‚ÇÄ , refl , refl

     e : v‚ÇÅ ‚ñ∑ u‚ÇÄ ++ v‚ÇÄ
     e = transport (_‚ñ∑ u‚ÇÄ ++ v‚ÇÄ) (equal-tails (equal-tails p)) e'

     Œ≥ : Œ£ t Íûâ FA , (y‚ÇÄ ‚à∑ z‚ÇÄ ‚à∑ u‚ÇÄ ++ v‚ÇÄ ‚ñ∑ t) √ó (v‚ÇÅ ‚ñ∑ t)
     Œ≥ = (u‚ÇÄ ++ v‚ÇÄ) , d , e

   f (y‚ÇÄ ‚à∑ u‚ÇÄ) (y‚ÇÅ ‚à∑ u‚ÇÅ) p = Œ≥
    where
     have : y‚ÇÄ ‚à∑ u‚ÇÄ ++ [ x‚ÇÄ ] ++ [ x‚ÇÄ ‚Åª ] ++ v‚ÇÄ
          ‚â° y‚ÇÅ ‚à∑ u‚ÇÅ ++ [ x‚ÇÅ ] ++ [ x‚ÇÅ ‚Åª ] ++ v‚ÇÅ
     have = p

     IH : (u‚ÇÄ ++ v‚ÇÄ ‚â° u‚ÇÅ ++ v‚ÇÅ) + (Œ£ t Íûâ FA , (u‚ÇÄ ++ v‚ÇÄ ‚ñ∑ t) √ó (u‚ÇÅ ++ v‚ÇÅ ‚ñ∑ t))
     IH = f u‚ÇÄ u‚ÇÅ (equal-tails p)

     Œì : X ‚Üí X ‚Üí ùì§ Ãá
     Œì y‚ÇÄ y‚ÇÅ = (y‚ÇÄ ‚à∑ u‚ÇÄ ++ v‚ÇÄ ‚â° y‚ÇÅ ‚à∑ u‚ÇÅ ++ v‚ÇÅ)
             + (Œ£ t Íûâ FA , (y‚ÇÄ ‚à∑ u‚ÇÄ ++ v‚ÇÄ ‚ñ∑ t) √ó (y‚ÇÅ ‚à∑ u‚ÇÅ ++ v‚ÇÅ ‚ñ∑ t))

     Œ¥ : type-of IH ‚Üí ‚àÄ {y‚ÇÄ y‚ÇÅ} ‚Üí y‚ÇÄ ‚â° y‚ÇÅ ‚Üí Œì y‚ÇÄ y‚ÇÅ
     Œ¥ (inl q)           {y‚ÇÄ} refl = inl (ap (y‚ÇÄ ‚à∑_) q)
     Œ¥ (inr (t , d , e)) {y‚ÇÄ} refl = inr ((y‚ÇÄ ‚à∑ t) , ‚à∑-‚ñ∑ y‚ÇÄ d , ‚à∑-‚ñ∑ y‚ÇÄ e)

     Œ≥ : Œì y‚ÇÄ y‚ÇÅ
     Œ≥ = Œ¥ IH (equal-heads p)

 Church-Rosser : (s t‚ÇÄ t‚ÇÅ : FA)
               ‚Üí s ‚ñ∑ t‚ÇÄ
               ‚Üí s ‚ñ∑ t‚ÇÅ
               ‚Üí (t‚ÇÄ ‚â° t‚ÇÅ) + (Œ£ t Íûâ FA , (t‚ÇÄ ‚ñ∑ t) √ó (t‚ÇÅ ‚ñ∑ t))
 Church-Rosser s t‚ÇÄ t‚ÇÅ (u‚ÇÄ , v‚ÇÄ , x‚ÇÄ , p‚ÇÄ , q‚ÇÄ) (u‚ÇÅ , v‚ÇÅ , x‚ÇÅ , p‚ÇÅ , q‚ÇÅ) = Œ≥ Œ¥
  where
   Œ¥ : (u‚ÇÄ ++ v‚ÇÄ ‚â° u‚ÇÅ ++ v‚ÇÅ) + (Œ£ t Íûâ FA , (u‚ÇÄ ++ v‚ÇÄ ‚ñ∑ t) √ó (u‚ÇÅ ++ v‚ÇÅ ‚ñ∑ t))
   Œ¥ = church-rosser u‚ÇÄ v‚ÇÄ u‚ÇÅ v‚ÇÅ x‚ÇÄ x‚ÇÅ (p‚ÇÄ ‚Åª¬π ‚àô p‚ÇÅ)

   Œ≥ : type-of Œ¥ ‚Üí (t‚ÇÄ ‚â° t‚ÇÅ) + (Œ£ t Íûâ FA , (t‚ÇÄ ‚ñ∑ t) √ó (t‚ÇÅ ‚ñ∑ t))
   Œ≥ (inl q)           = inl (q‚ÇÄ ‚àô q ‚àô q‚ÇÅ ‚Åª¬π)
   Œ≥ (inr (t , p , q)) = inr (t , transport (_‚ñ∑ t) (q‚ÇÄ ‚Åª¬π) p ,
                                  transport (_‚ñ∑ t) (q‚ÇÅ ‚Åª¬π) q)
\end{code}

It is noteworthy and remarkable that the above doesn't need decidable
equality on A. We repeat that this construction is due to Mines,
Richman and Ruttenberg

The following import defines

  _‚óÅ‚ñ∑_       the symmetric closure of _‚ñ∑_,
  _‚àø_        the symmetric, reflexive, transitive closure of _‚ñ∑_,
  _‚ñ∑*_       the reflexive, transitive closure of _‚ñ∑_,
  _‚ñ∑[ n ]_   the n-fold iteration of _‚ñ∑_.
  _‚óÅ‚ñ∑[ n ]_  the n-fold iteration of _‚óÅ‚ñ∑_.

and its submodule Church-Rosser-consequences develops some useful
consequences of the Church-Rosser property in a general setting.

\begin{code}

 open import SRTclosure
 open Church-Rosser-consequences {ùì§} {ùì§} _‚ñ∑_ public

\end{code}

The insertion of generators is trivially left cancellable before
quotienting:

\begin{code}

 Œ∑-lc : {a b : A} ‚Üí Œ∑ a ‚â° Œ∑ b ‚Üí a ‚â° b
 Œ∑-lc refl = refl

\end{code}

The following less trivial result, which relies on the Church-Rosser
property, will give that the insertion of generators is injective
after quotienting:

\begin{code}

 Œ∑-irreducible : {a : A} {s : FA} ‚Üí ¬¨ (Œ∑ a ‚ñ∑ s)
 Œ∑-irreducible ((x ‚à∑ []) , v , y , () , refl)
 Œ∑-irreducible ((x ‚à∑ y ‚à∑ u) , v , z , () , q)

 Œ∑-irreducible‚ãÜ : {a : A} {s : FA} ‚Üí Œ∑ a ‚ñ∑‚ãÜ s ‚Üí Œ∑ a ‚â° s
 Œ∑-irreducible‚ãÜ {a} {s} (n , r) = f n r
  where
   f : (n : ‚Ñï) ‚Üí Œ∑ a ‚ñ∑[ n ] s ‚Üí Œ∑ a ‚â° s
   f zero     refl = refl
   f (succ n) (t , r , i) = ùüò-elim (Œ∑-irreducible r)

 Œ∑-identifies-‚àø-related-points : {a b : A} ‚Üí Œ∑ a ‚àø Œ∑ b ‚Üí a ‚â° b
 Œ∑-identifies-‚àø-related-points {a} {b} e = Œ∑-lc p
  where
   œÉ : Œ£ s Íûâ FA , (Œ∑ a ‚ñ∑‚ãÜ s) √ó (Œ∑ b ‚ñ∑‚ãÜ s)
   œÉ = from-‚àø Church-Rosser (Œ∑ a) (Œ∑ b) e
   s = pr‚ÇÅ œÉ

   p = Œ∑ a ‚â°‚ü®  Œ∑-irreducible‚ãÜ (pr‚ÇÅ (pr‚ÇÇ œÉ)) ‚ü©
       s   ‚â°‚ü® (Œ∑-irreducible‚ãÜ (pr‚ÇÇ (pr‚ÇÇ œÉ)))‚Åª¬π ‚ü©
       Œ∑ b ‚àé

\end{code}

We need to work with the propositional truncation of _‚àø_ to construct
the free group, but most of the work will be done before truncation.

The following is for reasoning with chains of equivalences _‚àø_:

\begin{code}

 _‚àø‚ü®_‚ü©_ : (s : FA) {t u : FA} ‚Üí s ‚àø t ‚Üí t ‚àø u ‚Üí s ‚àø u
 _ ‚àø‚ü® p ‚ü© q = srt-transitive _‚ñ∑_ _ _ _ p q

 _‚àø‚àé : (s : FA) ‚Üí s ‚àø s
 _‚àø‚àé _ = srt-reflexive _‚ñ∑_ _

 infixr 0 _‚àø‚ü®_‚ü©_
 infix  1 _‚àø‚àé

 ‚â°-gives-‚àø : {s s' : FA} ‚Üí s ‚â° s' ‚Üí s ‚àø s'
 ‚â°-gives-‚àø {s} refl = srt-reflexive _‚ñ∑_ s

\end{code}

As discussed above, the group operation before quotienting is simply
concatenation, with the empty list as the neutral element.

Concatenation is a left congruence. We establish this in several
steps:

\begin{code}

 ++-‚ñ∑-left : (s s' t : FA) ‚Üí s ‚ñ∑ s' ‚Üí s ++ t ‚ñ∑ s' ++ t
 ++-‚ñ∑-left s s' t (u , v , x , p , q) = u , (v ++ t) , x , p' , q'
  where
   p' = s ++ t                            ‚â°‚ü® ap (_++ t) p ‚ü©
        (u ++ [ x ] ++ [ x ‚Åª ] ++ v) ++ t ‚â°‚ü® ++-assoc u ([ x ] ++ [ x ‚Åª ] ++ v) t ‚ü©
        u ++ [ x ] ++ [ x ‚Åª ] ++ v ++ t   ‚àé

   q' = s' ++ t       ‚â°‚ü® ap (_++ t) q ‚ü©
        (u ++ v) ++ t ‚â°‚ü® ++-assoc u v t ‚ü©
        u ++ v ++ t   ‚àé

 ++-‚óÅ‚ñ∑-left : (s s' t : FA) ‚Üí s ‚óÅ‚ñ∑ s' ‚Üí s ++ t ‚óÅ‚ñ∑ s' ++ t
 ++-‚óÅ‚ñ∑-left s s' t (inl a) = inl (++-‚ñ∑-left s s' t a)
 ++-‚óÅ‚ñ∑-left s s' t (inr a) = inr (++-‚ñ∑-left s' s t a)

 ++-iteration-left : (s s' t : FA) (n : ‚Ñï)
                   ‚Üí s ‚óÅ‚ñ∑[ n ] s'
                   ‚Üí s ++ t ‚óÅ‚ñ∑[ n ] s' ++ t
 ++-iteration-left s s  t zero     refl        = refl
 ++-iteration-left s s' t (succ n) (u , b , c) = (u ++ t) ,
                                                 ++-‚óÅ‚ñ∑-left s u t b ,
                                                 ++-iteration-left u s' t n c

 ++-cong-left : (s s' t : FA) ‚Üí s ‚àø s' ‚Üí s ++ t ‚àø s' ++ t
 ++-cong-left s s' t (n , a) = n , ++-iteration-left s s' t n a

\end{code}

It is also a right congruence:

\begin{code}

 ‚à∑-‚óÅ‚ñ∑ : (x : X) {s t : FA} ‚Üí s ‚óÅ‚ñ∑ t ‚Üí x ‚à∑ s ‚óÅ‚ñ∑ x ‚à∑ t
 ‚à∑-‚óÅ‚ñ∑ x (inl e) = inl (‚à∑-‚ñ∑ x e)
 ‚à∑-‚óÅ‚ñ∑ x (inr e) = inr (‚à∑-‚ñ∑ x e)

 ‚à∑-iteration : (x : X) {s t : FA} (n : ‚Ñï)
             ‚Üí s ‚óÅ‚ñ∑[ n ] t
             ‚Üí x ‚à∑ s ‚óÅ‚ñ∑[ n ] x ‚à∑ t
 ‚à∑-iteration x zero refl = refl
 ‚à∑-iteration x (succ n) (u , b , c) = (x ‚à∑ u) , ‚à∑-‚óÅ‚ñ∑ x b , ‚à∑-iteration x n c

 ‚à∑-cong : (x : X) {s t : FA} ‚Üí s ‚àø t ‚Üí x ‚à∑ s ‚àø x ‚à∑ t
 ‚à∑-cong x (n , a) = n , ‚à∑-iteration x n a

 ++-cong-right : (s {t t'} : FA) ‚Üí t ‚àø t' ‚Üí s ++ t ‚àø s ++ t'
 ++-cong-right []      e = e
 ++-cong-right (x ‚à∑ s) e = ‚à∑-cong x (++-cong-right s e)

\end{code}

And therefore it is a two-sided congruence:

\begin{code}

 ++-cong-‚àø : {s s' t t' : FA} ‚Üí s ‚àø s' ‚Üí t ‚àø t' ‚Üí s ++ t ‚àø s' ++ t'
 ++-cong-‚àø {s} {s'} {t} {t'} d e = s ++ t   ‚àø‚ü® ++-cong-left s s' t d ‚ü©
                                   s' ++ t  ‚àø‚ü® ++-cong-right s' e ‚ü©
                                   s' ++ t' ‚àø‚àé
\end{code}

We now construct the group inverse before quotienting. We reverse the
given list and formally invert all its elements:

\begin{code}

 finv : FA ‚Üí FA
 finv [] = []
 finv (x ‚à∑ s) = finv s ++ [ x ‚Åª ]

\end{code}

It is a congruence, which is proved in several steps:

\begin{code}

 finv-++ : (s t : FA) ‚Üí finv (s ++ t) ‚â° finv t ++ finv s
 finv-++ []      t = []-right-neutral (finv t)
 finv-++ (x ‚à∑ s) t = finv (s ++ t) ++ [ x ‚Åª ]      ‚â°‚ü® IH ‚ü©
                     (finv t ++ finv s) ++ [ x ‚Åª ] ‚â°‚ü® a ‚ü©
                     finv t ++ (finv s ++ [ x ‚Åª ]) ‚àé
  where
   IH = ap (_++ [ x ‚Åª ]) (finv-++ s t)
   a  = ++-assoc (finv t) (finv s) [ x ‚Åª ]

 finv-‚ñ∑ : {s t : FA} ‚Üí s ‚ñ∑ t ‚Üí finv s ‚ñ∑ finv t
 finv-‚ñ∑ {s} {t} (u , v , y , p , q) = finv v , finv u , y , p' , q'
  where
   p' = finv s                                      ‚â°‚ü® I ‚ü©
        finv (u ++ [ y ] ++ [ y ‚Åª ] ++ v)           ‚â°‚ü® II ‚ü©
        finv ([ y ] ++ [ y ‚Åª ] ++ v) ++ finv u      ‚â°‚ü® III ‚ü©
        finv (([ y ] ++ [ y ‚Åª ]) ++ v) ++ finv u    ‚â°‚ü® IV ‚ü©
        (finv v ++ [ (y ‚Åª)‚Åª ] ++ [ y ‚Åª ]) ++ finv u ‚â°‚ü® V ‚ü©
        (finv v ++ [ y ] ++ [ y ‚Åª ]) ++ finv u      ‚â°‚ü® VI ‚ü©
        finv v ++ [ y ] ++ [ y ‚Åª ] ++ finv u        ‚àé
    where
     I   = ap finv p
     II  = finv-++ u ([ y ] ++ [ y ‚Åª ] ++ v)
     III = ap (Œª - ‚Üí finv - ++ finv u) ((++-assoc [ y ] [ y ‚Åª ] v)‚Åª¬π)
     IV  = ap (_++ finv u) (finv-++ ([ y ] ++ [ y ‚Åª ]) v)
     V   = ap (Œª - ‚Üí (finv v ++ [ - ] ++ [ y ‚Åª ]) ++ finv u) (inv-invol y)
     VI  = ++-assoc (finv v) ([ y ] ++ [ y ‚Åª ]) (finv u)

   q' = finv t          ‚â°‚ü® ap finv q ‚ü©
        finv (u ++ v)   ‚â°‚ü® finv-++ u v ‚ü©
        finv v ++ finv u ‚àé

 finv-‚óÅ‚ñ∑ : {s t : FA} ‚Üí s ‚óÅ‚ñ∑ t ‚Üí finv s ‚óÅ‚ñ∑ finv t
 finv-‚óÅ‚ñ∑ (inl e) = inl (finv-‚ñ∑ e)
 finv-‚óÅ‚ñ∑ (inr e) = inr (finv-‚ñ∑ e)

 finv-iteration : {s t : FA} (n : ‚Ñï)
                ‚Üí s ‚óÅ‚ñ∑[ n ] t
                ‚Üí finv s ‚óÅ‚ñ∑[ n ] finv t
 finv-iteration zero refl = refl
 finv-iteration (succ n) (u , b , c) = finv u , finv-‚óÅ‚ñ∑ b , finv-iteration n c

 finv-cong-‚àø : {s t : FA} ‚Üí s ‚àø t ‚Üí finv s ‚àø finv t
 finv-cong-‚àø (n , a) = n , finv-iteration n a

\end{code}

The inverse really is an inverse:

\begin{code}

 finv-lemma-right : (x : X) ‚Üí [ x ] ++ [ x ‚Åª ] ‚àø []
 finv-lemma-right x = srt-extension _‚ñ∑_ _ [] ([] , [] , x , refl , refl)

 finv-lemma-left : (x : X) ‚Üí [ x ‚Åª ] ++ [ x ] ‚àø []
 finv-lemma-left x = srt-extension _‚ñ∑_ _ _
                      ([] ,
                       [] ,
                       (x ‚Åª) ,
                       ap (Œª - ‚Üí [ x ‚Åª ] ++ [ - ]) ((inv-invol x)‚Åª¬π) , refl)

 finv-right-‚àø : (s : FA) ‚Üí s ++ finv s ‚àø []
 finv-right-‚àø []      = srt-reflexive _‚ñ∑_ []
 finv-right-‚àø (x ‚à∑ s) = Œ≥
  where
   IH : s ++ finv s ‚àø []
   IH = finv-right-‚àø s

   Œ≥ = [ x ] ++ s ++ finv s ++ [ x ‚Åª ]   ‚àø‚ü® I ‚ü©
       [ x ] ++ (s ++ finv s) ++ [ x ‚Åª ] ‚àø‚ü® II ‚ü©
       [ x ] ++ [ x ‚Åª ]                  ‚àø‚ü® III ‚ü©
       []                                ‚àø‚àé
    where
     I   = ‚â°-gives-‚àø  (ap (x ‚à∑_) (++-assoc s (finv s) [ x ‚Åª ])‚Åª¬π)
     II  = ++-cong-right [ x ] (++-cong-left _ _ _ IH)
     III = finv-lemma-right x

 finv-left-‚àø : (s : FA) ‚Üí finv s ++ s ‚àø []
 finv-left-‚àø []      = srt-reflexive _‚ñ∑_ []
 finv-left-‚àø (x ‚à∑ s) = Œ≥
  where
   Œ≥ = (finv s ++ [ x ‚Åª ]) ++ (x ‚à∑ s)    ‚àø‚ü® I ‚ü©
       finv s ++ ([ x ‚Åª ] ++ [ x ] ++ s) ‚àø‚ü® II ‚ü©
       finv s ++ ([ x ‚Åª ] ++ [ x ]) ++ s ‚àø‚ü® III ‚ü©
       finv s ++ s                       ‚àø‚ü® IV ‚ü©
       []                                ‚àø‚àé
    where
     I   = ‚â°-gives-‚àø (++-assoc (finv s) [ x ‚Åª ] (x ‚à∑ s))
     II  = ‚â°-gives-‚àø (ap (finv s ++_) ((++-assoc [ x ‚Åª ] [ x ] s)‚Åª¬π))
     III = ++-cong-right (finv s) (++-cong-left _ _ _ (finv-lemma-left x))
     IV  = finv-left-‚àø s

\end{code}

The propositional, symmetric, reflexive, transitive closure of _‚ñ∑_:

\begin{code}

 module free-group-construction-step‚ÇÅ
         (pt : propositional-truncations-exist)
        where

  open PropositionalTruncation pt public

  _‚àæ_ : FA ‚Üí FA ‚Üí ùì§ Ãá
  x ‚àæ y = ‚à• x ‚àø y ‚à•

  infix 1 _‚àæ_

  Œ∑-identifies-‚àæ-related-points : {a b : A} ‚Üí is-set A ‚Üí Œ∑ a ‚àæ Œ∑ b ‚Üí a ‚â° b
  Œ∑-identifies-‚àæ-related-points i = ‚à•‚à•-rec i Œ∑-identifies-‚àø-related-points

  ++-cong : {s s' t t' : FA} ‚Üí s ‚àæ s' ‚Üí t ‚àæ t' ‚Üí s ++ t ‚àæ s' ++ t'
  ++-cong = ‚à•‚à•-functor‚ÇÇ ++-cong-‚àø

  finv-cong : {s t : FA} ‚Üí s ‚àæ t ‚Üí finv s ‚àæ finv t
  finv-cong = ‚à•‚à•-functor finv-cong-‚àø

  finv-right : (s : FA) ‚Üí s ++ finv s ‚àæ []
  finv-right s = ‚à£ finv-right-‚àø s ‚à£

  finv-left : (s : FA) ‚Üí finv s ++ s ‚àæ []
  finv-left s = ‚à£ finv-left-‚àø s ‚à£

\end{code}

To perform the quotient, we assume functional and propositional
extensionality.

\begin{code}

  module free-group-construction-step‚ÇÇ
          (fe : Fun-Ext)
          (pe : Prop-Ext)
        where

\end{code}

We work with quotients constructed in the module UF-Quotient using
functional extensionality and propositional extensionality, and no
higher-inductive types other than propositional truncation:

\begin{code}

   open import UF-Large-Quotient pt fe pe
   open psrt pt _‚ñ∑_ public

\end{code}

We have that _‚àæ_ is an equivalence relation:

\begin{code}

   ‚àæ-is-equiv-rel : is-equiv-rel _‚àæ_
   ‚àæ-is-equiv-rel = psrt-is-equiv-rel

   -‚àæ- : EqRel FA
   -‚àæ- = _‚àæ_ , ‚àæ-is-equiv-rel

\end{code}

The acronym "psrt" stands for propositional, reflexive, symmetric and
transitive closure of a relation, in this case _‚ñ∑_.

Our quotients constructed via propositional truncation increase
universe levels:

\begin{code}

   FA/‚àæ : ùì§ ‚Å∫ Ãá
   FA/‚àæ = FA / -‚àæ-

   Œ∑/‚àæ : FA ‚Üí FA/‚àæ
   Œ∑/‚àæ = Œ∑/ -‚àæ-

\end{code}

The above function Œ∑/‚àæ is the universal map into the quotient.

The insertion of generators of the free group is obtained by composing
the universal map into the quotient with our original map Œ∑ : A ‚Üí FA
that inserts the generators into the freely generated "pre-group" of
lists.

\begin{code}

   Œ∑·¥≥ ≥·µñ : A ‚Üí FA/‚àæ
   Œ∑·¥≥ ≥·µñ a = Œ∑/‚àæ (Œ∑ a)

\end{code}

It is noteworthy, and what we wanted to know, constructively, that the
inclusion of generators in the free group is an injection, or a
left-cancellable map:

\begin{code}

   Œ∑·¥≥ ≥·µñ-lc : is-set A ‚Üí {a b : A} ‚Üí Œ∑·¥≥ ≥·µñ a ‚â° Œ∑·¥≥ ≥·µñ b ‚Üí a ‚â° b
   Œ∑·¥≥ ≥·µñ-lc i p = Œ∑-identifies-‚àæ-related-points i
                (Œ∑/-relates-identified-points -‚àæ- p)

   Œ∑·¥≥ ≥·µñ-is-embedding : is-set A ‚Üí is-embedding Œ∑·¥≥ ≥·µñ
   Œ∑·¥≥ ≥·µñ-is-embedding i = lc-maps-into-sets-are-embeddings Œ∑·¥≥ ≥·µñ
                         (Œ∑·¥≥ ≥·µñ-lc i)
                         (quotient-is-set -‚àæ-)

   Œ∑/‚àæ-identifies-related-points : {s t : FA} ‚Üí s ‚àæ t ‚Üí Œ∑/‚àæ s ‚â° Œ∑/‚àæ t
   Œ∑/‚àæ-identifies-related-points = Œ∑/-identifies-related-points -‚àæ-

   Œ∑/‚àæ-relates-identified-points : {s t : FA} ‚Üí Œ∑/‚àæ s ‚â° Œ∑/‚àæ t ‚Üí s ‚àæ t
   Œ∑/‚àæ-relates-identified-points = Œ∑/-relates-identified-points -‚àæ-

\end{code}

We now need to make FA/‚àæ into a group. We will use "/" in names to
indicate constructions on the quotient type FA/‚àæ.

\begin{code}

   e/ : FA/‚àæ
   e/ = Œ∑/‚àæ []

   inv/ : FA/‚àæ ‚Üí FA/‚àæ
   inv/ = extension‚ÇÅ/ -‚àæ- finv finv-cong

   _¬∑_ : FA/‚àæ ‚Üí FA/‚àæ ‚Üí FA/‚àæ
   _¬∑_ = extension‚ÇÇ/ -‚àæ- _++_ ++-cong

\end{code}

The following two naturality conditions are crucial:

\begin{code}

   inv/-natural : (s : FA) ‚Üí inv/ (Œ∑/‚àæ s) ‚â° Œ∑/‚àæ (finv s)
   inv/-natural = naturality/ -‚àæ- finv finv-cong

   ¬∑-natural : (s t : FA) ‚Üí Œ∑/‚àæ s ¬∑ Œ∑/‚àæ t ‚â° Œ∑/‚àæ (s ++ t)
   ¬∑-natural = naturality‚ÇÇ/ -‚àæ- _++_ ++-cong

\end{code}

Next, to prove the groups laws, we use quotient induction "/-induction".

One can think of elements of FA/‚àæ as equivalence classes, and of Œ∑/‚àæ s
as the equivalence class of s. Then quotient induction says that in
order to prove a property of equivalence classes, it is enough to
prove it for all equivalence classes of given elements (this is proved
in the module UF-Quotient).

The following proofs rely on the above naturality conditions:

\begin{code}

   ln/ : left-neutral e/ _¬∑_
   ln/ = /-induction -‚àæ- (Œª x ‚Üí e/ ¬∑ x ‚â° x) (Œª x ‚Üí quotient-is-set -‚àæ-) Œ≥
    where
     Œ≥ : (s : FA) ‚Üí Œ∑/‚àæ [] ¬∑ Œ∑/‚àæ s ‚â° Œ∑/‚àæ s
     Œ≥ = ¬∑-natural []

   rn/ : right-neutral e/ _¬∑_
   rn/ = /-induction -‚àæ- (Œª x ‚Üí x ¬∑ e/ ‚â° x) (Œª x ‚Üí quotient-is-set -‚àæ-) Œ≥
    where
     Œ≥ : (s : FA) ‚Üí Œ∑/‚àæ s ¬∑ Œ∑/‚àæ [] ‚â° Œ∑/‚àæ s
     Œ≥ s = Œ∑/‚àæ s ¬∑ Œ∑/‚àæ [] ‚â°‚ü® ¬∑-natural s [] ‚ü©
           Œ∑/‚àæ (s ++ [])  ‚â°‚ü® ap Œ∑/‚àæ ([]-right-neutral s ‚Åª¬π) ‚ü©
           Œ∑/‚àæ s          ‚àé

   invl/ : (x : FA/‚àæ) ‚Üí inv/ x ¬∑ x ‚â° e/
   invl/ = /-induction -‚àæ- (Œª x ‚Üí (inv/ x ¬∑ x) ‚â° e/) (Œª x ‚Üí quotient-is-set -‚àæ-) Œ≥
    where
     Œ≥ : (s : FA) ‚Üí inv/ (Œ∑/‚àæ s) ¬∑ Œ∑/‚àæ s ‚â° e/
     Œ≥ s = inv/ (Œ∑/‚àæ s) ¬∑ Œ∑/‚àæ s  ‚â°‚ü® ap (_¬∑ Œ∑/‚àæ s) (inv/-natural s) ‚ü©
           Œ∑/‚àæ (finv s) ¬∑ Œ∑/‚àæ s  ‚â°‚ü® ¬∑-natural (finv s) s ‚ü©
           Œ∑/‚àæ (finv s ++ s)     ‚â°‚ü® Œ∑/‚àæ-identifies-related-points (finv-left s) ‚ü©
           Œ∑/‚àæ []                ‚â°‚ü® refl ‚ü©
           e/                    ‚àé

   invr/ : (x : FA/‚àæ) ‚Üí x ¬∑ inv/ x ‚â° e/
   invr/ = /-induction -‚àæ- (Œª x ‚Üí x ¬∑ inv/ x ‚â° e/) (Œª x ‚Üí quotient-is-set -‚àæ-) Œ≥
    where
     Œ≥ : (s : FA) ‚Üí Œ∑/‚àæ s ¬∑ inv/ (Œ∑/‚àæ s) ‚â° e/
     Œ≥ s = Œ∑/‚àæ s ¬∑ inv/ (Œ∑/‚àæ s)  ‚â°‚ü® ap (Œ∑/‚àæ s ¬∑_) (inv/-natural s) ‚ü©
           Œ∑/‚àæ s ¬∑ Œ∑/‚àæ (finv s)  ‚â°‚ü® ¬∑-natural s (finv s) ‚ü©
           Œ∑/‚àæ (s ++ finv s)     ‚â°‚ü® Œ∑/‚àæ-identifies-related-points (finv-right s) ‚ü©
           Œ∑/‚àæ []                ‚â°‚ü® refl ‚ü©
           e/                    ‚àé

   assoc/ : associative _¬∑_
   assoc/ = /-induction -‚àæ- (Œª x ‚Üí ‚àÄ y z ‚Üí (x ¬∑ y) ¬∑ z ‚â° x ¬∑ (y ¬∑ z))
              (Œª x ‚Üí Œ†‚ÇÇ-is-prop fe (Œª y z ‚Üí quotient-is-set -‚àæ-))
              (Œª s ‚Üí /-induction -‚àæ- (Œª y ‚Üí ‚àÄ z ‚Üí (Œ∑/‚àæ s ¬∑ y) ¬∑ z ‚â° Œ∑/‚àæ s ¬∑ (y ¬∑ z))
                       (Œª y ‚Üí Œ†-is-prop fe (Œª z ‚Üí quotient-is-set -‚àæ-))
                       (Œª t ‚Üí /-induction -‚àæ- (Œª z ‚Üí (Œ∑/‚àæ s ¬∑ Œ∑/‚àæ t) ¬∑ z ‚â° Œ∑/‚àæ s ¬∑ (Œ∑/‚àæ t ¬∑ z))
                                (Œª z ‚Üí quotient-is-set -‚àæ-)
                                (Œ≥ s t)))
    where
     Œ≥ : (s t u : FA) ‚Üí (Œ∑/‚àæ s ¬∑ Œ∑/‚àæ t) ¬∑ Œ∑/‚àæ u ‚â° Œ∑/‚àæ s ¬∑ (Œ∑/‚àæ t ¬∑ Œ∑/‚àæ u)
     Œ≥ s t u = (Œ∑/‚àæ s ¬∑ Œ∑/‚àæ t) ¬∑ Œ∑/‚àæ u ‚â°‚ü® ap (_¬∑ Œ∑/‚àæ u) (¬∑-natural s t) ‚ü©
               Œ∑/‚àæ (s ++ t) ¬∑ Œ∑/‚àæ u    ‚â°‚ü® ¬∑-natural (s ++ t) u ‚ü©
               Œ∑/‚àæ ((s ++ t) ++ u)     ‚â°‚ü® ap Œ∑/‚àæ (++-assoc s t u) ‚ü©
               Œ∑/‚àæ (s ++ (t ++ u))     ‚â°‚ü® (¬∑-natural s (t ++ u))‚Åª¬π ‚ü©
               Œ∑/‚àæ s ¬∑ Œ∑/‚àæ (t ++ u)    ‚â°‚ü® ap (Œ∑/‚àæ s ¬∑_) ((¬∑-natural t u)‚Åª¬π) ‚ü©
               Œ∑/‚àæ s ¬∑ (Œ∑/‚àæ t ¬∑ Œ∑/‚àæ u) ‚àé
\end{code}

So we have constructed a group with underlying set FA/‚àæ and a map
Œ∑·¥≥ ≥·µñ : A ‚Üí FA/‚àæ. We now put everyhing together:

\begin{code}

   ùìï : Group (ùì§ ‚Å∫)
   ùìï = (FA/‚àæ , _¬∑_ , quotient-is-set -‚àæ- , assoc/ , e/ , ln/ , rn/ ,
        (Œª x ‚Üí inv/ x , invl/ x , invr/ x))
\end{code}

To prove that Œ∑·¥≥ ≥·µñ is the universal map of the set A into a group, we
assume another group G with a map f : A ‚Üí G:

\begin{code}

   module free-group-construction-step‚ÇÉ
            {ùì• : Universe}
            (G : ùì• Ãá )
            (G-is-set : is-set G)
            (e : G)
            (invG : G ‚Üí G)
            (_*_ : G ‚Üí G ‚Üí G)
            (G-ln : left-neutral e _*_)
            (G-rn : right-neutral e _*_)
            (G-invl : (g : G) ‚Üí invG g * g ‚â° e)
            (G-invr : (g : G) ‚Üí g * invG g ‚â° e)
            (G-assoc : associative _*_)
            (f : A ‚Üí G)
         where

    ùìñ : Group ùì•
    ùìñ = (G , _*_ ,
         G-is-set , G-assoc , e , G-ln , G-rn ,
         (Œª x ‚Üí invG x , G-invl x , G-invr x))

\end{code}

Our objective is to construct f' from f making the universality
triangle commute. As a first step in the construction of f', we
construct a map h by induction of lists:

\begin{code}

    h : FA ‚Üí G
    h [] = e
    h ((‚ÇÄ , a) ‚à∑ s) = f a * h s
    h ((‚ÇÅ , a) ‚à∑ s) = invG (f a) * h s

\end{code}

We need the following property of h with respect to formal inverses:

\begin{code}

    h‚Åª : (x : X) ‚Üí h ([ x ] ++ [ x ‚Åª ]) ‚â° e

    h‚Åª (‚ÇÄ , a) = f a * (invG (f a) * e) ‚â°‚ü® ap (f a *_) (G-rn (invG (f a))) ‚ü©
                 f a * invG (f a)       ‚â°‚ü® G-invr (f a) ‚ü©
                 e                      ‚àé

    h‚Åª (‚ÇÅ , a) = invG (f a) * (f a * e) ‚â°‚ü® ap (invG (f a) *_) (G-rn (f a)) ‚ü©
                 invG (f a) * f a       ‚â°‚ü® G-invl (f a) ‚ü©
                 e                      ‚àé
\end{code}

By construction, the function h is a list homomorphism. It is also a
monoid homomorphism (it would be a group homomorphism if FA were a
group, which it isn't):

\begin{code}

    h-is-hom : (s t : FA) ‚Üí h (s ++ t) ‚â° h s * h t

    h-is-hom [] t =
     h  t    ‚â°‚ü® (G-ln (h t))‚Åª¬π ‚ü©
     e * h t ‚àé

    h-is-hom ((‚ÇÄ , a) ‚à∑ s) t =
     f a * h (s ++ t)    ‚â°‚ü® ap (f a *_) (h-is-hom s t) ‚ü©
     f a * (h s * h t)   ‚â°‚ü® (G-assoc (f a) (h s) (h t))‚Åª¬π ‚ü©
     (f a * h s) * h t   ‚â°‚ü® refl ‚ü©
     h (‚ÇÄ , a ‚à∑ s) * h t ‚àé

    h-is-hom (‚ÇÅ , a ‚à∑ s) t =
     invG (f a) * h (s ++ t)  ‚â°‚ü® ap (invG (f a) *_) (h-is-hom s t) ‚ü©
     invG (f a) * (h s * h t) ‚â°‚ü® (G-assoc (invG (f a)) (h s) (h t))‚Åª¬π ‚ü©
     (invG (f a) * h s) * h t ‚â°‚ü® refl ‚ü©
     h (‚ÇÅ , a ‚à∑ s) * h t      ‚àé

\end{code}

We also need the following property of the map h in order to construct
our desired group homomorphism f':

\begin{code}

    h-identifies-‚ñ∑-related-points : {s t : FA} ‚Üí s ‚ñ∑ t ‚Üí h s ‚â° h t
    h-identifies-‚ñ∑-related-points {s} {t} (u , v , y , p , q) =
       h s ‚â°‚ü® ap h p ‚ü©
       h (u ++ [ y ] ++ [ y ‚Åª ] ++ v) ‚â°‚ü® h-is-hom u ([ y ] ++ [ y ‚Åª ] ++ v) ‚ü©
       h u * h (y ‚à∑ y ‚Åª ‚à∑ v)          ‚â°‚ü® ap (h u *_) (h-is-hom (y ‚à∑ y ‚Åª ‚à∑ []) v) ‚ü©
       h u * (h (y ‚à∑ y ‚Åª ‚à∑ []) * h v) ‚â°‚ü® ap (Œª - ‚Üí h u * (- * h v)) (h‚Åª y) ‚ü©
       h u * (e * h v)                ‚â°‚ü® ap (h u *_) (G-ln (h v)) ‚ü©
       h u * h v                      ‚â°‚ü® (h-is-hom u v)‚Åª¬π ‚ü©
       h (u ++ v)                     ‚â°‚ü® ap h (q ‚Åª¬π) ‚ü©
       h t                            ‚àé

    h-identifies-‚ñ∑‚ãÜ-related-points : {s t : FA} ‚Üí s ‚ñ∑‚ãÜ t ‚Üí h s ‚â° h t
    h-identifies-‚ñ∑‚ãÜ-related-points {s} {t} (n , r) = Œ≥ n s t r
     where
      Œ≥ : (n : ‚Ñï) (s t : FA) ‚Üí s ‚ñ∑[ n ] t ‚Üí h s ‚â° h t
      Œ≥ zero s s refl  = refl
      Œ≥ (succ n) s t (u , r , i) = h s ‚â°‚ü® h-identifies-‚ñ∑-related-points r ‚ü©
                                   h u ‚â°‚ü® Œ≥ n u t i ‚ü©
                                   h t ‚àé

    h-identifies-‚àæ-related-points : {s t : FA} ‚Üí s ‚àæ t ‚Üí h s ‚â° h t
    h-identifies-‚àæ-related-points {s} {t} e = Œ≥
     where
      Œ¥ : (Œ£ u Íûâ FA , (s ‚ñ∑‚ãÜ u) √ó (t ‚ñ∑‚ãÜ u)) ‚Üí h s ‚â° h t
      Œ¥ (u , œÉ , œÑ) = h s ‚â°‚ü® (h-identifies-‚ñ∑‚ãÜ-related-points œÉ) ‚ü©
                      h u ‚â°‚ü® (h-identifies-‚ñ∑‚ãÜ-related-points œÑ)‚Åª¬π ‚ü©
                      h t ‚àé
      Œ≥ : h s ‚â° h t
      Œ≥ = ‚à•‚à•-rec G-is-set Œ¥ (‚à•‚à•-functor (from-‚àø Church-Rosser s t) e)

\end{code}

We can then finally construct the unique homorphism f' extending f
using the universal property of quotients, using the above map h:

\begin{code}

    f' : FA/‚àæ ‚Üí G
    f' = mediating-map/ -‚àæ- G-is-set h h-identifies-‚àæ-related-points

    f'-/triangle : f' ‚àò Œ∑/‚àæ ‚àº h
    f'-/triangle = universality-triangle/ -‚àæ- G-is-set h h-identifies-‚àæ-related-points

\end{code}

And from this we get the triangle for the universal property of the
free group:

\begin{code}

    f'-triangle : f' ‚àò Œ∑·¥≥ ≥·µñ ‚àº f
    f'-triangle a = f' (Œ∑/‚àæ (Œ∑ a)) ‚â°‚ü® f'-/triangle (Œ∑ a) ‚ü©
                    h (Œ∑ a)        ‚â°‚ü® refl ‚ü©
                    f a * e        ‚â°‚ü® G-rn (f a) ‚ü©
                    f a            ‚àé

\end{code}

Which is a group homomorphism (rather than merely a monoid
homomorphism like h):

\begin{code}

    f'-is-hom : is-hom ùìï ùìñ f'
    f'-is-hom {x} {y} = Œ≥ x y
     where
      Œ¥ : (s t : FA) ‚Üí f' (Œ∑/‚àæ s ¬∑ Œ∑/‚àæ t) ‚â° f' (Œ∑/‚àæ s) * f' (Œ∑/‚àæ t)
      Œ¥ s t = f' (Œ∑/‚àæ s ¬∑ Œ∑/‚àæ t)      ‚â°‚ü® I ‚ü©
              f' (Œ∑/‚àæ (s ++ t))       ‚â°‚ü® II ‚ü©
              h (s ++ t)              ‚â°‚ü® III ‚ü©
              h s * h t               ‚â°‚ü® IV ‚ü©
              f' (Œ∑/‚àæ s) * f' (Œ∑/‚àæ t) ‚àé
        where
         I   = ap f' (¬∑-natural s t)
         II  = f'-/triangle (s ++ t)
         III = h-is-hom s t
         IV  = ap‚ÇÇ _*_ ((f'-/triangle s)‚Åª¬π) ((f'-/triangle t)‚Åª¬π)

      Œ≥ : (x y : FA / -‚àæ-) ‚Üí f' (x ¬∑ y) ‚â° f' x * f' y
      Œ≥ = /-induction -‚àæ- (Œª x ‚Üí ‚àÄ y ‚Üí f' (x ¬∑ y) ‚â° f' x * f' y)
           (Œª x ‚Üí Œ†-is-prop fe (Œª y ‚Üí G-is-set))
           (Œª s ‚Üí /-induction -‚àæ- (Œª y ‚Üí f' (Œ∑/‚àæ s ¬∑ y) ‚â° f' (Œ∑/‚àæ s) * f' y)
                   (Œª a ‚Üí G-is-set)
                   (Œ¥ s))
\end{code}

Notice that for the following uniqueness property of f' we don't need
to assume that f‚ÇÄ and f‚ÇÅ are group homomorphisms:

\begin{code}

    f'-uniqueness-‚àæ : (f‚ÇÄ f‚ÇÅ : FA/‚àæ ‚Üí G) ‚Üí f‚ÇÄ ‚àò Œ∑/‚àæ ‚àº h ‚Üí f‚ÇÅ ‚àò Œ∑/‚àæ ‚àº h ‚Üí f‚ÇÄ ‚àº f‚ÇÅ
    f'-uniqueness-‚àæ f‚ÇÄ f‚ÇÅ p q = at-most-one-mediating-map/ -‚àæ- G-is-set f‚ÇÄ f‚ÇÅ
                                   (Œª s ‚Üí p s ‚àô (q s)‚Åª¬π)

\end{code}

But for this one we do:

\begin{code}

    f'-uniqueness' : (f‚ÇÄ f‚ÇÅ : FA/‚àæ ‚Üí G)
                  ‚Üí is-hom ùìï ùìñ f‚ÇÄ
                  ‚Üí is-hom ùìï ùìñ f‚ÇÅ
                  ‚Üí f‚ÇÄ ‚àò Œ∑·¥≥ ≥·µñ ‚àº f
                  ‚Üí f‚ÇÅ ‚àò Œ∑·¥≥ ≥·µñ ‚àº f
                  ‚Üí f‚ÇÄ ‚àº f‚ÇÅ
    f'-uniqueness' f‚ÇÄ f‚ÇÅ i‚ÇÄ i‚ÇÅ f‚ÇÄ-triangle f‚ÇÅ-triangle = Œ≥
     where
      p : f‚ÇÄ ‚àò Œ∑·¥≥ ≥·µñ ‚àº f‚ÇÅ ‚àò Œ∑·¥≥ ≥·µñ
      p x = f‚ÇÄ-triangle x ‚àô (f‚ÇÅ-triangle x)‚Åª¬π

      Œ¥ : (s : FA) ‚Üí f‚ÇÄ (Œ∑/‚àæ s) ‚â° f‚ÇÅ (Œ∑/‚àæ s)
      Œ¥ [] = f‚ÇÄ (Œ∑/‚àæ []) ‚â°‚ü® homs-preserve-unit ùìï ùìñ f‚ÇÄ i‚ÇÄ ‚ü©
             e           ‚â°‚ü® (homs-preserve-unit ùìï ùìñ f‚ÇÅ i‚ÇÅ)‚Åª¬π ‚ü©
             f‚ÇÅ (Œ∑/‚àæ []) ‚àé
      Œ¥ ((‚ÇÄ , a) ‚à∑ s) =
             f‚ÇÄ (Œ∑/‚àæ (Œ∑ a ++ s))    ‚â°‚ü® ap f‚ÇÄ ((¬∑-natural (Œ∑ a) s)‚Åª¬π) ‚ü©
             f‚ÇÄ (Œ∑·¥≥ ≥·µñ a ¬∑ Œ∑/‚àæ s)      ‚â°‚ü® i‚ÇÄ  ‚ü©
             f‚ÇÄ (Œ∑·¥≥ ≥·µñ a) * f‚ÇÄ (Œ∑/‚àæ s) ‚â°‚ü® ap‚ÇÇ _*_ (p a) (Œ¥ s) ‚ü©
             f‚ÇÅ (Œ∑·¥≥ ≥·µñ a) * f‚ÇÅ (Œ∑/‚àæ s) ‚â°‚ü® i‚ÇÅ ‚Åª¬π ‚ü©
             f‚ÇÅ (Œ∑·¥≥ ≥·µñ a ¬∑ Œ∑/‚àæ s)      ‚â°‚ü® ap f‚ÇÅ (¬∑-natural (Œ∑ a) s) ‚ü©
             f‚ÇÅ (Œ∑/‚àæ (Œ∑ a ++ s))    ‚àé
      Œ¥ ((‚ÇÅ , a) ‚à∑ s) =
             f‚ÇÄ (Œ∑/‚àæ (finv (Œ∑ a) ++ s))         ‚â°‚ü® I ‚ü©
             f‚ÇÄ (Œ∑/‚àæ (finv (Œ∑ a)) ¬∑ Œ∑/‚àæ s)      ‚â°‚ü® II ‚ü©
             f‚ÇÄ (Œ∑/‚àæ (finv (Œ∑ a))) * f‚ÇÄ (Œ∑/‚àæ s) ‚â°‚ü® III ‚ü©
             f‚ÇÄ (inv/ (Œ∑·¥≥ ≥·µñ a)) * f‚ÇÄ (Œ∑/‚àæ s)      ‚â°‚ü® IV ‚ü©
             invG (f‚ÇÄ (Œ∑·¥≥ ≥·µñ a)) * f‚ÇÄ (Œ∑/‚àæ s)      ‚â°‚ü® IH ‚ü©
             invG (f‚ÇÅ (Œ∑·¥≥ ≥·µñ a)) * f‚ÇÅ (Œ∑/‚àæ s)      ‚â°‚ü® IV' ‚ü©
             f‚ÇÅ (inv/ (Œ∑·¥≥ ≥·µñ a)) * f‚ÇÅ (Œ∑/‚àæ s)      ‚â°‚ü® III' ‚ü©
             f‚ÇÅ (Œ∑/‚àæ (finv (Œ∑ a))) * f‚ÇÅ (Œ∑/‚àæ s) ‚â°‚ü® II' ‚ü©
             f‚ÇÅ (Œ∑/‚àæ (finv (Œ∑ a)) ¬∑ Œ∑/‚àæ s)      ‚â°‚ü® I' ‚ü©
             f‚ÇÅ (Œ∑/‚àæ (finv (Œ∑ a) ++ s))         ‚àé
            where
             I    = ap f‚ÇÄ ((¬∑-natural (finv (Œ∑ a)) s)‚Åª¬π)
             II   = i‚ÇÄ
             III  = ap (Œª - ‚Üí f‚ÇÄ - * f‚ÇÄ (Œ∑/‚àæ s)) ((inv/-natural (Œ∑ a))‚Åª¬π)
             IV   = ap (_* f‚ÇÄ (Œ∑/‚àæ s)) (homs-preserve-invs ùìï ùìñ f‚ÇÄ i‚ÇÄ (Œ∑·¥≥ ≥·µñ a))
             IH   = ap‚ÇÇ (Œª - -' ‚Üí invG - * -') (p a) (Œ¥ s)
             IV'  = ap (_* f‚ÇÅ (Œ∑/‚àæ s)) ((homs-preserve-invs ùìï ùìñ f‚ÇÅ i‚ÇÅ (Œ∑·¥≥ ≥·µñ a))‚Åª¬π)
             III' = ap (Œª - ‚Üí f‚ÇÅ - * f‚ÇÅ (Œ∑/‚àæ s)) (inv/-natural (Œ∑ a))
             II'  = i‚ÇÅ ‚Åª¬π
             I'   = ap f‚ÇÅ (¬∑-natural (finv (Œ∑ a)) s)

      Œ≥ : f‚ÇÄ ‚àº f‚ÇÅ
      Œ≥ = /-induction -‚àæ- (Œª x ‚Üí f‚ÇÄ x ‚â° f‚ÇÅ x) (Œª x ‚Üí G-is-set) Œ¥

    f'-uniqueness : ‚àÉ! f' Íûâ (‚ü® ùìï ‚ü© ‚Üí ‚ü® ùìñ ‚ü©) , is-hom ùìï ùìñ f'
                                             √ó f' ‚àò Œ∑·¥≥ ≥·µñ ‚àº f
    f'-uniqueness = Œ≥
     where
      c : Œ£ f' Íûâ (‚ü® ùìï ‚ü© ‚Üí ‚ü® ùìñ ‚ü©) , is-hom ùìï ùìñ f' √ó f' ‚àò Œ∑·¥≥ ≥·µñ ‚àº f
      c = (f' , f'-is-hom , f'-triangle)

      i : is-central _ c
      i (f‚ÇÄ , f‚ÇÄ-is-hom , f‚ÇÄ-triangle) = to-subtype-‚â° a b
       where
        a : (f' : ‚ü® ùìï ‚ü© ‚Üí ‚ü® ùìñ ‚ü©) ‚Üí is-prop (is-hom ùìï ùìñ f' √ó f' ‚àò Œ∑·¥≥ ≥·µñ ‚àº f)
        a f' = √ó-is-prop (being-hom-is-prop fe ùìï ùìñ f')
                         (Œ†-is-prop fe (Œª a ‚Üí group-is-set ùìñ))

        b : f' ‚â° f‚ÇÄ
        b = dfunext fe (f'-uniqueness' f' f‚ÇÄ f'-is-hom f‚ÇÄ-is-hom f'-triangle f‚ÇÄ-triangle)

      Œ≥ : ‚àÉ! f' Íûâ (‚ü® ùìï ‚ü© ‚Üí ‚ü® ùìñ ‚ü©) , is-hom ùìï ùìñ f' √ó f' ‚àò Œ∑·¥≥ ≥·µñ ‚àº f
      Œ≥ = c , i

\end{code}

What we wanted to know is now proved.

We summarize the important parts in the following interface:

\begin{code}

module FreeGroupInterface
        (pt : propositional-truncations-exist)
        (fe : Fun-Ext)
        (pe : Prop-Ext)
        {ùì§ : Universe}
        (A : ùì§ Ãá )
       where

 open free-group-construction A
 open free-group-construction-step‚ÇÅ pt
 open free-group-construction-step‚ÇÇ fe pe

 free-group : Group (ùì§ ‚Å∫)
 free-group = ùìï

 Œ∑-free-group : A ‚Üí ‚ü® free-group ‚ü©
 Œ∑-free-group = Œ∑·¥≥ ≥·µñ

 Œ∑-free-group-is-embedding : is-set A ‚Üí is-embedding Œ∑-free-group
 Œ∑-free-group-is-embedding = Œ∑·¥≥ ≥·µñ-is-embedding

 module _ ((G , _*_ , G-is-set , G-assoc , e , l , r , inversion) : Group ùì•)
          (f : A ‚Üí G)
        where

  open free-group-construction-step‚ÇÉ
        G G-is-set e (Œª x ‚Üí pr‚ÇÅ (inversion x)) _*_ l r
        (Œª x ‚Üí pr‚ÇÅ (pr‚ÇÇ (inversion x))) (Œª x ‚Üí pr‚ÇÇ (pr‚ÇÇ (inversion x))) G-assoc f

  free-group-extension : ‚ü® free-group ‚ü© ‚Üí ‚ü® ùìñ ‚ü©
  free-group-extension = f'

  free-group-is-hom : is-hom free-group ùìñ free-group-extension
  free-group-is-hom = f'-is-hom

  free-group-triangle : free-group-extension ‚àò Œ∑-free-group ‚àº f
  free-group-triangle = f'-triangle

  extension-to-free-group-uniqueness :

    ‚àÉ! f' Íûâ (‚ü® free-group ‚ü© ‚Üí ‚ü® ùìñ ‚ü©) , is-hom free-group ùìñ f'
                                     √ó f' ‚àò Œ∑-free-group ‚àº f

  extension-to-free-group-uniqueness = f'-uniqueness

\end{code}

We now package the above into a single theorem.

Notice that we don't need to assume that the type A of
generators is a set to construct the free group and establish its
universal property.

But if A is a set then the universal map Œ∑ is left-cancellable and
hence an embedding.

\begin{code}

free-groups-exist : propositional-truncations-exist
                  ‚Üí Fun-Ext
                  ‚Üí Prop-Ext
                  ‚Üí (A : ùì§ Ãá )
                  ‚Üí Œ£ ùìï Íûâ Group (ùì§ ‚Å∫)
                  , Œ£ Œ∑ Íûâ (A ‚Üí ‚ü® ùìï ‚ü©)
                  , ((ùìñ : Group ùì•) (f : A ‚Üí ‚ü® ùìñ ‚ü©)
                        ‚Üí ‚àÉ! f' Íûâ (‚ü® ùìï ‚ü© ‚Üí ‚ü® ùìñ ‚ü©) , is-hom ùìï ùìñ f' √ó f' ‚àò Œ∑ ‚àº f)
                  √ó (is-set A ‚Üí is-embedding Œ∑)

free-groups-exist pt fe pe A = free-group A  ,
                               Œ∑-free-group A ,
                               extension-to-free-group-uniqueness A ,
                               Œ∑-free-group-is-embedding A
 where
  open FreeGroupInterface pt fe pe

\end{code}

Notice that the free group construction increases the universe level,
but the universal property eliminates into any universe. This is
because our construction of quotients via propositional truncation
increses universe levels. In the module FreeGroupOfLargeLocallySmallSet

we show that for a large, locally small type type A : ùì§‚Å∫, the free
group has a copy in the same universe ùì§+ as A, and moreover, if the
free group has a copy in ùì§ then so must have the type A.
