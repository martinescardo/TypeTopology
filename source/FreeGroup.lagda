Martin Escardo
January - February 2021.

In collaboration with Marc Bezem, Thierry Coquand and Peter Dybjer

We construct free groups in HoTT/UF in Agda without HIT's other than
propositional truncation, and with no consequence of univalence other
than function extensionality and propositional extensionality.

This is based on the book "A course in constructive algebra" by Ray
Mines, Fred Richman and Wim Ruitenburg, 1988. In particular, this
construction shows that the inclusion of generators is injective (and
hence an embedding in the sense of HoTT/UF). It is noteworthy and
surprising that the set of generators is not required to have
decidable equality.

This is part of Martin Escardo's Agda development TypeTopology,
whose philosophy is to be Spartan. At the moment we are a little bit
Athenian, though, with the use of Agda lists rather than Spartan-MLTT
constructed lists, although we intend to fix this in the future. (The
way to do it is already present in the module Fin.lagda.)

\begin{code}

{-# OPTIONS --without-K --safe --auto-inline #-} -- --exact-split

\end{code}

NB. This repository is supposed to use exact-split, but even though
everything has been developed using case-split, the exact-split check
fails (in Agda 2.6.1) in the helper function f of the function
church-rosser. This seems to be a bug, but we are not sure.

\begin{code}

module FreeGroup where

open import SpartanMLTT
open import Groups
open import Two
open import Two-Properties
open import List

open import UF-PropTrunc
open import UF-Univalence
open import UF-Base
open import UF-Subsingletons
open import UF-Subsingletons-FunExt
open import UF-Embeddings
open import UF-Equiv
open import UF-UA-FunExt
open import UF-FunExt

\end{code}

We now construct the group freely generated by a set A. The set-hood
requirement is needed later only, and so we don't include it as an
assumption in the following anonymous module:

\begin{code}

module free-group-construction
        {ğ“¤ : Universe}
        (A : ğ“¤ Ì‡ )
       where

 X : ğ“¤ Ì‡
 X = ğŸš Ã— A

 _â» : X â†’ X
 (n , a)â» = (complement n , a)

 inv-invol : (x : X) â†’ (x â»)â» â‰¡ x
 inv-invol (n , a) = ap (_, a) (complement-involutive n)

\end{code}

The idea is that list concatenation _++_ will be the group operation
after suitable quotienting, with the empty list [] as the neutral
element.

We will quotient the following type FA to get the undelying type of
the free group:

\begin{code}

 FA : ğ“¤ Ì‡
 FA = List X

 Î· : A â†’ FA
 Î· a = [ (â‚€ , a) ]

\end{code}

The type ğŸš has two elements â‚€ and â‚, and a prefix â‚ to an element a of
the type A means it is formally inverted. So in the inclusion of
generators Î· we indicate that the element a is not inverted by
prefixing it with â‚€.

We will quotient by the equivalence relation generated by the
following reduction relation:

\begin{code}

 _â–·_ : FA â†’ FA â†’ ğ“¤ Ì‡
 s â–· t = Î£ u ê‰ FA , Î£ v ê‰ FA , Î£ x ê‰ X , (s â‰¡ u ++ [ x ] ++ [ x â» ] ++ v)
                                       Ã— (t â‰¡ u ++ v)

 infix 1 _â–·_

 âˆ·-â–· : {s t : FA} (x : X) â†’ s â–· t â†’ x âˆ· s â–· x âˆ· t
 âˆ·-â–· x (u , v , y , p , q) = (x âˆ· u) , v , y , ap (x âˆ·_) p , ap (x âˆ·_) q

\end{code}

The following is a lemma for the Church-Rosser property, proved by
induction on uâ‚€ and uâ‚:

\begin{code}

 church-rosser : (uâ‚€ vâ‚€ uâ‚ vâ‚ : FA) (xâ‚€ xâ‚ : X)

               â†’ uâ‚€ ++  [ xâ‚€ ] ++ [ xâ‚€ â» ] ++ vâ‚€
               â‰¡ uâ‚ ++  [ xâ‚ ] ++ [ xâ‚ â» ] ++ vâ‚

               â†’ (uâ‚€ ++ vâ‚€ â‰¡ uâ‚ ++ vâ‚)
               + (Î£ t ê‰ FA , (uâ‚€ ++ vâ‚€ â–· t) Ã— (uâ‚ ++ vâ‚ â–· t))

 church-rosser uâ‚€ vâ‚€ uâ‚ vâ‚ xâ‚€ xâ‚ = f uâ‚€ uâ‚
  where
   f : (uâ‚€ uâ‚ : FA)
     â†’ uâ‚€ ++  [ xâ‚€ ] ++ [ xâ‚€ â» ] ++ vâ‚€ â‰¡ uâ‚ ++  [ xâ‚ ] ++ [ xâ‚ â» ] ++ vâ‚
     â†’ (uâ‚€ ++ vâ‚€ â‰¡ uâ‚ ++ vâ‚) + (Î£ t ê‰ FA , (uâ‚€ ++ vâ‚€ â–· t) Ã— (uâ‚ ++ vâ‚ â–· t))

   f [] [] p = inl Î³
    where
     have : xâ‚€ âˆ· xâ‚€ â»  âˆ· vâ‚€
          â‰¡ xâ‚ âˆ· xâ‚ â»  âˆ· vâ‚
     have = p

     Î³ : vâ‚€ â‰¡ vâ‚
     Î³ = equal-tails (equal-tails p)

   f [] (yâ‚ âˆ· []) p = inl Î³
    where
     have : xâ‚€ âˆ· xâ‚€ â» âˆ· vâ‚€
          â‰¡ yâ‚ âˆ· xâ‚   âˆ· xâ‚ â» âˆ· vâ‚
     have = p

     q = xâ‚ â»    â‰¡âŸ¨ ap _â» ((equal-heads (equal-tails p))â»Â¹) âŸ©
         (xâ‚€ â»)â» â‰¡âŸ¨ inv-invol xâ‚€ âŸ©
         xâ‚€      â‰¡âŸ¨ equal-heads p âŸ©
         yâ‚      âˆ

     Î³ : vâ‚€ â‰¡ yâ‚ âˆ· vâ‚
     Î³ = transport (Î» - â†’ vâ‚€ â‰¡ - âˆ· vâ‚) q (equal-tails (equal-tails p))

   f [] (yâ‚ âˆ· zâ‚ âˆ· uâ‚) p = inr Î³
    where
     have : xâ‚€ âˆ· xâ‚€ â» âˆ· vâ‚€
          â‰¡ yâ‚ âˆ· zâ‚   âˆ· uâ‚ ++ [ xâ‚ ] ++ [ xâ‚ â» ] ++ vâ‚
     have = p

     d' : uâ‚ ++ [ xâ‚ ] ++ [ xâ‚ â» ] ++ vâ‚ â–· uâ‚ ++ vâ‚
     d' = uâ‚ , vâ‚ , xâ‚ , refl , refl

     d : vâ‚€ â–· uâ‚ ++ vâ‚
     d = transport (_â–· uâ‚ ++ vâ‚) ((equal-tails (equal-tails p))â»Â¹) d'

     q = yâ‚ â» â‰¡âŸ¨ (ap (_â») (equal-heads p)â»Â¹) âŸ©
         xâ‚€ â» â‰¡âŸ¨ equal-heads (equal-tails p) âŸ©
         zâ‚   âˆ

     e' : yâ‚ âˆ· yâ‚ â» âˆ· uâ‚ ++ vâ‚ â–· uâ‚ ++ vâ‚
     e' = [] , (uâ‚ ++ vâ‚) , yâ‚ , refl , refl

     e : yâ‚ âˆ· zâ‚ âˆ· uâ‚ ++ vâ‚ â–· uâ‚ ++ vâ‚
     e = transport (Î» - â†’ yâ‚ âˆ· - âˆ· uâ‚ ++ vâ‚ â–· uâ‚ ++ vâ‚) q e'

     Î³ : Î£ t ê‰ FA , (vâ‚€ â–· t) Ã— (yâ‚ âˆ· zâ‚ âˆ· uâ‚ ++ vâ‚ â–· t)
     Î³ = (uâ‚ ++ vâ‚) , d , e

   f (yâ‚€ âˆ· []) [] p = inl Î³
    where
     have : yâ‚€ âˆ· xâ‚€   âˆ· xâ‚€ â» âˆ· vâ‚€
          â‰¡ xâ‚ âˆ· xâ‚ â» âˆ· vâ‚
     have = p

     Î³ = yâ‚€ âˆ· vâ‚€      â‰¡âŸ¨ ap (_âˆ· vâ‚€) (equal-heads p) âŸ©
         xâ‚ âˆ· vâ‚€      â‰¡âŸ¨ ap (_âˆ· vâ‚€) ((inv-invol xâ‚)â»Â¹) âŸ©
         (xâ‚ â»)â» âˆ· vâ‚€ â‰¡âŸ¨ ap (Î» - â†’ - â» âˆ· vâ‚€) ((equal-heads (equal-tails p))â»Â¹) âŸ©
         xâ‚€ â» âˆ· vâ‚€    â‰¡âŸ¨ equal-tails (equal-tails p) âŸ©
         vâ‚           âˆ

   f (yâ‚€ âˆ· zâ‚€ âˆ· uâ‚€) [] p = inr Î³
    where
     have : yâ‚€ âˆ· zâ‚€   âˆ· uâ‚€ ++ [ xâ‚€ ] ++ [ xâ‚€ â» ] ++ vâ‚€
          â‰¡ xâ‚ âˆ· xâ‚ â» âˆ· vâ‚
     have = p

     q = yâ‚€ â» â‰¡âŸ¨ ap (_â») (equal-heads p) âŸ©
         xâ‚ â» â‰¡âŸ¨ (equal-heads (equal-tails p))â»Â¹ âŸ©
         zâ‚€   âˆ

     d' : yâ‚€ âˆ· yâ‚€ â» âˆ· uâ‚€ ++ vâ‚€ â–· uâ‚€ ++ vâ‚€
     d' = [] , (uâ‚€ ++ vâ‚€) , yâ‚€ , refl , refl

     d : yâ‚€ âˆ· zâ‚€ âˆ· uâ‚€ ++ vâ‚€ â–· uâ‚€ ++ vâ‚€
     d = transport (Î» - â†’ yâ‚€ âˆ· - âˆ· uâ‚€ ++ vâ‚€ â–· uâ‚€ ++ vâ‚€) q d'

     e' : uâ‚€ ++ [ xâ‚€ ] ++ [ xâ‚€ â» ] ++ vâ‚€ â–· uâ‚€ ++ vâ‚€
     e' = uâ‚€ , vâ‚€ , xâ‚€ , refl , refl

     e : vâ‚ â–· uâ‚€ ++ vâ‚€
     e = transport (_â–· uâ‚€ ++ vâ‚€) (equal-tails (equal-tails p)) e'

     Î³ : Î£ t ê‰ FA , (yâ‚€ âˆ· zâ‚€ âˆ· uâ‚€ ++ vâ‚€ â–· t) Ã— (vâ‚ â–· t)
     Î³ = (uâ‚€ ++ vâ‚€) , d , e

   f (yâ‚€ âˆ· uâ‚€) (yâ‚ âˆ· uâ‚) p = Î³
    where
     have : yâ‚€ âˆ· uâ‚€ ++ [ xâ‚€ ] ++ [ xâ‚€ â» ] ++ vâ‚€
          â‰¡ yâ‚ âˆ· uâ‚ ++ [ xâ‚ ] ++ [ xâ‚ â» ] ++ vâ‚
     have = p

     IH : (uâ‚€ ++ vâ‚€ â‰¡ uâ‚ ++ vâ‚) + (Î£ t ê‰ FA , (uâ‚€ ++ vâ‚€ â–· t) Ã— (uâ‚ ++ vâ‚ â–· t))
     IH = f uâ‚€ uâ‚ (equal-tails p)

     Î“ : X â†’ X â†’ ğ“¤ Ì‡
     Î“ yâ‚€ yâ‚ = (yâ‚€ âˆ· uâ‚€ ++ vâ‚€ â‰¡ yâ‚ âˆ· uâ‚ ++ vâ‚)
             + (Î£ t ê‰ FA , (yâ‚€ âˆ· uâ‚€ ++ vâ‚€ â–· t) Ã— (yâ‚ âˆ· uâ‚ ++ vâ‚ â–· t))

     Î´ : type-of IH â†’ âˆ€ {yâ‚€ yâ‚} â†’ yâ‚€ â‰¡ yâ‚ â†’ Î“ yâ‚€ yâ‚
     Î´ (inl q)           {yâ‚€} refl = inl (ap (yâ‚€ âˆ·_) q)
     Î´ (inr (t , d , e)) {yâ‚€} refl = inr ((yâ‚€ âˆ· t) , âˆ·-â–· yâ‚€ d , âˆ·-â–· yâ‚€ e)

     Î³ : Î“ yâ‚€ yâ‚
     Î³ = Î´ IH (equal-heads p)

 Church-Rosser : (s tâ‚€ tâ‚ : FA)
               â†’ s â–· tâ‚€
               â†’ s â–· tâ‚
               â†’ (tâ‚€ â‰¡ tâ‚) + (Î£ t ê‰ FA , (tâ‚€ â–· t) Ã— (tâ‚ â–· t))
 Church-Rosser s tâ‚€ tâ‚ (uâ‚€ , vâ‚€ , xâ‚€ , pâ‚€ , qâ‚€) (uâ‚ , vâ‚ , xâ‚ , pâ‚ , qâ‚) = Î³ Î´
  where
   Î´ : (uâ‚€ ++ vâ‚€ â‰¡ uâ‚ ++ vâ‚) + (Î£ t ê‰ FA , (uâ‚€ ++ vâ‚€ â–· t) Ã— (uâ‚ ++ vâ‚ â–· t))
   Î´ = church-rosser uâ‚€ vâ‚€ uâ‚ vâ‚ xâ‚€ xâ‚ (pâ‚€ â»Â¹ âˆ™ pâ‚)

   Î³ : type-of Î´ â†’ (tâ‚€ â‰¡ tâ‚) + (Î£ t ê‰ FA , (tâ‚€ â–· t) Ã— (tâ‚ â–· t))
   Î³ (inl q)           = inl (qâ‚€ âˆ™ q âˆ™ qâ‚ â»Â¹)
   Î³ (inr (t , p , q)) = inr (t , transport (_â–· t) (qâ‚€ â»Â¹) p ,
                                  transport (_â–· t) (qâ‚ â»Â¹) q)
\end{code}

It is noteworthy and remarkable that the above doesn't need decidable
equality on A. We repeat that this construction is due to Mines,
Richman and Ruttenberg

The following import defines

  _â—â–·_       the symmetric closure of _â–·_,
  _âˆ¿_        the symmetric, reflexive, transitive closure of _â–·_,
  _â–·*_       the reflexive, transitive closure of _â–·_,
  _â–·[ n ]_   the n-fold iteration of _â–·_.
  _â—â–·[ n ]_  the n-fold iteration of _â—â–·_.

and its submodule Church-Rosser-consequences develops some useful
consequences of the Church-Rosser property in a general setting.

\begin{code}

 open import SRTclosure
 open Church-Rosser-consequences {ğ“¤} {ğ“¤} _â–·_ public

\end{code}

The insertion of generators is trivially left cancellable before
quotienting:

\begin{code}

 Î·-lc : {a b : A} â†’ Î· a â‰¡ Î· b â†’ a â‰¡ b
 Î·-lc refl = refl

\end{code}

The following less trivial result, which relies on the Church-Rosser
property, will give that the insertion of generators is injective
after quotienting:

\begin{code}

 Î·-irreducible : {a : A} {s : FA} â†’ Â¬ (Î· a â–· s)
 Î·-irreducible ((x âˆ· []) , v , y , () , refl)
 Î·-irreducible ((x âˆ· y âˆ· u) , v , z , () , q)

 Î·-irreducibleâ‹† : {a : A} {s : FA} â†’ Î· a â–·â‹† s â†’ Î· a â‰¡ s
 Î·-irreducibleâ‹† {a} {s} (n , r) = f n r
  where
   f : (n : â„•) â†’ Î· a â–·[ n ] s â†’ Î· a â‰¡ s
   f zero     refl = refl
   f (succ n) (t , r , i) = ğŸ˜-elim (Î·-irreducible r)

 Î·-identifies-âˆ¿-related-points : {a b : A} â†’ Î· a âˆ¿ Î· b â†’ a â‰¡ b
 Î·-identifies-âˆ¿-related-points {a} {b} e = Î·-lc p
  where
   Ïƒ : Î£ s ê‰ FA , (Î· a â–·â‹† s) Ã— (Î· b â–·â‹† s)
   Ïƒ = from-âˆ¿ Church-Rosser (Î· a) (Î· b) e
   s = prâ‚ Ïƒ

   p = Î· a â‰¡âŸ¨  Î·-irreducibleâ‹† (prâ‚ (prâ‚‚ Ïƒ)) âŸ©
       s   â‰¡âŸ¨ (Î·-irreducibleâ‹† (prâ‚‚ (prâ‚‚ Ïƒ)))â»Â¹ âŸ©
       Î· b âˆ

\end{code}

We need to work with the propositional truncation of _âˆ¿_ to construct
the free group, but most of the work will be done before truncation.

The following is for reasoning with chains of equivalences _âˆ¿_:

\begin{code}

 _âˆ¿âŸ¨_âŸ©_ : (s : FA) {t u : FA} â†’ s âˆ¿ t â†’ t âˆ¿ u â†’ s âˆ¿ u
 _ âˆ¿âŸ¨ p âŸ© q = srt-transitive _â–·_ _ _ _ p q

 _âˆ¿âˆ : (s : FA) â†’ s âˆ¿ s
 _âˆ¿âˆ _ = srt-reflexive _â–·_ _

 infixr 0 _âˆ¿âŸ¨_âŸ©_
 infix  1 _âˆ¿âˆ

 â‰¡-gives-âˆ¿ : {s s' : FA} â†’ s â‰¡ s' â†’ s âˆ¿ s'
 â‰¡-gives-âˆ¿ {s} refl = srt-reflexive _â–·_ s

\end{code}

As discussed above, the group operation before quotienting is simply
concatenation, with the empty list as the neutral element.

Concatenation is a left congruence. We establish this in several
steps:

\begin{code}

 ++-â–·-left : (s s' t : FA) â†’ s â–· s' â†’ s ++ t â–· s' ++ t
 ++-â–·-left s s' t (u , v , x , p , q) = u , (v ++ t) , x , p' , q'
  where
   p' = s ++ t                            â‰¡âŸ¨ ap (_++ t) p âŸ©
        (u ++ [ x ] ++ [ x â» ] ++ v) ++ t â‰¡âŸ¨ ++-assoc u ([ x ] ++ [ x â» ] ++ v) t âŸ©
        u ++ [ x ] ++ [ x â» ] ++ v ++ t   âˆ

   q' = s' ++ t       â‰¡âŸ¨ ap (_++ t) q âŸ©
        (u ++ v) ++ t â‰¡âŸ¨ ++-assoc u v t âŸ©
        u ++ v ++ t   âˆ

 ++-â—â–·-left : (s s' t : FA) â†’ s â—â–· s' â†’ s ++ t â—â–· s' ++ t
 ++-â—â–·-left s s' t (inl a) = inl (++-â–·-left s s' t a)
 ++-â—â–·-left s s' t (inr a) = inr (++-â–·-left s' s t a)

 ++-iteration-left : (s s' t : FA) (n : â„•)
                   â†’ s â—â–·[ n ] s'
                   â†’ s ++ t â—â–·[ n ] s' ++ t
 ++-iteration-left s s  t zero     refl        = refl
 ++-iteration-left s s' t (succ n) (u , b , c) = (u ++ t) ,
                                                 ++-â—â–·-left s u t b ,
                                                 ++-iteration-left u s' t n c

 ++-cong-left : (s s' t : FA) â†’ s âˆ¿ s' â†’ s ++ t âˆ¿ s' ++ t
 ++-cong-left s s' t (n , a) = n , ++-iteration-left s s' t n a

\end{code}

It is also a right congruence:

\begin{code}

 âˆ·-â—â–· : (x : X) {s t : FA} â†’ s â—â–· t â†’ x âˆ· s â—â–· x âˆ· t
 âˆ·-â—â–· x (inl e) = inl (âˆ·-â–· x e)
 âˆ·-â—â–· x (inr e) = inr (âˆ·-â–· x e)

 âˆ·-iteration : (x : X) {s t : FA} (n : â„•)
             â†’ s â—â–·[ n ] t
             â†’ x âˆ· s â—â–·[ n ] x âˆ· t
 âˆ·-iteration x zero refl = refl
 âˆ·-iteration x (succ n) (u , b , c) = (x âˆ· u) , âˆ·-â—â–· x b , âˆ·-iteration x n c

 âˆ·-cong : (x : X) {s t : FA} â†’ s âˆ¿ t â†’ x âˆ· s âˆ¿ x âˆ· t
 âˆ·-cong x (n , a) = n , âˆ·-iteration x n a

 ++-cong-right : (s {t t'} : FA) â†’ t âˆ¿ t' â†’ s ++ t âˆ¿ s ++ t'
 ++-cong-right []      e = e
 ++-cong-right (x âˆ· s) e = âˆ·-cong x (++-cong-right s e)

\end{code}

And therefore it is a two-sided congruence:

\begin{code}

 ++-cong-âˆ¿ : {s s' t t' : FA} â†’ s âˆ¿ s' â†’ t âˆ¿ t' â†’ s ++ t âˆ¿ s' ++ t'
 ++-cong-âˆ¿ {s} {s'} {t} {t'} d e = s ++ t   âˆ¿âŸ¨ ++-cong-left s s' t d âŸ©
                                   s' ++ t  âˆ¿âŸ¨ ++-cong-right s' e âŸ©
                                   s' ++ t' âˆ¿âˆ
\end{code}

We now construct the group inverse before quotienting. We reverse the
given list and formally invert all its elements:

\begin{code}

 finv : FA â†’ FA
 finv [] = []
 finv (x âˆ· s) = finv s ++ [ x â» ]

\end{code}

It is a congruence, which is proved in several steps:

\begin{code}

 finv-++ : (s t : FA) â†’ finv (s ++ t) â‰¡ finv t ++ finv s
 finv-++ []      t = []-right-neutral (finv t)
 finv-++ (x âˆ· s) t = finv (s ++ t) ++ [ x â» ]      â‰¡âŸ¨ IH âŸ©
                     (finv t ++ finv s) ++ [ x â» ] â‰¡âŸ¨ a âŸ©
                     finv t ++ (finv s ++ [ x â» ]) âˆ
  where
   IH = ap (_++ [ x â» ]) (finv-++ s t)
   a  = ++-assoc (finv t) (finv s) [ x â» ]

 finv-â–· : {s t : FA} â†’ s â–· t â†’ finv s â–· finv t
 finv-â–· {s} {t} (u , v , y , p , q) = finv v , finv u , y , p' , q'
  where
   p' = finv s                                      â‰¡âŸ¨ I âŸ©
        finv (u ++ [ y ] ++ [ y â» ] ++ v)           â‰¡âŸ¨ II âŸ©
        finv ([ y ] ++ [ y â» ] ++ v) ++ finv u      â‰¡âŸ¨ III âŸ©
        finv (([ y ] ++ [ y â» ]) ++ v) ++ finv u    â‰¡âŸ¨ IV âŸ©
        (finv v ++ [ (y â»)â» ] ++ [ y â» ]) ++ finv u â‰¡âŸ¨ V âŸ©
        (finv v ++ [ y ] ++ [ y â» ]) ++ finv u      â‰¡âŸ¨ VI âŸ©
        finv v ++ [ y ] ++ [ y â» ] ++ finv u        âˆ
    where
     I   = ap finv p
     II  = finv-++ u ([ y ] ++ [ y â» ] ++ v)
     III = ap (Î» - â†’ finv - ++ finv u) ((++-assoc [ y ] [ y â» ] v)â»Â¹)
     IV  = ap (_++ finv u) (finv-++ ([ y ] ++ [ y â» ]) v)
     V   = ap (Î» - â†’ (finv v ++ [ - ] ++ [ y â» ]) ++ finv u) (inv-invol y)
     VI  = ++-assoc (finv v) ([ y ] ++ [ y â» ]) (finv u)

   q' = finv t          â‰¡âŸ¨ ap finv q âŸ©
        finv (u ++ v)   â‰¡âŸ¨ finv-++ u v âŸ©
        finv v ++ finv u âˆ

 finv-â—â–· : {s t : FA} â†’ s â—â–· t â†’ finv s â—â–· finv t
 finv-â—â–· (inl e) = inl (finv-â–· e)
 finv-â—â–· (inr e) = inr (finv-â–· e)

 finv-iteration : {s t : FA} (n : â„•)
                â†’ s â—â–·[ n ] t
                â†’ finv s â—â–·[ n ] finv t
 finv-iteration zero refl = refl
 finv-iteration (succ n) (u , b , c) = finv u , finv-â—â–· b , finv-iteration n c

 finv-cong-âˆ¿ : {s t : FA} â†’ s âˆ¿ t â†’ finv s âˆ¿ finv t
 finv-cong-âˆ¿ (n , a) = n , finv-iteration n a

\end{code}

The inverse really is an inverse:

\begin{code}

 finv-lemma-right : (x : X) â†’ [ x ] ++ [ x â» ] âˆ¿ []
 finv-lemma-right x = srt-extension _â–·_ _ [] ([] , [] , x , refl , refl)

 finv-lemma-left : (x : X) â†’ [ x â» ] ++ [ x ] âˆ¿ []
 finv-lemma-left x = srt-extension _â–·_ _ _
                      ([] ,
                       [] ,
                       (x â») ,
                       ap (Î» - â†’ [ x â» ] ++ [ - ]) ((inv-invol x)â»Â¹) , refl)

 finv-right-âˆ¿ : (s : FA) â†’ s ++ finv s âˆ¿ []
 finv-right-âˆ¿ []      = srt-reflexive _â–·_ []
 finv-right-âˆ¿ (x âˆ· s) = Î³
  where
   IH : s ++ finv s âˆ¿ []
   IH = finv-right-âˆ¿ s

   Î³ = [ x ] ++ s ++ finv s ++ [ x â» ]   âˆ¿âŸ¨ I âŸ©
       [ x ] ++ (s ++ finv s) ++ [ x â» ] âˆ¿âŸ¨ II âŸ©
       [ x ] ++ [ x â» ]                  âˆ¿âŸ¨ III âŸ©
       []                                âˆ¿âˆ
    where
     I   = â‰¡-gives-âˆ¿  (ap (x âˆ·_) (++-assoc s (finv s) [ x â» ])â»Â¹)
     II  = ++-cong-right [ x ] (++-cong-left _ _ _ IH)
     III = finv-lemma-right x

 finv-left-âˆ¿ : (s : FA) â†’ finv s ++ s âˆ¿ []
 finv-left-âˆ¿ []      = srt-reflexive _â–·_ []
 finv-left-âˆ¿ (x âˆ· s) = Î³
  where
   Î³ = (finv s ++ [ x â» ]) ++ (x âˆ· s)    âˆ¿âŸ¨ I âŸ©
       finv s ++ ([ x â» ] ++ [ x ] ++ s) âˆ¿âŸ¨ II âŸ©
       finv s ++ ([ x â» ] ++ [ x ]) ++ s âˆ¿âŸ¨ III âŸ©
       finv s ++ s                       âˆ¿âŸ¨ IV âŸ©
       []                                âˆ¿âˆ
    where
     I   = â‰¡-gives-âˆ¿ (++-assoc (finv s) [ x â» ] (x âˆ· s))
     II  = â‰¡-gives-âˆ¿ (ap (finv s ++_) ((++-assoc [ x â» ] [ x ] s)â»Â¹))
     III = ++-cong-right (finv s) (++-cong-left _ _ _ (finv-lemma-left x))
     IV  = finv-left-âˆ¿ s

\end{code}

The propositional, symmetric, reflexive, transitive closure of _â–·_:

\begin{code}

 module free-group-construction-stepâ‚
         (pt : propositional-truncations-exist)
        where

  open PropositionalTruncation pt public

  _âˆ¾_ : FA â†’ FA â†’ ğ“¤ Ì‡
  x âˆ¾ y = âˆ¥ x âˆ¿ y âˆ¥

  infix 1 _âˆ¾_

  Î·-identifies-âˆ¾-related-points : {a b : A} â†’ is-set A â†’ Î· a âˆ¾ Î· b â†’ a â‰¡ b
  Î·-identifies-âˆ¾-related-points i = âˆ¥âˆ¥-rec i Î·-identifies-âˆ¿-related-points

  ++-cong : {s s' t t' : FA} â†’ s âˆ¾ s' â†’ t âˆ¾ t' â†’ s ++ t âˆ¾ s' ++ t'
  ++-cong = âˆ¥âˆ¥-functorâ‚‚ ++-cong-âˆ¿

  finv-cong : {s t : FA} â†’ s âˆ¾ t â†’ finv s âˆ¾ finv t
  finv-cong = âˆ¥âˆ¥-functor finv-cong-âˆ¿

  finv-right : (s : FA) â†’ s ++ finv s âˆ¾ []
  finv-right s = âˆ£ finv-right-âˆ¿ s âˆ£

  finv-left : (s : FA) â†’ finv s ++ s âˆ¾ []
  finv-left s = âˆ£ finv-left-âˆ¿ s âˆ£

\end{code}

To perform the quotient, we assume functional and propositional
extensionality.

\begin{code}

  module free-group-construction-stepâ‚‚
          (fe : Fun-Ext)
          (pe : Prop-Ext)
        where

\end{code}

We work with quotients constructed in the module UF-Quotient using
functional extensionality and propositional extensionality, and no
higher-inductive types other than propositional truncation:

\begin{code}

   open import UF-Large-Quotient pt fe pe
   open psrt pt _â–·_ public

\end{code}

We have that _âˆ¾_ is an equivalence relation:

\begin{code}

   âˆ¾-is-equiv-rel : is-equiv-rel _âˆ¾_
   âˆ¾-is-equiv-rel = psrt-is-equiv-rel

   -âˆ¾- : EqRel FA
   -âˆ¾- = _âˆ¾_ , âˆ¾-is-equiv-rel

\end{code}

The acronym "psrt" stands for propositional, reflexive, symmetric and
transitive closure of a relation, in this case _â–·_.

Our quotients constructed via propositional truncation increase
universe levels:

\begin{code}

   FA/âˆ¾ : ğ“¤ âº Ì‡
   FA/âˆ¾ = FA / -âˆ¾-

   Î·/âˆ¾ : FA â†’ FA/âˆ¾
   Î·/âˆ¾ = Î·/ -âˆ¾-

\end{code}

The above function Î·/âˆ¾ is the universal map into the quotient.

The insertion of generators of the free group is obtained by composing
the universal map into the quotient with our original map Î· : A â†’ FA
that inserts the generators into the freely generated "pre-group" of
lists.

\begin{code}

   Î·á´³Ê³áµ– : A â†’ FA/âˆ¾
   Î·á´³Ê³áµ– a = Î·/âˆ¾ (Î· a)

\end{code}

It is noteworthy, and what we wanted to know, constructively, that the
inclusion of generators in the free group is an injection, or a
left-cancellable map:

\begin{code}

   Î·á´³Ê³áµ–-lc : is-set A â†’ {a b : A} â†’ Î·á´³Ê³áµ– a â‰¡ Î·á´³Ê³áµ– b â†’ a â‰¡ b
   Î·á´³Ê³áµ–-lc i p = Î·-identifies-âˆ¾-related-points i
                (Î·/-relates-identified-points -âˆ¾- p)

   Î·á´³Ê³áµ–-is-embedding : is-set A â†’ is-embedding Î·á´³Ê³áµ–
   Î·á´³Ê³áµ–-is-embedding i = lc-maps-into-sets-are-embeddings Î·á´³Ê³áµ–
                         (Î·á´³Ê³áµ–-lc i)
                         (quotient-is-set -âˆ¾-)

   Î·/âˆ¾-identifies-related-points : {s t : FA} â†’ s âˆ¾ t â†’ Î·/âˆ¾ s â‰¡ Î·/âˆ¾ t
   Î·/âˆ¾-identifies-related-points = Î·/-identifies-related-points -âˆ¾-

   Î·/âˆ¾-relates-identified-points : {s t : FA} â†’ Î·/âˆ¾ s â‰¡ Î·/âˆ¾ t â†’ s âˆ¾ t
   Î·/âˆ¾-relates-identified-points = Î·/-relates-identified-points -âˆ¾-

\end{code}

We now need to make FA/âˆ¾ into a group. We will use "/" in names to
indicate constructions on the quotient type FA/âˆ¾.

\begin{code}

   e/ : FA/âˆ¾
   e/ = Î·/âˆ¾ []

   inv/ : FA/âˆ¾ â†’ FA/âˆ¾
   inv/ = extensionâ‚/ -âˆ¾- finv finv-cong

   _Â·_ : FA/âˆ¾ â†’ FA/âˆ¾ â†’ FA/âˆ¾
   _Â·_ = extensionâ‚‚/ -âˆ¾- _++_ ++-cong

\end{code}

The following two naturality conditions are crucial:

\begin{code}

   inv/-natural : (s : FA) â†’ inv/ (Î·/âˆ¾ s) â‰¡ Î·/âˆ¾ (finv s)
   inv/-natural = naturality/ -âˆ¾- finv finv-cong

   Â·-natural : (s t : FA) â†’ Î·/âˆ¾ s Â· Î·/âˆ¾ t â‰¡ Î·/âˆ¾ (s ++ t)
   Â·-natural = naturalityâ‚‚/ -âˆ¾- _++_ ++-cong

\end{code}

Next, to prove the groups laws, we use quotient induction "/-induction".

One can think of elements of FA/âˆ¾ as equivalence classes, and of Î·/âˆ¾ s
as the equivalence class of s. Then quotient induction says that in
order to prove a property of equivalence classes, it is enough to
prove it for all equivalence classes of given elements (this is proved
in the module UF-Quotient).

The following proofs rely on the above naturality conditions:

\begin{code}

   ln/ : left-neutral e/ _Â·_
   ln/ = /-induction -âˆ¾- (Î» x â†’ e/ Â· x â‰¡ x) (Î» x â†’ quotient-is-set -âˆ¾-) Î³
    where
     Î³ : (s : FA) â†’ Î·/âˆ¾ [] Â· Î·/âˆ¾ s â‰¡ Î·/âˆ¾ s
     Î³ = Â·-natural []

   rn/ : right-neutral e/ _Â·_
   rn/ = /-induction -âˆ¾- (Î» x â†’ x Â· e/ â‰¡ x) (Î» x â†’ quotient-is-set -âˆ¾-) Î³
    where
     Î³ : (s : FA) â†’ Î·/âˆ¾ s Â· Î·/âˆ¾ [] â‰¡ Î·/âˆ¾ s
     Î³ s = Î·/âˆ¾ s Â· Î·/âˆ¾ [] â‰¡âŸ¨ Â·-natural s [] âŸ©
           Î·/âˆ¾ (s ++ [])  â‰¡âŸ¨ ap Î·/âˆ¾ ([]-right-neutral s â»Â¹) âŸ©
           Î·/âˆ¾ s          âˆ

   invl/ : (x : FA/âˆ¾) â†’ inv/ x Â· x â‰¡ e/
   invl/ = /-induction -âˆ¾- (Î» x â†’ (inv/ x Â· x) â‰¡ e/) (Î» x â†’ quotient-is-set -âˆ¾-) Î³
    where
     Î³ : (s : FA) â†’ inv/ (Î·/âˆ¾ s) Â· Î·/âˆ¾ s â‰¡ e/
     Î³ s = inv/ (Î·/âˆ¾ s) Â· Î·/âˆ¾ s  â‰¡âŸ¨ ap (_Â· Î·/âˆ¾ s) (inv/-natural s) âŸ©
           Î·/âˆ¾ (finv s) Â· Î·/âˆ¾ s  â‰¡âŸ¨ Â·-natural (finv s) s âŸ©
           Î·/âˆ¾ (finv s ++ s)     â‰¡âŸ¨ Î·/âˆ¾-identifies-related-points (finv-left s) âŸ©
           Î·/âˆ¾ []                â‰¡âŸ¨ refl âŸ©
           e/                    âˆ

   invr/ : (x : FA/âˆ¾) â†’ x Â· inv/ x â‰¡ e/
   invr/ = /-induction -âˆ¾- (Î» x â†’ x Â· inv/ x â‰¡ e/) (Î» x â†’ quotient-is-set -âˆ¾-) Î³
    where
     Î³ : (s : FA) â†’ Î·/âˆ¾ s Â· inv/ (Î·/âˆ¾ s) â‰¡ e/
     Î³ s = Î·/âˆ¾ s Â· inv/ (Î·/âˆ¾ s)  â‰¡âŸ¨ ap (Î·/âˆ¾ s Â·_) (inv/-natural s) âŸ©
           Î·/âˆ¾ s Â· Î·/âˆ¾ (finv s)  â‰¡âŸ¨ Â·-natural s (finv s) âŸ©
           Î·/âˆ¾ (s ++ finv s)     â‰¡âŸ¨ Î·/âˆ¾-identifies-related-points (finv-right s) âŸ©
           Î·/âˆ¾ []                â‰¡âŸ¨ refl âŸ©
           e/                    âˆ

   assoc/ : associative _Â·_
   assoc/ = /-induction -âˆ¾- (Î» x â†’ âˆ€ y z â†’ (x Â· y) Â· z â‰¡ x Â· (y Â· z))
              (Î» x â†’ Î â‚‚-is-prop fe (Î» y z â†’ quotient-is-set -âˆ¾-))
              (Î» s â†’ /-induction -âˆ¾- (Î» y â†’ âˆ€ z â†’ (Î·/âˆ¾ s Â· y) Â· z â‰¡ Î·/âˆ¾ s Â· (y Â· z))
                       (Î» y â†’ Î -is-prop fe (Î» z â†’ quotient-is-set -âˆ¾-))
                       (Î» t â†’ /-induction -âˆ¾- (Î» z â†’ (Î·/âˆ¾ s Â· Î·/âˆ¾ t) Â· z â‰¡ Î·/âˆ¾ s Â· (Î·/âˆ¾ t Â· z))
                                (Î» z â†’ quotient-is-set -âˆ¾-)
                                (Î³ s t)))
    where
     Î³ : (s t u : FA) â†’ (Î·/âˆ¾ s Â· Î·/âˆ¾ t) Â· Î·/âˆ¾ u â‰¡ Î·/âˆ¾ s Â· (Î·/âˆ¾ t Â· Î·/âˆ¾ u)
     Î³ s t u = (Î·/âˆ¾ s Â· Î·/âˆ¾ t) Â· Î·/âˆ¾ u â‰¡âŸ¨ ap (_Â· Î·/âˆ¾ u) (Â·-natural s t) âŸ©
               Î·/âˆ¾ (s ++ t) Â· Î·/âˆ¾ u    â‰¡âŸ¨ Â·-natural (s ++ t) u âŸ©
               Î·/âˆ¾ ((s ++ t) ++ u)     â‰¡âŸ¨ ap Î·/âˆ¾ (++-assoc s t u) âŸ©
               Î·/âˆ¾ (s ++ (t ++ u))     â‰¡âŸ¨ (Â·-natural s (t ++ u))â»Â¹ âŸ©
               Î·/âˆ¾ s Â· Î·/âˆ¾ (t ++ u)    â‰¡âŸ¨ ap (Î·/âˆ¾ s Â·_) ((Â·-natural t u)â»Â¹) âŸ©
               Î·/âˆ¾ s Â· (Î·/âˆ¾ t Â· Î·/âˆ¾ u) âˆ
\end{code}

So we have constructed a group with underlying set FA/âˆ¾ and a map
Î·á´³Ê³áµ– : A â†’ FA/âˆ¾. We now put everyhing together:

\begin{code}

   ğ“• : Group (ğ“¤ âº)
   ğ“• = (FA/âˆ¾ , _Â·_ , quotient-is-set -âˆ¾- , assoc/ , e/ , ln/ , rn/ ,
        (Î» x â†’ inv/ x , invl/ x , invr/ x))
\end{code}

To prove that Î·á´³Ê³áµ– is the universal map of the set A into a group, we
assume another group G with a map f : A â†’ G:

\begin{code}

   module free-group-construction-stepâ‚ƒ
            {ğ“¥ : Universe}
            (G : ğ“¥ Ì‡ )
            (G-is-set : is-set G)
            (e : G)
            (invG : G â†’ G)
            (_*_ : G â†’ G â†’ G)
            (G-ln : left-neutral e _*_)
            (G-rn : right-neutral e _*_)
            (G-invl : (g : G) â†’ invG g * g â‰¡ e)
            (G-invr : (g : G) â†’ g * invG g â‰¡ e)
            (G-assoc : associative _*_)
            (f : A â†’ G)
         where

    ğ“– : Group ğ“¥
    ğ“– = (G , _*_ ,
         G-is-set , G-assoc , e , G-ln , G-rn ,
         (Î» x â†’ invG x , G-invl x , G-invr x))

\end{code}

Our objective is to construct f' from f making the universality
triangle commute. As a first step in the construction of f', we
construct a map h by induction of lists:

\begin{code}

    h : FA â†’ G
    h [] = e
    h ((â‚€ , a) âˆ· s) = f a * h s
    h ((â‚ , a) âˆ· s) = invG (f a) * h s

\end{code}

We need the following property of h with respect to formal inverses:

\begin{code}

    hâ» : (x : X) â†’ h ([ x ] ++ [ x â» ]) â‰¡ e

    hâ» (â‚€ , a) = f a * (invG (f a) * e) â‰¡âŸ¨ ap (f a *_) (G-rn (invG (f a))) âŸ©
                 f a * invG (f a)       â‰¡âŸ¨ G-invr (f a) âŸ©
                 e                      âˆ

    hâ» (â‚ , a) = invG (f a) * (f a * e) â‰¡âŸ¨ ap (invG (f a) *_) (G-rn (f a)) âŸ©
                 invG (f a) * f a       â‰¡âŸ¨ G-invl (f a) âŸ©
                 e                      âˆ
\end{code}

By construction, the function h is a list homomorphism. It is also a
monoid homomorphism (it would be a group homomorphism if FA were a
group, which it isn't):

\begin{code}

    h-is-hom : (s t : FA) â†’ h (s ++ t) â‰¡ h s * h t

    h-is-hom [] t =
     h  t    â‰¡âŸ¨ (G-ln (h t))â»Â¹ âŸ©
     e * h t âˆ

    h-is-hom ((â‚€ , a) âˆ· s) t =
     f a * h (s ++ t)    â‰¡âŸ¨ ap (f a *_) (h-is-hom s t) âŸ©
     f a * (h s * h t)   â‰¡âŸ¨ (G-assoc (f a) (h s) (h t))â»Â¹ âŸ©
     (f a * h s) * h t   â‰¡âŸ¨ refl âŸ©
     h (â‚€ , a âˆ· s) * h t âˆ

    h-is-hom (â‚ , a âˆ· s) t =
     invG (f a) * h (s ++ t)  â‰¡âŸ¨ ap (invG (f a) *_) (h-is-hom s t) âŸ©
     invG (f a) * (h s * h t) â‰¡âŸ¨ (G-assoc (invG (f a)) (h s) (h t))â»Â¹ âŸ©
     (invG (f a) * h s) * h t â‰¡âŸ¨ refl âŸ©
     h (â‚ , a âˆ· s) * h t      âˆ

\end{code}

We also need the following property of the map h in order to construct
our desired group homomorphism f':

\begin{code}

    h-identifies-â–·-related-points : {s t : FA} â†’ s â–· t â†’ h s â‰¡ h t
    h-identifies-â–·-related-points {s} {t} (u , v , y , p , q) =
       h s â‰¡âŸ¨ ap h p âŸ©
       h (u ++ [ y ] ++ [ y â» ] ++ v) â‰¡âŸ¨ h-is-hom u ([ y ] ++ [ y â» ] ++ v) âŸ©
       h u * h (y âˆ· y â» âˆ· v)          â‰¡âŸ¨ ap (h u *_) (h-is-hom (y âˆ· y â» âˆ· []) v) âŸ©
       h u * (h (y âˆ· y â» âˆ· []) * h v) â‰¡âŸ¨ ap (Î» - â†’ h u * (- * h v)) (hâ» y) âŸ©
       h u * (e * h v)                â‰¡âŸ¨ ap (h u *_) (G-ln (h v)) âŸ©
       h u * h v                      â‰¡âŸ¨ (h-is-hom u v)â»Â¹ âŸ©
       h (u ++ v)                     â‰¡âŸ¨ ap h (q â»Â¹) âŸ©
       h t                            âˆ

    h-identifies-â–·â‹†-related-points : {s t : FA} â†’ s â–·â‹† t â†’ h s â‰¡ h t
    h-identifies-â–·â‹†-related-points {s} {t} (n , r) = Î³ n s t r
     where
      Î³ : (n : â„•) (s t : FA) â†’ s â–·[ n ] t â†’ h s â‰¡ h t
      Î³ zero s s refl  = refl
      Î³ (succ n) s t (u , r , i) = h s â‰¡âŸ¨ h-identifies-â–·-related-points r âŸ©
                                   h u â‰¡âŸ¨ Î³ n u t i âŸ©
                                   h t âˆ

    h-identifies-âˆ¾-related-points : {s t : FA} â†’ s âˆ¾ t â†’ h s â‰¡ h t
    h-identifies-âˆ¾-related-points {s} {t} e = Î³
     where
      Î´ : (Î£ u ê‰ FA , (s â–·â‹† u) Ã— (t â–·â‹† u)) â†’ h s â‰¡ h t
      Î´ (u , Ïƒ , Ï„) = h s â‰¡âŸ¨ (h-identifies-â–·â‹†-related-points Ïƒ) âŸ©
                      h u â‰¡âŸ¨ (h-identifies-â–·â‹†-related-points Ï„)â»Â¹ âŸ©
                      h t âˆ
      Î³ : h s â‰¡ h t
      Î³ = âˆ¥âˆ¥-rec G-is-set Î´ (âˆ¥âˆ¥-functor (from-âˆ¿ Church-Rosser s t) e)

\end{code}

We can then finally construct the unique homorphism f' extending f
using the universal property of quotients, using the above map h:

\begin{code}

    f' : FA/âˆ¾ â†’ G
    f' = mediating-map/ -âˆ¾- G-is-set h h-identifies-âˆ¾-related-points

    f'-/triangle : f' âˆ˜ Î·/âˆ¾ âˆ¼ h
    f'-/triangle = universality-triangle/ -âˆ¾- G-is-set h h-identifies-âˆ¾-related-points

\end{code}

And from this we get the triangle for the universal property of the
free group:

\begin{code}

    f'-triangle : f' âˆ˜ Î·á´³Ê³áµ– âˆ¼ f
    f'-triangle a = f' (Î·/âˆ¾ (Î· a)) â‰¡âŸ¨ f'-/triangle (Î· a) âŸ©
                    h (Î· a)        â‰¡âŸ¨ refl âŸ©
                    f a * e        â‰¡âŸ¨ G-rn (f a) âŸ©
                    f a            âˆ

\end{code}

Which is a group homomorphism (rather than merely a monoid
homomorphism like h):

\begin{code}

    f'-is-hom : is-hom ğ“• ğ“– f'
    f'-is-hom {x} {y} = Î³ x y
     where
      Î´ : (s t : FA) â†’ f' (Î·/âˆ¾ s Â· Î·/âˆ¾ t) â‰¡ f' (Î·/âˆ¾ s) * f' (Î·/âˆ¾ t)
      Î´ s t = f' (Î·/âˆ¾ s Â· Î·/âˆ¾ t)      â‰¡âŸ¨ I âŸ©
              f' (Î·/âˆ¾ (s ++ t))       â‰¡âŸ¨ II âŸ©
              h (s ++ t)              â‰¡âŸ¨ III âŸ©
              h s * h t               â‰¡âŸ¨ IV âŸ©
              f' (Î·/âˆ¾ s) * f' (Î·/âˆ¾ t) âˆ
        where
         I   = ap f' (Â·-natural s t)
         II  = f'-/triangle (s ++ t)
         III = h-is-hom s t
         IV  = apâ‚‚ _*_ ((f'-/triangle s)â»Â¹) ((f'-/triangle t)â»Â¹)

      Î³ : (x y : FA / -âˆ¾-) â†’ f' (x Â· y) â‰¡ f' x * f' y
      Î³ = /-induction -âˆ¾- (Î» x â†’ âˆ€ y â†’ f' (x Â· y) â‰¡ f' x * f' y)
           (Î» x â†’ Î -is-prop fe (Î» y â†’ G-is-set))
           (Î» s â†’ /-induction -âˆ¾- (Î» y â†’ f' (Î·/âˆ¾ s Â· y) â‰¡ f' (Î·/âˆ¾ s) * f' y)
                   (Î» a â†’ G-is-set)
                   (Î´ s))
\end{code}

Notice that for the following uniqueness property of f' we don't need
to assume that fâ‚€ and fâ‚ are group homomorphisms:

\begin{code}

    f'-uniqueness-âˆ¾ : (fâ‚€ fâ‚ : FA/âˆ¾ â†’ G) â†’ fâ‚€ âˆ˜ Î·/âˆ¾ âˆ¼ h â†’ fâ‚ âˆ˜ Î·/âˆ¾ âˆ¼ h â†’ fâ‚€ âˆ¼ fâ‚
    f'-uniqueness-âˆ¾ fâ‚€ fâ‚ p q = at-most-one-mediating-map/ -âˆ¾- G-is-set fâ‚€ fâ‚
                                   (Î» s â†’ p s âˆ™ (q s)â»Â¹)

\end{code}

But for this one we do:

\begin{code}

    f'-uniqueness' : (fâ‚€ fâ‚ : FA/âˆ¾ â†’ G)
                  â†’ is-hom ğ“• ğ“– fâ‚€
                  â†’ is-hom ğ“• ğ“– fâ‚
                  â†’ fâ‚€ âˆ˜ Î·á´³Ê³áµ– âˆ¼ f
                  â†’ fâ‚ âˆ˜ Î·á´³Ê³áµ– âˆ¼ f
                  â†’ fâ‚€ âˆ¼ fâ‚
    f'-uniqueness' fâ‚€ fâ‚ iâ‚€ iâ‚ fâ‚€-triangle fâ‚-triangle = Î³
     where
      p : fâ‚€ âˆ˜ Î·á´³Ê³áµ– âˆ¼ fâ‚ âˆ˜ Î·á´³Ê³áµ–
      p x = fâ‚€-triangle x âˆ™ (fâ‚-triangle x)â»Â¹

      Î´ : (s : FA) â†’ fâ‚€ (Î·/âˆ¾ s) â‰¡ fâ‚ (Î·/âˆ¾ s)
      Î´ [] = fâ‚€ (Î·/âˆ¾ []) â‰¡âŸ¨ homs-preserve-unit ğ“• ğ“– fâ‚€ iâ‚€ âŸ©
             e           â‰¡âŸ¨ (homs-preserve-unit ğ“• ğ“– fâ‚ iâ‚)â»Â¹ âŸ©
             fâ‚ (Î·/âˆ¾ []) âˆ
      Î´ ((â‚€ , a) âˆ· s) =
             fâ‚€ (Î·/âˆ¾ (Î· a ++ s))    â‰¡âŸ¨ ap fâ‚€ ((Â·-natural (Î· a) s)â»Â¹) âŸ©
             fâ‚€ (Î·á´³Ê³áµ– a Â· Î·/âˆ¾ s)      â‰¡âŸ¨ iâ‚€  âŸ©
             fâ‚€ (Î·á´³Ê³áµ– a) * fâ‚€ (Î·/âˆ¾ s) â‰¡âŸ¨ apâ‚‚ _*_ (p a) (Î´ s) âŸ©
             fâ‚ (Î·á´³Ê³áµ– a) * fâ‚ (Î·/âˆ¾ s) â‰¡âŸ¨ iâ‚ â»Â¹ âŸ©
             fâ‚ (Î·á´³Ê³áµ– a Â· Î·/âˆ¾ s)      â‰¡âŸ¨ ap fâ‚ (Â·-natural (Î· a) s) âŸ©
             fâ‚ (Î·/âˆ¾ (Î· a ++ s))    âˆ
      Î´ ((â‚ , a) âˆ· s) =
             fâ‚€ (Î·/âˆ¾ (finv (Î· a) ++ s))         â‰¡âŸ¨ I âŸ©
             fâ‚€ (Î·/âˆ¾ (finv (Î· a)) Â· Î·/âˆ¾ s)      â‰¡âŸ¨ II âŸ©
             fâ‚€ (Î·/âˆ¾ (finv (Î· a))) * fâ‚€ (Î·/âˆ¾ s) â‰¡âŸ¨ III âŸ©
             fâ‚€ (inv/ (Î·á´³Ê³áµ– a)) * fâ‚€ (Î·/âˆ¾ s)      â‰¡âŸ¨ IV âŸ©
             invG (fâ‚€ (Î·á´³Ê³áµ– a)) * fâ‚€ (Î·/âˆ¾ s)      â‰¡âŸ¨ IH âŸ©
             invG (fâ‚ (Î·á´³Ê³áµ– a)) * fâ‚ (Î·/âˆ¾ s)      â‰¡âŸ¨ IV' âŸ©
             fâ‚ (inv/ (Î·á´³Ê³áµ– a)) * fâ‚ (Î·/âˆ¾ s)      â‰¡âŸ¨ III' âŸ©
             fâ‚ (Î·/âˆ¾ (finv (Î· a))) * fâ‚ (Î·/âˆ¾ s) â‰¡âŸ¨ II' âŸ©
             fâ‚ (Î·/âˆ¾ (finv (Î· a)) Â· Î·/âˆ¾ s)      â‰¡âŸ¨ I' âŸ©
             fâ‚ (Î·/âˆ¾ (finv (Î· a) ++ s))         âˆ
            where
             I    = ap fâ‚€ ((Â·-natural (finv (Î· a)) s)â»Â¹)
             II   = iâ‚€
             III  = ap (Î» - â†’ fâ‚€ - * fâ‚€ (Î·/âˆ¾ s)) ((inv/-natural (Î· a))â»Â¹)
             IV   = ap (_* fâ‚€ (Î·/âˆ¾ s)) (homs-preserve-invs ğ“• ğ“– fâ‚€ iâ‚€ (Î·á´³Ê³áµ– a))
             IH   = apâ‚‚ (Î» - -' â†’ invG - * -') (p a) (Î´ s)
             IV'  = ap (_* fâ‚ (Î·/âˆ¾ s)) ((homs-preserve-invs ğ“• ğ“– fâ‚ iâ‚ (Î·á´³Ê³áµ– a))â»Â¹)
             III' = ap (Î» - â†’ fâ‚ - * fâ‚ (Î·/âˆ¾ s)) (inv/-natural (Î· a))
             II'  = iâ‚ â»Â¹
             I'   = ap fâ‚ (Â·-natural (finv (Î· a)) s)

      Î³ : fâ‚€ âˆ¼ fâ‚
      Î³ = /-induction -âˆ¾- (Î» x â†’ fâ‚€ x â‰¡ fâ‚ x) (Î» x â†’ G-is-set) Î´

    f'-uniqueness : âˆƒ! f' ê‰ (âŸ¨ ğ“• âŸ© â†’ âŸ¨ ğ“– âŸ©) , is-hom ğ“• ğ“– f'
                                             Ã— f' âˆ˜ Î·á´³Ê³áµ– âˆ¼ f
    f'-uniqueness = Î³
     where
      c : Î£ f' ê‰ (âŸ¨ ğ“• âŸ© â†’ âŸ¨ ğ“– âŸ©) , is-hom ğ“• ğ“– f' Ã— f' âˆ˜ Î·á´³Ê³áµ– âˆ¼ f
      c = (f' , f'-is-hom , f'-triangle)

      i : is-central _ c
      i (fâ‚€ , fâ‚€-is-hom , fâ‚€-triangle) = to-subtype-â‰¡ a b
       where
        a : (f' : âŸ¨ ğ“• âŸ© â†’ âŸ¨ ğ“– âŸ©) â†’ is-prop (is-hom ğ“• ğ“– f' Ã— f' âˆ˜ Î·á´³Ê³áµ– âˆ¼ f)
        a f' = Ã—-is-prop (being-hom-is-prop fe ğ“• ğ“– f')
                         (Î -is-prop fe (Î» a â†’ group-is-set ğ“–))

        b : f' â‰¡ fâ‚€
        b = dfunext fe (f'-uniqueness' f' fâ‚€ f'-is-hom fâ‚€-is-hom f'-triangle fâ‚€-triangle)

      Î³ : âˆƒ! f' ê‰ (âŸ¨ ğ“• âŸ© â†’ âŸ¨ ğ“– âŸ©) , is-hom ğ“• ğ“– f' Ã— f' âˆ˜ Î·á´³Ê³áµ– âˆ¼ f
      Î³ = c , i

\end{code}

What we wanted to know is now proved.

We summarize the important parts in the following interface:

\begin{code}

module FreeGroupInterface
        (pt : propositional-truncations-exist)
        (fe : Fun-Ext)
        (pe : Prop-Ext)
        {ğ“¤ : Universe}
        (A : ğ“¤ Ì‡ )
       where

 open free-group-construction A
 open free-group-construction-stepâ‚ pt
 open free-group-construction-stepâ‚‚ fe pe

 free-group : Group (ğ“¤ âº)
 free-group = ğ“•

 Î·-free-group : A â†’ âŸ¨ free-group âŸ©
 Î·-free-group = Î·á´³Ê³áµ–

 Î·-free-group-is-embedding : is-set A â†’ is-embedding Î·-free-group
 Î·-free-group-is-embedding = Î·á´³Ê³áµ–-is-embedding

 module _ ((G , _*_ , G-is-set , G-assoc , e , l , r , inversion) : Group ğ“¥)
          (f : A â†’ G)
        where

  open free-group-construction-stepâ‚ƒ
        G G-is-set e (Î» x â†’ prâ‚ (inversion x)) _*_ l r
        (Î» x â†’ prâ‚ (prâ‚‚ (inversion x))) (Î» x â†’ prâ‚‚ (prâ‚‚ (inversion x))) G-assoc f

  free-group-extension : âŸ¨ free-group âŸ© â†’ âŸ¨ ğ“– âŸ©
  free-group-extension = f'

  free-group-is-hom : is-hom free-group ğ“– free-group-extension
  free-group-is-hom = f'-is-hom

  free-group-triangle : free-group-extension âˆ˜ Î·-free-group âˆ¼ f
  free-group-triangle = f'-triangle

  extension-to-free-group-uniqueness :

    âˆƒ! f' ê‰ (âŸ¨ free-group âŸ© â†’ âŸ¨ ğ“– âŸ©) , is-hom free-group ğ“– f'
                                     Ã— f' âˆ˜ Î·-free-group âˆ¼ f

  extension-to-free-group-uniqueness = f'-uniqueness

\end{code}

We now package the above into a single theorem.

Notice that we don't need to assume that the type A of
generators is a set to construct the free group and establish its
universal property.

But if A is a set then the universal map Î· is left-cancellable and
hence an embedding.

\begin{code}

free-groups-exist : propositional-truncations-exist
                  â†’ Fun-Ext
                  â†’ Prop-Ext
                  â†’ (A : ğ“¤ Ì‡ )
                  â†’ Î£ ğ“• ê‰ Group (ğ“¤ âº)
                  , Î£ Î· ê‰ (A â†’ âŸ¨ ğ“• âŸ©)
                  , ((ğ“– : Group ğ“¥) (f : A â†’ âŸ¨ ğ“– âŸ©)
                        â†’ âˆƒ! f' ê‰ (âŸ¨ ğ“• âŸ© â†’ âŸ¨ ğ“– âŸ©) , is-hom ğ“• ğ“– f' Ã— f' âˆ˜ Î· âˆ¼ f)
                  Ã— (is-set A â†’ is-embedding Î·)

free-groups-exist pt fe pe A = free-group A  ,
                               Î·-free-group A ,
                               extension-to-free-group-uniqueness A ,
                               Î·-free-group-is-embedding A
 where
  open FreeGroupInterface pt fe pe

\end{code}

Notice that the free group construction increases the universe level,
but the universal property eliminates into any universe. This is
because our construction of quotients via propositional truncation
increses universe levels. In the module FreeGroupOfLargeLocallySmallSet

we show that for a large, locally small type type A : ğ“¤âº, the free
group has a copy in the same universe ğ“¤+ as A, and moreover, if the
free group has a copy in ğ“¤ then so must have the type A.
