Martin Escardo, 04 January 2021.

Ongoing joint work with Marc Bezem, Thierry Coquand, and Peter Dybjer.

We construct free groups in HoTT/UF in Agda without HIT's other than
propositional truncation.

Based on Richman's book on constructive algebra.

For the moment this file is not for public consumption, but it is
publicly visible.

This is part of the Martin Escardo's Agda development TypeTopology,
whose philosophy is to be Spartan. At the moment we are a bit
Athenian, though, although we intend to fix this in the
future.

\begin{code}

{-# OPTIONS --without-K --safe #-} -- --exact-split

\end{code}

NB. This repository is supposed to use exact-split, but even though
everything has been developed using case-split, the exact-split check
fails (in Agda 2.6.1) in the helper function f of the function
churros. This seems to be a bug.

\begin{code}

module FreeGroup where

open import SpartanMLTT
open import Two
open import Two-Properties

open import UF-PropTrunc
open import UF-Univalence
open import UF-Base
open import UF-Subsingletons
open import UF-Equiv
open import UF-UA-FunExt
open import UF-FunExt

\end{code}

It is possible to work with lists *defined* from the ingredients of
our Spartan MLTT (see the module Fin.lagda). For the moment we are
Athenian in this respect:

\begin{code}

data List {ğ“¤} (X : ğ“¤ Ì‡ ) : ğ“¤ Ì‡  where
 [] : List X
 _âˆ·_ : X â†’ List X â†’ List X

infixr 3 _âˆ·_

equal-heads : {X : ğ“¤ Ì‡ } {x y : X} {s t : List X}
            â†’ x âˆ· s â‰¡ y âˆ· t
            â†’ x â‰¡ y
equal-heads refl = refl

equal-tails : {X : ğ“¤ Ì‡ } {x y : X} {s t : List X}
            â†’ x âˆ· s â‰¡ y âˆ· t
            â†’ s â‰¡ t
equal-tails {ğ“¤} {X} refl = refl

[_] : {X : ğ“¤ Ì‡ } â†’ X â†’ List X
[ x ] = x âˆ· []

_++_ : {X : ğ“¤ Ì‡ } â†’ List X â†’ List X â†’ List X
[]      ++ t = t
(x âˆ· s) ++ t = x âˆ· (s ++ t)

infixr 4 _++_

[]-right-neutral : {X : ğ“¤ Ì‡ } (s : List X) â†’ s â‰¡ s ++ []
[]-right-neutral []      = refl
[]-right-neutral (x âˆ· s) = ap (x âˆ·_) ([]-right-neutral s)

++-assoc : {X : ğ“¤ Ì‡ } â†’ associative (_++_ {ğ“¤} {X})
++-assoc []      t u = refl
++-assoc (x âˆ· s) t u = ap (x âˆ·_) (++-assoc s t u)

\end{code}

We now construct the group freely generated by a set A. The set-hood
requirement is needed later only, and so we don't include it as an
assumption in the following anonymous module:

\begin{code}

module _ {ğ“¤ : Universe}
         {A : ğ“¤ Ì‡ }
       where

 X : ğ“¤ Ì‡
 X = ğŸš Ã— A

 _â» : X â†’ X
 (n , a)â» = (complement n , a)

 inv-invol : (x : X) â†’ (x â»)â» â‰¡ x
 inv-invol (n , a) = ap (_, a) (complement-involutive n)

\end{code}

We will quotient the following type FA to get the undelying type of
the free group:

\begin{code}

 FA : ğ“¤ Ì‡
 FA = List X

 Î· : A â†’ FA
 Î· a = [ â‚€ , a ]

\end{code}

We will quotient by the equivalence relation generated by the
following reduction relation:

\begin{code}

 _â–·_ : FA â†’ FA â†’ ğ“¤ Ì‡
 s â–· t = Î£ u ê‰ FA , Î£ v ê‰ FA , Î£ x ê‰ X , (s â‰¡ u ++ [ x ] ++ [ x â» ] ++ v)
                                       Ã— (t â‰¡ u ++ v)

 infix 1 _â–·_

 âˆ·-â–· : {s t : FA} (x : X) â†’ s â–· t â†’ x âˆ· s â–· x âˆ· t
 âˆ·-â–· x (u , v , y , p , q) = (x âˆ· u) , v , y , ap (x âˆ·_) p , ap (x âˆ·_) q

\end{code}

The following is a lemma for the Church-Rosser property, proved by
induction on uâ‚€ and uâ‚:

\begin{code}

 churros : (uâ‚€ vâ‚€ uâ‚ vâ‚ : FA) (xâ‚€ xâ‚ : X)

         â†’ uâ‚€ ++  [ xâ‚€ ] ++ [ xâ‚€ â» ] ++ vâ‚€
         â‰¡ uâ‚ ++  [ xâ‚ ] ++ [ xâ‚ â» ] ++ vâ‚

         â†’ (uâ‚€ ++ vâ‚€ â‰¡ uâ‚ ++ vâ‚)
         + (Î£ t ê‰ FA , (uâ‚€ ++ vâ‚€ â–· t) Ã— (uâ‚ ++ vâ‚ â–· t))

 churros uâ‚€ vâ‚€ uâ‚ vâ‚ xâ‚€ xâ‚ = f uâ‚€ uâ‚
  where
   f : (uâ‚€ uâ‚ : FA)
     â†’ uâ‚€ ++  [ xâ‚€ ] ++ [ xâ‚€ â» ] ++ vâ‚€ â‰¡ uâ‚ ++  [ xâ‚ ] ++ [ xâ‚ â» ] ++ vâ‚
     â†’ (uâ‚€ ++ vâ‚€ â‰¡ uâ‚ ++ vâ‚) + (Î£ t ê‰ FA , (uâ‚€ ++ vâ‚€ â–· t) Ã— (uâ‚ ++ vâ‚ â–· t))

   f [] [] p = inl Î³
    where
     have : xâ‚€ âˆ· xâ‚€ â»  âˆ· vâ‚€
          â‰¡ xâ‚ âˆ· xâ‚ â»  âˆ· vâ‚
     have = p

     Î³ : vâ‚€ â‰¡ vâ‚
     Î³ = equal-tails (equal-tails p)

   f [] (yâ‚ âˆ· []) p = inl Î³
    where
     have : xâ‚€ âˆ· xâ‚€ â» âˆ· vâ‚€
          â‰¡ yâ‚ âˆ· xâ‚   âˆ· xâ‚ â» âˆ· vâ‚
     have = p

     q = xâ‚ â»    â‰¡âŸ¨ ap _â» ((equal-heads (equal-tails p))â»Â¹) âŸ©
         (xâ‚€ â»)â» â‰¡âŸ¨ inv-invol xâ‚€ âŸ©
         xâ‚€      â‰¡âŸ¨ equal-heads p âŸ©
         yâ‚      âˆ

     Î³ : vâ‚€ â‰¡ yâ‚ âˆ· vâ‚
     Î³ = transport (Î» - â†’ vâ‚€ â‰¡ - âˆ· vâ‚) q (equal-tails (equal-tails p))

   f [] (yâ‚ âˆ· zâ‚ âˆ· uâ‚) p = inr Î³
    where
     have : xâ‚€ âˆ· xâ‚€ â» âˆ· vâ‚€
          â‰¡ yâ‚ âˆ· zâ‚   âˆ· uâ‚ ++ [ xâ‚ ] ++ [ xâ‚ â» ] ++ vâ‚
     have = p

     d' : uâ‚ ++ [ xâ‚ ] ++ [ xâ‚ â» ] ++ vâ‚ â–· uâ‚ ++ vâ‚
     d' = uâ‚ , vâ‚ , xâ‚ , refl , refl

     d : vâ‚€ â–· uâ‚ ++ vâ‚
     d = transport (_â–· uâ‚ ++ vâ‚) ((equal-tails (equal-tails p))â»Â¹) d'

     q = yâ‚ â» â‰¡âŸ¨ (ap (_â») (equal-heads p)â»Â¹) âŸ©
         xâ‚€ â» â‰¡âŸ¨ equal-heads (equal-tails p) âŸ©
         zâ‚   âˆ

     e' : yâ‚ âˆ· yâ‚ â» âˆ· uâ‚ ++ vâ‚ â–· uâ‚ ++ vâ‚
     e' = [] , (uâ‚ ++ vâ‚) , yâ‚ , refl , refl

     e : yâ‚ âˆ· zâ‚ âˆ· uâ‚ ++ vâ‚ â–· uâ‚ ++ vâ‚
     e = transport (Î» - â†’ yâ‚ âˆ· - âˆ· uâ‚ ++ vâ‚ â–· uâ‚ ++ vâ‚) q e'

     Î³ : Î£ t ê‰ FA , (vâ‚€ â–· t) Ã— (yâ‚ âˆ· zâ‚ âˆ· uâ‚ ++ vâ‚ â–· t)
     Î³ = (uâ‚ ++ vâ‚) , d , e

   f (yâ‚€ âˆ· []) [] p = inl Î³
    where
     have : yâ‚€ âˆ· xâ‚€   âˆ· xâ‚€ â» âˆ· vâ‚€
          â‰¡ xâ‚ âˆ· xâ‚ â» âˆ· vâ‚
     have = p

     Î³ = yâ‚€ âˆ· vâ‚€      â‰¡âŸ¨ ap (_âˆ· vâ‚€) (equal-heads p) âŸ©
         xâ‚ âˆ· vâ‚€      â‰¡âŸ¨ ap (_âˆ· vâ‚€) ((inv-invol xâ‚)â»Â¹) âŸ©
         (xâ‚ â»)â» âˆ· vâ‚€ â‰¡âŸ¨ ap (Î» - â†’ - â» âˆ· vâ‚€) ((equal-heads (equal-tails p))â»Â¹) âŸ©
         xâ‚€ â» âˆ· vâ‚€    â‰¡âŸ¨ equal-tails (equal-tails p) âŸ©
         vâ‚           âˆ

   f (yâ‚€ âˆ· zâ‚€ âˆ· uâ‚€) [] p = inr Î³
    where
     have : yâ‚€ âˆ· zâ‚€   âˆ· uâ‚€ ++ [ xâ‚€ ] ++ [ xâ‚€ â» ] ++ vâ‚€
          â‰¡ xâ‚ âˆ· xâ‚ â» âˆ· vâ‚
     have = p

     q = yâ‚€ â» â‰¡âŸ¨ ap (_â») (equal-heads p) âŸ©
         xâ‚ â» â‰¡âŸ¨ (equal-heads (equal-tails p))â»Â¹ âŸ©
         zâ‚€   âˆ

     d' : yâ‚€ âˆ· yâ‚€ â» âˆ· uâ‚€ ++ vâ‚€ â–· uâ‚€ ++ vâ‚€
     d' = [] , (uâ‚€ ++ vâ‚€) , yâ‚€ , refl , refl

     d : yâ‚€ âˆ· zâ‚€ âˆ· uâ‚€ ++ vâ‚€ â–· uâ‚€ ++ vâ‚€
     d = transport (Î» - â†’ yâ‚€ âˆ· - âˆ· uâ‚€ ++ vâ‚€ â–· uâ‚€ ++ vâ‚€) q d'

     e' : uâ‚€ ++ [ xâ‚€ ] ++ [ xâ‚€ â» ] ++ vâ‚€ â–· uâ‚€ ++ vâ‚€
     e' = uâ‚€ , vâ‚€ , xâ‚€ , refl , refl

     e : vâ‚ â–· uâ‚€ ++ vâ‚€
     e = transport (_â–· uâ‚€ ++ vâ‚€) (equal-tails (equal-tails p)) e'

     Î³ : Î£ t ê‰ FA , (yâ‚€ âˆ· zâ‚€ âˆ· uâ‚€ ++ vâ‚€ â–· t) Ã— (vâ‚ â–· t)
     Î³ = (uâ‚€ ++ vâ‚€) , d , e

   f (yâ‚€ âˆ· uâ‚€) (yâ‚ âˆ· uâ‚) p = Î³
    where
     have : yâ‚€ âˆ· uâ‚€ ++ [ xâ‚€ ] ++ [ xâ‚€ â» ] ++ vâ‚€
          â‰¡ yâ‚ âˆ· uâ‚ ++ [ xâ‚ ] ++ [ xâ‚ â» ] ++ vâ‚
     have = p

     IH : (uâ‚€ ++ vâ‚€ â‰¡ uâ‚ ++ vâ‚) + (Î£ t ê‰ FA , (uâ‚€ ++ vâ‚€ â–· t) Ã— (uâ‚ ++ vâ‚ â–· t))
     IH = f uâ‚€ uâ‚ (equal-tails p)

     Î“ : X â†’ X â†’ ğ“¤ Ì‡
     Î“ yâ‚€ yâ‚ = (yâ‚€ âˆ· uâ‚€ ++ vâ‚€ â‰¡ yâ‚ âˆ· uâ‚ ++ vâ‚)
             + (Î£ t ê‰ FA , (yâ‚€ âˆ· uâ‚€ ++ vâ‚€ â–· t) Ã— (yâ‚ âˆ· uâ‚ ++ vâ‚ â–· t))

     Î´ : type-of IH â†’ âˆ€ {yâ‚€ yâ‚} â†’ yâ‚€ â‰¡ yâ‚ â†’ Î“ yâ‚€ yâ‚
     Î´ (inl q)           {yâ‚€} refl = inl (ap (yâ‚€ âˆ·_) q)
     Î´ (inr (t , d , e)) {yâ‚€} refl = inr ((yâ‚€ âˆ· t) , âˆ·-â–· yâ‚€ d , âˆ·-â–· yâ‚€ e)

     Î³ : Î“ yâ‚€ yâ‚
     Î³ = Î´ IH (equal-heads p)

 Church-Rosser : (s tâ‚€ tâ‚ : FA)
               â†’ s â–· tâ‚€
               â†’ s â–· tâ‚
               â†’ (tâ‚€ â‰¡ tâ‚) + (Î£ t ê‰ FA , (tâ‚€ â–· t) Ã— (tâ‚ â–· t))
 Church-Rosser s tâ‚€ tâ‚ (uâ‚€ , vâ‚€ , xâ‚€ , pâ‚€ , qâ‚€) (uâ‚ , vâ‚ , xâ‚ , pâ‚ , qâ‚) = Î³ Î´
  where
   Î´ : (uâ‚€ ++ vâ‚€ â‰¡ uâ‚ ++ vâ‚) + (Î£ t ê‰ FA , (uâ‚€ ++ vâ‚€ â–· t) Ã— (uâ‚ ++ vâ‚ â–· t))
   Î´ = churros uâ‚€ vâ‚€ uâ‚ vâ‚ xâ‚€ xâ‚ (pâ‚€ â»Â¹ âˆ™ pâ‚)

   Î³ : type-of Î´ â†’ (tâ‚€ â‰¡ tâ‚) + (Î£ t ê‰ FA , (tâ‚€ â–· t) Ã— (tâ‚ â–· t))
   Î³ (inl q)           = inl (qâ‚€ âˆ™ q âˆ™ qâ‚ â»Â¹)
   Î³ (inr (t , p , q)) = inr (t , transport (_â–· t) (qâ‚€ â»Â¹) p ,
                                  transport (_â–· t) (qâ‚ â»Â¹) q)

\end{code}

The following import defines

  _â—â–·_       the symmetric closure of _â–·_,
  _âˆ¿_        the symmetric, reflexive, transitive closure of _â–·_,
  _â–·*_       the reflexive, transitive closure of _â–·_,
  _â–·[ n ]_   the n-fold iteration of _â–·_.
  _â—â–·[ n ]_  the n-fold iteration of _â—â–·_.

\begin{code}

 open import SRTclosure
 open Church-Rosser _â–·_

\end{code}

The insertion of generators is left cancellable before quotienting:

\begin{code}

 Î·-lc : {a b : A} â†’ Î· a â‰¡ Î· b â†’ a â‰¡ b
 Î·-lc refl = refl

\end{code}

The following will give that the insertion of generators is injective
after quotienting:

\begin{code}

 Î·-irreducible : {a : A} {s : FA} â†’ Â¬ (Î· a â–· s)
 Î·-irreducible ((x âˆ· []) , v , y , () , refl)
 Î·-irreducible ((x âˆ· y âˆ· u) , v , z , () , q)

 Î·-irreducible* : {a : A} {s : FA} â†’ Î· a â–·* s â†’ Î· a â‰¡ s
 Î·-irreducible* {a} {s} (n , r) = f n r
  where
   f : (n : â„•) â†’ Î· a â–·[ n ] s â†’ Î· a â‰¡ s
   f zero     refl = refl
   f (succ n) (t , r , i) = ğŸ˜-elim (Î·-irreducible r)

 Î·-âˆ¿ : {a b : A} â†’ Î· a âˆ¿ Î· b â†’ a â‰¡ b
 Î·-âˆ¿ {a} {b} e = Î·-lc p
  where
   Ïƒ : Î£ s ê‰ FA , (Î· a â–·* s) Ã— (Î· b â–·* s)
   Ïƒ = from-âˆ¿ Church-Rosser (Î· a) (Î· b) e
   s = prâ‚ Ïƒ

   p = Î· a â‰¡âŸ¨  Î·-irreducible* (prâ‚ (prâ‚‚ Ïƒ)) âŸ©
       s   â‰¡âŸ¨ (Î·-irreducible* (prâ‚‚ (prâ‚‚ Ïƒ)))â»Â¹ âŸ©
       Î· b âˆ

\end{code}

We need to work with the truncation of _âˆ¿_ to construct the free
group, but most of the work will be done before truncation.

The following is for reasoning with chains of equivalences _âˆ¿_:

\begin{code}

 _âˆ¿âŸ¨_âŸ©_ : (s : FA) {t u : FA} â†’ s âˆ¿ t â†’ t âˆ¿ u â†’ s âˆ¿ u
 _ âˆ¿âŸ¨ p âŸ© q = srt-transitive _â–·_ _ _ _ p q

 _âˆ¿âˆ : (s : FA) â†’ s âˆ¿ s
 _âˆ¿âˆ _ = srt-reflexive _â–·_ _

 infixr 0 _âˆ¿âŸ¨_âŸ©_
 infix  1 _âˆ¿âˆ

\end{code}

The group operation before quotienting is simply concatenation.

Concatenation is a left congruence:

\begin{code}

 ++-â–·-left : (s s' t : FA) â†’ s â–· s' â†’ s ++ t â–· s' ++ t
 ++-â–·-left s s' t (u , v , x , p , q) = u , (v ++ t) , x , p' , q'
  where
   p' = s ++ t                            â‰¡âŸ¨ ap (_++ t) p âŸ©
        (u ++ [ x ] ++ [ x â» ] ++ v) ++ t â‰¡âŸ¨ ++-assoc u ([ x ] ++ [ x â» ] ++ v) t âŸ©
        u ++ [ x ] ++ [ x â» ] ++ v ++ t   âˆ

   q' = s' ++ t       â‰¡âŸ¨ ap (_++ t) q âŸ©
        (u ++ v) ++ t â‰¡âŸ¨ ++-assoc u v t âŸ©
        u ++ v ++ t   âˆ

 ++-â—â–·-left : (s s' t : FA) â†’ s â—â–· s' â†’ s ++ t â—â–· s' ++ t
 ++-â—â–·-left s s' t (inl a) = inl (++-â–·-left s s' t a)
 ++-â—â–·-left s s' t (inr a) = inr (++-â–·-left s' s t a)

 ++-iteration-left : (s s' t : FA) (n : â„•)
                   â†’ s â—â–·[ n ] s'
                   â†’ s ++ t â—â–·[ n ] s' ++ t
 ++-iteration-left s s  t zero     refl        = refl
 ++-iteration-left s s' t (succ n) (u , b , c) = (u ++ t) ,
                                                 ++-â—â–·-left s u t b ,
                                                 ++-iteration-left u s' t n c

 ++-cong-left : (s s' t : FA) â†’ s âˆ¿ s' â†’ s ++ t âˆ¿ s' ++ t
 ++-cong-left s s' t (n , a) = n , ++-iteration-left s s' t n a

\end{code}

It is also a right congruence:

\begin{code}

 âˆ·-â—â–· : (x : X) {s t : FA} â†’ s â—â–· t â†’ x âˆ· s â—â–· x âˆ· t
 âˆ·-â—â–· x (inl e) = inl (âˆ·-â–· x e)
 âˆ·-â—â–· x (inr e) = inr (âˆ·-â–· x e)

 âˆ·-iteration : (x : X) {s t : FA} (n : â„•)
             â†’ s â—â–·[ n ] t
             â†’ x âˆ· s â—â–·[ n ] x âˆ· t
 âˆ·-iteration x zero refl = refl
 âˆ·-iteration x (succ n) (u , b , c) = (x âˆ· u) , âˆ·-â—â–· x b , âˆ·-iteration x n c

 âˆ·-cong : (x : X) {s t : FA} â†’ s âˆ¿ t â†’ x âˆ· s âˆ¿ x âˆ· t
 âˆ·-cong x (n , a) = n , âˆ·-iteration x n a

 ++-cong-right : (s {t t'} : FA) â†’ t âˆ¿ t' â†’ s ++ t âˆ¿ s ++ t'
 ++-cong-right []      e = e
 ++-cong-right (x âˆ· s) e = âˆ·-cong x (++-cong-right s e)

\end{code}

And therefore it is a two-sided congruence:

\begin{code}

 ++-cong-âˆ¿ : {s s' t t' : FA} â†’ s âˆ¿ s' â†’ t âˆ¿ t' â†’ s ++ t âˆ¿ s' ++ t'
 ++-cong-âˆ¿ {s} {s'} {t} {t'} d e = s ++ t   âˆ¿âŸ¨ ++-cong-left s s' t d âŸ©
                                   s' ++ t  âˆ¿âŸ¨ ++-cong-right s' e âŸ©
                                   s' ++ t' âˆ¿âˆ
\end{code}

The group inverse, before quotienting:

\begin{code}

 inv : FA â†’ FA
 inv [] = []
 inv (x âˆ· s) = inv s ++ [ x â» ]

\end{code}

It is a congruence:

\begin{code}

 inv-++ : (s t : FA) â†’ inv (s ++ t) â‰¡ inv t ++ inv s
 inv-++ []      t = []-right-neutral (inv t)
 inv-++ (x âˆ· s) t = inv (s ++ t) ++ [ x â» ]     â‰¡âŸ¨ IH âŸ©
                    (inv t ++ inv s) ++ [ x â» ] â‰¡âŸ¨ assoc âŸ©
                    inv t ++ (inv s ++ [ x â» ]) âˆ
  where
   IH    = ap (_++ [ x â» ]) (inv-++ s t)
   assoc = ++-assoc (inv t) (inv s) [ x â» ]

 inv-â–· : {s t : FA} â†’ s â–· t â†’ inv s â–· inv t
 inv-â–· {s} {t} (u , v , y , p , q) = inv v , inv u , y , p' , q'
  where
   p' = inv s                                     â‰¡âŸ¨ I âŸ©
        inv (u ++ [ y ] ++ [ y â» ] ++ v)          â‰¡âŸ¨ II âŸ©
        inv ([ y ] ++ [ y â» ] ++ v) ++ inv u      â‰¡âŸ¨ III âŸ©
        inv (([ y ] ++ [ y â» ]) ++ v) ++ inv u    â‰¡âŸ¨ IV âŸ©
        (inv v ++ [ (y â»)â» ] ++ [ y â» ]) ++ inv u â‰¡âŸ¨ V âŸ©
        (inv v ++ [ y ] ++ [ y â» ]) ++ inv u      â‰¡âŸ¨ VI âŸ©
        inv v ++ [ y ] ++ [ y â» ] ++ inv u        âˆ
    where
     I   = ap inv p
     II  = inv-++ u ([ y ] ++ [ y â» ] ++ v)
     III = ap (Î» - â†’ inv - ++ inv u) ((++-assoc [ y ] [ y â» ] v)â»Â¹)
     IV  = ap (_++ inv u) (inv-++ ([ y ] ++ [ y â» ]) v)
     V   = ap (Î» - â†’ (inv v ++ [ - ] ++ [ y â» ]) ++ inv u) (inv-invol y)
     VI  = ++-assoc (inv v) ([ y ] ++ [ y â» ]) (inv u)

   q' = inv t          â‰¡âŸ¨ ap inv q âŸ©
        inv (u ++ v)   â‰¡âŸ¨ inv-++ u v âŸ©
        inv v ++ inv u âˆ

 inv-â—â–· : {s t : FA} â†’ s â—â–· t â†’ inv s â—â–· inv t
 inv-â—â–· (inl e) = inl (inv-â–· e)
 inv-â—â–· (inr e) = inr (inv-â–· e)

 inv-iteration : {s t : FA} (n : â„•)
               â†’ s â—â–·[ n ] t
               â†’ inv s â—â–·[ n ] inv t
 inv-iteration zero refl = refl
 inv-iteration (succ n) (u , b , c) = inv u , inv-â—â–· b , inv-iteration n c

 inv-cong-âˆ¿ : {s t : FA} â†’ s âˆ¿ t â†’ inv s âˆ¿ inv t
 inv-cong-âˆ¿ (n , a) = n , inv-iteration n a

\end{code}

The inverse really is an inverse:

\begin{code}

 =-âˆ¿ : {s s' : FA} â†’ s â‰¡ s' â†’ s âˆ¿ s'
 =-âˆ¿ {s} refl = srt-reflexive _â–·_ s

 inv-lemma : (x : X) â†’ [ x ] ++ [ x â» ] âˆ¿ []
 inv-lemma x = srt-extension _â–·_ _ [] ([] , [] , x , refl , refl)

 inv-lemma' : (x : X) â†’ [ x â» ] ++ [ x ] âˆ¿ []
 inv-lemma' x = srt-extension _â–·_ _ _
                 ([] ,
                  [] ,
                  (x â») ,
                  ap (Î» - â†’ [ x â» ] ++ [ - ]) ((inv-invol x)â»Â¹) , refl)

 inv-property-âˆ¿ : (s : FA) â†’ s ++ inv s âˆ¿ []
 inv-property-âˆ¿ []      = srt-reflexive _â–·_ []
 inv-property-âˆ¿ (x âˆ· s) = Î³
  where
   IH : s ++ inv s âˆ¿ []
   IH = inv-property-âˆ¿ s

   Î³ = [ x ] ++ s ++ inv s ++ [ x â» ]   âˆ¿âŸ¨ I âŸ©
       [ x ] ++ (s ++ inv s) ++ [ x â» ] âˆ¿âŸ¨ II âŸ©
       [ x ] ++ [ x â» ]                 âˆ¿âŸ¨ III âŸ©
       []                               âˆ¿âˆ
    where
     I   = =-âˆ¿  (ap (x âˆ·_) (++-assoc s (inv s) [ x â» ])â»Â¹)
     II  = ++-cong-right [ x ] (++-cong-left _ _ _ IH)
     III = inv-lemma x

 inv-property'-âˆ¿ : (s : FA) â†’ inv s ++ s âˆ¿ []
 inv-property'-âˆ¿ []      = srt-reflexive _â–·_ []
 inv-property'-âˆ¿ (x âˆ· s) = Î³
  where
   Î³ = (inv s ++ [ x â» ]) ++ (x âˆ· s)    âˆ¿âŸ¨ I âŸ©
       inv s ++ ([ x â» ] ++ [ x ] ++ s) âˆ¿âŸ¨ II âŸ©
       inv s ++ ([ x â» ] ++ [ x ]) ++ s âˆ¿âŸ¨ III âŸ©
       inv s ++ s                       âˆ¿âŸ¨ IV âŸ©
       []                               âˆ¿âˆ
    where
     I   = =-âˆ¿ (++-assoc (inv s) [ x â» ] (x âˆ· s))
     II  = =-âˆ¿ (ap (inv s ++_) ((++-assoc [ x â» ] [ x ] s)â»Â¹))
     III = ++-cong-right (inv s) (++-cong-left _ _ _ (inv-lemma' x))
     IV  = inv-property'-âˆ¿ s

\end{code}

The propositional, symmetric, reflexive, transitive closure of _â–·_:

\begin{code}

 module _ (pt : propositional-truncations-exist) where

  open PropositionalTruncation pt

  _âˆ¾_ : FA â†’ FA â†’ ğ“¤ Ì‡
  x âˆ¾ y = âˆ¥ x âˆ¿ y âˆ¥

  infix 1 _âˆ¾_

  Î·-âˆ¾ : {a b : A} â†’ is-set A â†’ Î· a âˆ¾ Î· b â†’ a â‰¡ b
  Î·-âˆ¾ i = âˆ¥âˆ¥-rec i Î·-âˆ¿

  ++-cong : {s s' t t' : FA} â†’ s âˆ¾ s' â†’ t âˆ¾ t' â†’ s ++ t âˆ¾ s' ++ t'
  ++-cong = âˆ¥âˆ¥-functorâ‚‚ ++-cong-âˆ¿

  inv-cong : {s t : FA} â†’ s âˆ¾ t â†’ inv s âˆ¾ inv t
  inv-cong = âˆ¥âˆ¥-functor inv-cong-âˆ¿

  inv-property : (s : FA) â†’ s ++ inv s âˆ¾ []
  inv-property s = âˆ£ inv-property-âˆ¿ s âˆ£

  inv-property' : (s : FA) â†’ inv s ++ s âˆ¾ []
  inv-property' s = âˆ£ inv-property'-âˆ¿ s âˆ£

\end{code}

To perform the quotient, we assume functional and propositional
extensionality.

\begin{code}

  module _ (fe  : FunExt)
           (pe  : propext ğ“¤)
        where


   open import UF-Quotient
   open Quotient ğ“¤ ğ“¤ pt fe pe
   open psrt pt _â–·_


   âˆ¾ : EqRel FA
   âˆ¾ = _âˆ¾_ , psrt-is-prop-valued , psrt-reflexive , psrt-symmetric , psrt-transitive

\end{code}

Our quotients constructed via propositional truncation increase
universe levels:

\begin{code}

   FA/âˆ¾ : ğ“¤ âº Ì‡
   FA/âˆ¾ = FA / âˆ¾

\end{code}

This won't be a problem for our intended application, the free group
over the type of ordinals, because although this type is large, it is
locally small.

To be continued.
