Martin Escardo, 04 January 2021.

Ongoing joint work with Marc Bezem, Thierry Coquand, and Peter Dybjer.

We construct free groups in HoTT/UF in Agda without HIT's other than
propositional truncation.

Based on Richman's book on constructive algebra.

For the moment this file is not for public consumption, but it is
publicly visible.

This is part of the Martin Escardo's Agda development TypeTopology,
whose philosophy is to be Spartan. At the moment we are a bit
Athenian, though, although we intend to fix this in the
future.

\begin{code}

{-# OPTIONS --without-K --safe #-} -- --exact-split

\end{code}

NB. This repository is supposed to use exact-split, but even though
everything has been developed using case-split, the exact-split check
fails (in Agda 2.6.1) in the helper function f of the function
churros. This seems to be a bug.

\begin{code}

open import UF-PropTrunc
open import UF-Univalence

module FreeGroup
       (pt : propositional-truncations-exist)
       (ua : Univalence)
       where

open import SpartanMLTT
open import Two
open import Two-Properties

open import UF-Base
open import UF-Subsingletons
open import UF-Equiv
open import UF-UA-FunExt
open import UF-FunExt

\end{code}

It is possible to work with lists *defined* from the ingredients of
our Spartan MLTT (see the module Fin.lagda). For the moment we are
Athenian in this respect:

\begin{code}

data List {ùì§} (X : ùì§ Ãá ) : ùì§ Ãá  where
 [] : List X
 _‚à∑_ : X ‚Üí List X ‚Üí List X

infixr 2 _‚à∑_

equal-heads : {X : ùì§ Ãá } {x y : X} {s t : List X}
            ‚Üí x ‚à∑ s ‚â° y ‚à∑ t
            ‚Üí x ‚â° y
equal-heads {ùì§} {X} {x} = ap f
 where
  f : List X ‚Üí X
  f []      = x
  f (z ‚à∑ _) = z

equal-tails : {X : ùì§ Ãá } {x y : X} {s t : List X}
            ‚Üí x ‚à∑ s ‚â° y ‚à∑ t
            ‚Üí s ‚â° t
equal-tails {ùì§} {X} = ap f
 where
  f : List X ‚Üí List X
  f []      = []
  f (_ ‚à∑ u) = u

[_] : {X : ùì§ Ãá } ‚Üí X ‚Üí List X
[ x ] = x ‚à∑ []

_++_ : {X : ùì§ Ãá } ‚Üí List X ‚Üí List X ‚Üí List X
[]      ++ t = t
(x ‚à∑ s) ++ t = x ‚à∑ (s ++ t)

infixr 4 _++_

[]-right-neutral : {X : ùì§ Ãá } (s : List X) ‚Üí s ‚â° s ++ []
[]-right-neutral []      = refl
[]-right-neutral (x ‚à∑ s) = ap (x ‚à∑_) ([]-right-neutral s)

++-assoc : {X : ùì§ Ãá } ‚Üí associative (_++_ {ùì§} {X})
++-assoc []      t u = refl
++-assoc (x ‚à∑ s) t u = ap (x ‚à∑_) (++-assoc s t u)

\end{code}

We now construct the group freely generated by a set A. The set-hood
requirement is needed later only, and so we don't include it as an
assumption in the following anonymous module:

\begin{code}

module _ {ùì§ : Universe}
         {A : ùì§ Ãá }
       where

 X : ùì§ Ãá
 X = ùüö √ó A

 _‚Åª : X ‚Üí X
 (n , a)‚Åª = (complement n , a)

 inv-invol : (x : X) ‚Üí (x ‚Åª)‚Åª ‚â° x
 inv-invol (n , a) = ap (_, a) (complement-involutive n)

\end{code}

We will quotient the following type FA to get the undelying type of
the free group:

\begin{code}

 FA : ùì§ Ãá
 FA = List X

 Œ∑ : A ‚Üí FA
 Œ∑ a = [ ‚ÇÄ , a ]

\end{code}

We will quotient by the equivalence relation generated by the
following reduction relation:

\begin{code}

 _‚ñ∑_ : FA ‚Üí FA ‚Üí ùì§ Ãá
 s ‚ñ∑ t = Œ£ u Íûâ FA , Œ£ v Íûâ FA , Œ£ x Íûâ X , (s ‚â° u ++ [ x ] ++ [ x ‚Åª ] ++ v)
                                       √ó (t ‚â° u ++ v)

 infix 1 _‚ñ∑_

 ‚à∑-‚ñ∑ : {s t : FA} (x : X) ‚Üí s ‚ñ∑ t ‚Üí x ‚à∑ s ‚ñ∑ x ‚à∑ t
 ‚à∑-‚ñ∑ x (u , v , y , p , q) = (x ‚à∑ u) , v , y , ap (x ‚à∑_) p , ap (x ‚à∑_) q

\end{code}

The following is a lemma for the Church-Rosser property, proved by
induction on u‚ÇÄ and u‚ÇÅ:

\begin{code}

 churros : (u‚ÇÄ v‚ÇÄ u‚ÇÅ v‚ÇÅ : FA) (x‚ÇÄ x‚ÇÅ : X)

         ‚Üí u‚ÇÄ ++  [ x‚ÇÄ ] ++ [ x‚ÇÄ ‚Åª ] ++ v‚ÇÄ
         ‚â° u‚ÇÅ ++  [ x‚ÇÅ ] ++ [ x‚ÇÅ ‚Åª ] ++ v‚ÇÅ

         ‚Üí (u‚ÇÄ ++ v‚ÇÄ ‚â° u‚ÇÅ ++ v‚ÇÅ)
         + (Œ£ t Íûâ FA , (u‚ÇÄ ++ v‚ÇÄ ‚ñ∑ t) √ó (u‚ÇÅ ++ v‚ÇÅ ‚ñ∑ t))

 churros u‚ÇÄ v‚ÇÄ u‚ÇÅ v‚ÇÅ x‚ÇÄ x‚ÇÅ = f u‚ÇÄ u‚ÇÅ
  where
   f : (u‚ÇÄ u‚ÇÅ : FA)
     ‚Üí u‚ÇÄ ++  [ x‚ÇÄ ] ++ [ x‚ÇÄ ‚Åª ] ++ v‚ÇÄ ‚â° u‚ÇÅ ++  [ x‚ÇÅ ] ++ [ x‚ÇÅ ‚Åª ] ++ v‚ÇÅ
     ‚Üí (u‚ÇÄ ++ v‚ÇÄ ‚â° u‚ÇÅ ++ v‚ÇÅ) + (Œ£ t Íûâ FA , (u‚ÇÄ ++ v‚ÇÄ ‚ñ∑ t) √ó (u‚ÇÅ ++ v‚ÇÅ ‚ñ∑ t))

   f [] [] p = inl Œ≥
    where
     have : x‚ÇÄ ‚à∑ x‚ÇÄ ‚Åª  ‚à∑ v‚ÇÄ
          ‚â° x‚ÇÅ ‚à∑ x‚ÇÅ ‚Åª  ‚à∑ v‚ÇÅ
     have = p

     Œ≥ : v‚ÇÄ ‚â° v‚ÇÅ
     Œ≥ = equal-tails (equal-tails p)

   f [] (y‚ÇÅ ‚à∑ []) p = inl Œ≥
    where
     have : x‚ÇÄ ‚à∑ x‚ÇÄ ‚Åª ‚à∑ v‚ÇÄ
          ‚â° y‚ÇÅ ‚à∑ x‚ÇÅ   ‚à∑ x‚ÇÅ ‚Åª ‚à∑ v‚ÇÅ
     have = p

     q = x‚ÇÅ ‚Åª     ‚â°‚ü® ap _‚Åª ((equal-heads (equal-tails p))‚Åª¬π) ‚ü©
         (x‚ÇÄ ‚Åª) ‚Åª ‚â°‚ü® inv-invol x‚ÇÄ ‚ü©
         x‚ÇÄ       ‚â°‚ü® equal-heads p ‚ü©
         y‚ÇÅ       ‚àé

     Œ≥ : v‚ÇÄ ‚â° y‚ÇÅ ‚à∑ v‚ÇÅ
     Œ≥ = transport (Œª - ‚Üí v‚ÇÄ ‚â° - ‚à∑ v‚ÇÅ) q (equal-tails (equal-tails p))

   f [] (y‚ÇÅ ‚à∑ z‚ÇÅ ‚à∑ u‚ÇÅ) p = inr Œ≥
    where
     have : x‚ÇÄ ‚à∑ x‚ÇÄ ‚Åª ‚à∑ v‚ÇÄ
          ‚â° y‚ÇÅ ‚à∑ z‚ÇÅ   ‚à∑ u‚ÇÅ ++ [ x‚ÇÅ ] ++ [ x‚ÇÅ ‚Åª ] ++ v‚ÇÅ
     have = p

     d' : u‚ÇÅ ++ [ x‚ÇÅ ] ++ [ x‚ÇÅ ‚Åª ] ++ v‚ÇÅ ‚ñ∑ u‚ÇÅ ++ v‚ÇÅ
     d' = u‚ÇÅ , v‚ÇÅ , x‚ÇÅ , refl , refl

     d : v‚ÇÄ ‚ñ∑ u‚ÇÅ ++ v‚ÇÅ
     d = transport (_‚ñ∑ u‚ÇÅ ++ v‚ÇÅ) ((equal-tails (equal-tails p))‚Åª¬π) d'

     q = y‚ÇÅ ‚Åª ‚â°‚ü® (ap (_‚Åª) (equal-heads p)‚Åª¬π) ‚ü©
         x‚ÇÄ ‚Åª ‚â°‚ü® equal-heads (equal-tails p) ‚ü©
         z‚ÇÅ   ‚àé

     e' : y‚ÇÅ ‚à∑ y‚ÇÅ ‚Åª ‚à∑ u‚ÇÅ ++ v‚ÇÅ ‚ñ∑ u‚ÇÅ ++ v‚ÇÅ
     e' = [] , (u‚ÇÅ ++ v‚ÇÅ) , y‚ÇÅ , refl , refl

     e : y‚ÇÅ ‚à∑ z‚ÇÅ ‚à∑ u‚ÇÅ ++ v‚ÇÅ ‚ñ∑ u‚ÇÅ ++ v‚ÇÅ
     e = transport (Œª - ‚Üí y‚ÇÅ ‚à∑ - ‚à∑ u‚ÇÅ ++ v‚ÇÅ ‚ñ∑ u‚ÇÅ ++ v‚ÇÅ) q e'

     Œ≥ : Œ£ t Íûâ FA , (v‚ÇÄ ‚ñ∑ t) √ó (y‚ÇÅ ‚à∑ z‚ÇÅ ‚à∑ u‚ÇÅ ++ v‚ÇÅ ‚ñ∑ t)
     Œ≥ = (u‚ÇÅ ++ v‚ÇÅ) , d , e

   f (y‚ÇÄ ‚à∑ []) [] p = inl Œ≥
    where
     have : y‚ÇÄ ‚à∑ x‚ÇÄ   ‚à∑ x‚ÇÄ ‚Åª ‚à∑ v‚ÇÄ
          ‚â° x‚ÇÅ ‚à∑ x‚ÇÅ ‚Åª ‚à∑ v‚ÇÅ
     have = p

     Œ≥ = y‚ÇÄ ‚à∑ v‚ÇÄ       ‚â°‚ü® ap (_‚à∑ v‚ÇÄ) (equal-heads p) ‚ü©
         x‚ÇÅ ‚à∑ v‚ÇÄ       ‚â°‚ü® ap (_‚à∑ v‚ÇÄ) ((inv-invol x‚ÇÅ)‚Åª¬π) ‚ü©
         (x‚ÇÅ ‚Åª) ‚Åª ‚à∑ v‚ÇÄ ‚â°‚ü® ap (Œª - ‚Üí - ‚Åª ‚à∑ v‚ÇÄ) ((equal-heads (equal-tails p))‚Åª¬π) ‚ü©
         x‚ÇÄ ‚Åª ‚à∑ v‚ÇÄ     ‚â°‚ü® equal-tails (equal-tails p) ‚ü©
         v‚ÇÅ            ‚àé

   f (y‚ÇÄ ‚à∑ z‚ÇÄ ‚à∑ u‚ÇÄ) [] p = inr Œ≥
    where
     have : y‚ÇÄ ‚à∑ z‚ÇÄ   ‚à∑ u‚ÇÄ ++ [ x‚ÇÄ ] ++ [ x‚ÇÄ ‚Åª ] ++ v‚ÇÄ
          ‚â° x‚ÇÅ ‚à∑ x‚ÇÅ ‚Åª ‚à∑ v‚ÇÅ
     have = p

     q = y‚ÇÄ ‚Åª ‚â°‚ü® ap (_‚Åª) (equal-heads p) ‚ü©
         x‚ÇÅ ‚Åª ‚â°‚ü® (equal-heads (equal-tails p))‚Åª¬π ‚ü©
         z‚ÇÄ   ‚àé

     d' : y‚ÇÄ ‚à∑ y‚ÇÄ ‚Åª ‚à∑ u‚ÇÄ ++ v‚ÇÄ ‚ñ∑ u‚ÇÄ ++ v‚ÇÄ
     d' = [] , (u‚ÇÄ ++ v‚ÇÄ) , y‚ÇÄ , refl , refl

     d : y‚ÇÄ ‚à∑ z‚ÇÄ ‚à∑ u‚ÇÄ ++ v‚ÇÄ ‚ñ∑ u‚ÇÄ ++ v‚ÇÄ
     d = transport (Œª - ‚Üí y‚ÇÄ ‚à∑ - ‚à∑ u‚ÇÄ ++ v‚ÇÄ ‚ñ∑ u‚ÇÄ ++ v‚ÇÄ) q d'

     e' : u‚ÇÄ ++ [ x‚ÇÄ ] ++ [ x‚ÇÄ ‚Åª ] ++ v‚ÇÄ ‚ñ∑ u‚ÇÄ ++ v‚ÇÄ
     e' = u‚ÇÄ , v‚ÇÄ , x‚ÇÄ , refl , refl

     e : v‚ÇÅ ‚ñ∑ u‚ÇÄ ++ v‚ÇÄ
     e = transport (_‚ñ∑ u‚ÇÄ ++ v‚ÇÄ) (equal-tails (equal-tails p)) e'

     Œ≥ : Œ£ t Íûâ FA , (y‚ÇÄ ‚à∑ z‚ÇÄ ‚à∑ u‚ÇÄ ++ v‚ÇÄ ‚ñ∑ t) √ó (v‚ÇÅ ‚ñ∑ t)
     Œ≥ = (u‚ÇÄ ++ v‚ÇÄ) , d , e

   f (y‚ÇÄ ‚à∑ u‚ÇÄ) (y‚ÇÅ ‚à∑ u‚ÇÅ) p = Œ≥
    where
     have : y‚ÇÄ ‚à∑ u‚ÇÄ ++ [ x‚ÇÄ ] ++ [ x‚ÇÄ ‚Åª ] ++ v‚ÇÄ
          ‚â° y‚ÇÅ ‚à∑ u‚ÇÅ ++ [ x‚ÇÅ ] ++ [ x‚ÇÅ ‚Åª ] ++ v‚ÇÅ
     have = p

     IH : (u‚ÇÄ ++ v‚ÇÄ ‚â° u‚ÇÅ ++ v‚ÇÅ) + (Œ£ t Íûâ FA , (u‚ÇÄ ++ v‚ÇÄ ‚ñ∑ t) √ó (u‚ÇÅ ++ v‚ÇÅ ‚ñ∑ t))
     IH = f u‚ÇÄ u‚ÇÅ (equal-tails p)

     Œì : X ‚Üí X ‚Üí ùì§ Ãá
     Œì y‚ÇÄ y‚ÇÅ = (y‚ÇÄ ‚à∑ u‚ÇÄ ++ v‚ÇÄ ‚â° y‚ÇÅ ‚à∑ u‚ÇÅ ++ v‚ÇÅ)
             + (Œ£ t Íûâ FA , (y‚ÇÄ ‚à∑ u‚ÇÄ ++ v‚ÇÄ ‚ñ∑ t) √ó (y‚ÇÅ ‚à∑ u‚ÇÅ ++ v‚ÇÅ ‚ñ∑ t))

     Œ¥ : type-of IH ‚Üí ‚àÄ {y‚ÇÄ y‚ÇÅ} ‚Üí y‚ÇÄ ‚â° y‚ÇÅ ‚Üí Œì y‚ÇÄ y‚ÇÅ
     Œ¥ (inl q)           {y‚ÇÄ} refl = inl (ap (y‚ÇÄ ‚à∑_) q)
     Œ¥ (inr (t , d , e)) {y‚ÇÄ} refl = inr ((y‚ÇÄ ‚à∑ t) , ‚à∑-‚ñ∑ y‚ÇÄ d , ‚à∑-‚ñ∑ y‚ÇÄ e)

     Œ≥ : Œì y‚ÇÄ y‚ÇÅ
     Œ≥ = Œ¥ IH (equal-heads p)

 Church-Rosser : (s t‚ÇÄ t‚ÇÅ : FA)
               ‚Üí s ‚ñ∑ t‚ÇÄ
               ‚Üí s ‚ñ∑ t‚ÇÅ
               ‚Üí (t‚ÇÄ ‚â° t‚ÇÅ) + (Œ£ t Íûâ FA , (t‚ÇÄ ‚ñ∑ t) √ó (t‚ÇÅ ‚ñ∑ t))
 Church-Rosser s t‚ÇÄ t‚ÇÅ (u‚ÇÄ , v‚ÇÄ , x‚ÇÄ , p‚ÇÄ , q‚ÇÄ) (u‚ÇÅ , v‚ÇÅ , x‚ÇÅ , p‚ÇÅ , q‚ÇÅ) = Œ≥ Œ¥
  where
   Œ¥ : (u‚ÇÄ ++ v‚ÇÄ ‚â° u‚ÇÅ ++ v‚ÇÅ) + (Œ£ t Íûâ FA , (u‚ÇÄ ++ v‚ÇÄ ‚ñ∑ t) √ó (u‚ÇÅ ++ v‚ÇÅ ‚ñ∑ t))
   Œ¥ = churros u‚ÇÄ v‚ÇÄ u‚ÇÅ v‚ÇÅ x‚ÇÄ x‚ÇÅ (p‚ÇÄ ‚Åª¬π ‚àô p‚ÇÅ)

   Œ≥ : type-of Œ¥ ‚Üí (t‚ÇÄ ‚â° t‚ÇÅ) + (Œ£ t Íûâ FA , (t‚ÇÄ ‚ñ∑ t) √ó (t‚ÇÅ ‚ñ∑ t))
   Œ≥ (inl q)           = inl (q‚ÇÄ ‚àô q ‚àô q‚ÇÅ ‚Åª¬π)
   Œ≥ (inr (t , p , q)) = inr (t , transport (_‚ñ∑ t) (q‚ÇÄ ‚Åª¬π) p ,
                                  transport (_‚ñ∑ t) (q‚ÇÅ ‚Åª¬π) q)

\end{code}

The symmetric closure of _‚ñ∑_:

\begin{code}

 open import SRTclosure

 _‚óÅ‚ñ∑_ : FA ‚Üí FA ‚Üí ùì§ Ãá
 _‚óÅ‚ñ∑_ = s-closure _‚ñ∑_

 infix 1 _‚óÅ‚ñ∑_

\end{code}

Symmetric, reflexive, transitive closure of _‚ñ∑_:

\begin{code}

 open psrt pt

 _‚àæ_ : FA ‚Üí FA ‚Üí ùì§ Ãá
 _‚àæ_ = srt-closure _‚ñ∑_

\end{code}

Propositional, symmetric, reflexive, transitive closure of _‚ñ∑_:

\begin{code}

 _‚àæ‚Çö_ : FA ‚Üí FA ‚Üí ùì§ Ãá
 _‚àæ‚Çö_ = psrt-closure _‚ñ∑_

\end{code}

The above is just the truncation of _‚àæ_. Most of the work will be done
before truncation. The following is for reasoning with chain of
equivalences:

\begin{code}

 infix 1 _‚àæ_

 _‚àæ‚ü®_‚ü©_ : (s : FA) {t u : FA} ‚Üí s ‚àæ t ‚Üí t ‚àæ u ‚Üí s ‚àæ u
 _ ‚àæ‚ü® p ‚ü© q = srt-transitive _‚ñ∑_ _ _ _ p q

 _‚àæ‚àé : (s : FA) ‚Üí s ‚àæ s
 _‚àæ‚àé _ = srt-reflexive _‚ñ∑_ _

 infixr 0 _‚àæ‚ü®_‚ü©_
 infix  1 _‚àæ‚àé

\end{code}

The group operation before quotienting is simply concatenation.

Concatenation is a left congruence:

\begin{code}

 ++-‚ñ∑-left : (s s' t : FA) ‚Üí s ‚ñ∑ s' ‚Üí s ++ t ‚ñ∑ s' ++ t
 ++-‚ñ∑-left s s' t (u , v , x , p , q) = u , (v ++ t) , x , p' , q'
  where
   p' = s ++ t                            ‚â°‚ü® ap (_++ t) p ‚ü©
        (u ++ [ x ] ++ [ x ‚Åª ] ++ v) ++ t ‚â°‚ü® ++-assoc u ([ x ] ++ [ x ‚Åª ] ++ v) t ‚ü©
        u ++ [ x ] ++ [ x ‚Åª ] ++ v ++ t   ‚àé

   q' = s' ++ t       ‚â°‚ü® ap (_++ t) q ‚ü©
        (u ++ v) ++ t ‚â°‚ü® ++-assoc u v t ‚ü©
        u ++ v ++ t   ‚àé

 ++-‚óÅ‚ñ∑-left : (s s' t : FA) ‚Üí s ‚óÅ‚ñ∑ s' ‚Üí s ++ t ‚óÅ‚ñ∑ s' ++ t
 ++-‚óÅ‚ñ∑-left s s' t (inl a) = inl (++-‚ñ∑-left s s' t a)
 ++-‚óÅ‚ñ∑-left s s' t (inr a) = inr (++-‚ñ∑-left s' s t a)

 ++-iteration-left : (s s' t : FA) (n : ‚Ñï)
                   ‚Üí iteration _‚óÅ‚ñ∑_ n s s'
                   ‚Üí iteration _‚óÅ‚ñ∑_ n (s ++ t) (s' ++ t)
 ++-iteration-left s s  t zero     refl        = refl
 ++-iteration-left s s' t (succ n) (u , b , c) = (u ++ t) ,
                                                 ++-‚óÅ‚ñ∑-left s u t b ,
                                                 ++-iteration-left u s' t n c

 ++-cong-left : (s s' t : FA) ‚Üí s ‚àæ s' ‚Üí s ++ t ‚àæ s' ++ t
 ++-cong-left s s' t (n , a) = n , ++-iteration-left s s' t n a

\end{code}

It is also a right congruence:

\begin{code}

 ‚à∑-‚óÅ‚ñ∑ : (x : X) {s t : FA} ‚Üí s ‚óÅ‚ñ∑ t ‚Üí x ‚à∑ s ‚óÅ‚ñ∑ x ‚à∑ t
 ‚à∑-‚óÅ‚ñ∑ x (inl e) = inl (‚à∑-‚ñ∑ x e)
 ‚à∑-‚óÅ‚ñ∑ x (inr e) = inr (‚à∑-‚ñ∑ x e)

 ‚à∑-iteration : (x : X) {s t : FA} (n : ‚Ñï)
             ‚Üí iteration _‚óÅ‚ñ∑_ n s t
             ‚Üí iteration _‚óÅ‚ñ∑_ n (x ‚à∑ s) (x ‚à∑ t)
 ‚à∑-iteration x zero refl = refl
 ‚à∑-iteration x (succ n) (u , b , c) = (x ‚à∑ u) , ‚à∑-‚óÅ‚ñ∑ x b , ‚à∑-iteration x n c

 ‚à∑-cong : (x : X) {s t : FA} ‚Üí s ‚àæ t ‚Üí x ‚à∑ s ‚àæ x ‚à∑ t
 ‚à∑-cong x (n , a) = n , ‚à∑-iteration x n a

 ++-cong-right : (s {t t'} : FA) ‚Üí t ‚àæ t' ‚Üí s ++ t ‚àæ s ++ t'
 ++-cong-right []      e = e
 ++-cong-right (x ‚à∑ s) e = ‚à∑-cong x (++-cong-right s e)

\end{code}

And therefore it is a two-sided congruence:

\begin{code}

 ++-cong : {s s' t t' : FA} ‚Üí s ‚àæ s' ‚Üí t ‚àæ t' ‚Üí s ++ t ‚àæ s' ++ t'
 ++-cong {s} {s'} {t} {t'} d e = s ++ t   ‚àæ‚ü® ++-cong-left s s' t d ‚ü©
                                 s' ++ t  ‚àæ‚ü® ++-cong-right s' e ‚ü©
                                 s' ++ t' ‚àæ‚àé
\end{code}

The group inverse, before quotienting:

\begin{code}

 inv : FA ‚Üí FA
 inv [] = []
 inv (x ‚à∑ s) = inv s ++ [ x ‚Åª ]

\end{code}

It is a congruence:

\begin{code}

 inv-++ : (s t : FA) ‚Üí inv (s ++ t) ‚â° inv t ++ inv s
 inv-++ []      t = []-right-neutral (inv t)
 inv-++ (x ‚à∑ s) t = inv (s ++ t) ++ [ x ‚Åª ]     ‚â°‚ü® IH ‚ü©
                    (inv t ++ inv s) ++ [ x ‚Åª ] ‚â°‚ü® assoc ‚ü©
                    inv t ++ (inv s ++ [ x ‚Åª ]) ‚àé
  where
   IH    = ap (_++ [ x ‚Åª ]) (inv-++ s t)
   assoc = ++-assoc (inv t) (inv s) [ x ‚Åª ]

 inv-‚ñ∑ : {s t : FA} ‚Üí s ‚ñ∑ t ‚Üí inv s ‚ñ∑ inv t
 inv-‚ñ∑ {s} {t} (u , v , y , p , q) = inv v , inv u , y , p' , q'
  where
   p' = inv s                                     ‚â°‚ü® I ‚ü©
        inv (u ++ [ y ] ++ [ y ‚Åª ] ++ v)          ‚â°‚ü® II ‚ü©
        inv ([ y ] ++ [ y ‚Åª ] ++ v) ++ inv u      ‚â°‚ü® III ‚ü©
        inv (([ y ] ++ [ y ‚Åª ]) ++ v) ++ inv u    ‚â°‚ü® IV ‚ü©
        (inv v ++ [ (y ‚Åª)‚Åª ] ++ [ y ‚Åª ]) ++ inv u ‚â°‚ü® V ‚ü©
        (inv v ++ [ y ] ++ [ y ‚Åª ]) ++ inv u      ‚â°‚ü® VI ‚ü©
        inv v ++ [ y ] ++ [ y ‚Åª ] ++ inv u        ‚àé
    where
     I   = ap inv p
     II  = inv-++ u ([ y ] ++ [ y ‚Åª ] ++ v)
     III = ap (Œª - ‚Üí inv - ++ inv u) ((++-assoc [ y ] [ y ‚Åª ] v)‚Åª¬π)
     IV  = ap (_++ inv u) (inv-++ ([ y ] ++ [ y ‚Åª ]) v)
     V   = ap (Œª - ‚Üí (inv v ++ [ - ] ++ [ y ‚Åª ]) ++ inv u) (inv-invol y)
     VI  = ++-assoc (inv v) ([ y ] ++ [ y ‚Åª ]) (inv u)

   q' = inv t          ‚â°‚ü® ap inv q ‚ü©
        inv (u ++ v)   ‚â°‚ü® inv-++ u v ‚ü©
        inv v ++ inv u ‚àé

 inv-‚óÅ‚ñ∑ : {s t : FA} ‚Üí s ‚óÅ‚ñ∑ t ‚Üí inv s ‚óÅ‚ñ∑ inv t
 inv-‚óÅ‚ñ∑ (inl e) = inl (inv-‚ñ∑ e)
 inv-‚óÅ‚ñ∑ (inr e) = inr (inv-‚ñ∑ e)

 inv-iteration : {s t : FA} (n : ‚Ñï)
               ‚Üí iteration _‚óÅ‚ñ∑_ n s t
               ‚Üí iteration _‚óÅ‚ñ∑_ n (inv s) (inv t)
 inv-iteration zero refl = refl
 inv-iteration (succ n) (u , b , c) = inv u , inv-‚óÅ‚ñ∑ b , inv-iteration n c

 inv-cong : {s t : FA} ‚Üí s ‚àæ t ‚Üí inv s ‚àæ inv t
 inv-cong (n , a) = n , inv-iteration n a

\end{code}

The inverse really is an inverse:

\begin{code}

 =-‚àæ : {s s' : FA} ‚Üí s ‚â° s' ‚Üí s ‚àæ s'
 =-‚àæ {s} refl = srt-reflexive _‚ñ∑_ s

 inv-lemma : (x : X) ‚Üí [ x ] ++ [ x ‚Åª ] ‚àæ []
 inv-lemma x = srt-extension _‚ñ∑_ _ [] ([] , [] , x , refl , refl)

 inv-lemma' : (x : X) ‚Üí [ x ‚Åª ] ++ [ x ] ‚àæ []
 inv-lemma' x = srt-extension _‚ñ∑_ _ _
                 ([] ,
                  [] ,
                  (x ‚Åª) ,
                  ap (Œª - ‚Üí [ x ‚Åª ] ++ [ - ]) ((inv-invol x)‚Åª¬π) , refl)

 inv-property : (s : FA) ‚Üí s ++ inv s ‚àæ []
 inv-property []      = srt-reflexive _‚ñ∑_ []
 inv-property (x ‚à∑ s) = Œ≥
  where
   IH : s ++ inv s ‚àæ []
   IH = inv-property s

   Œ≥ = [ x ] ++ s ++ inv s ++ [ x ‚Åª ]   ‚àæ‚ü® I ‚ü©
       [ x ] ++ (s ++ inv s) ++ [ x ‚Åª ] ‚àæ‚ü® II ‚ü©
       [ x ] ++ [ x ‚Åª ]                 ‚àæ‚ü® III ‚ü©
       []                               ‚àæ‚àé
    where
     I   = =-‚àæ  (ap (x ‚à∑_) (++-assoc s (inv s) [ x ‚Åª ])‚Åª¬π)
     II  = ++-cong-right [ x ] (++-cong-left _ _ _ IH)
     III = inv-lemma x

 inv-property' : (s : FA) ‚Üí inv s ++ s ‚àæ []
 inv-property' []      = srt-reflexive _‚ñ∑_ []
 inv-property' (x ‚à∑ s) = Œ≥
  where
   Œ≥ = (inv s ++ [ x ‚Åª ]) ++ (x ‚à∑ s)    ‚àæ‚ü® I ‚ü©
       inv s ++ ([ x ‚Åª ] ++ [ x ] ++ s) ‚àæ‚ü® II ‚ü©
       inv s ++ ([ x ‚Åª ] ++ [ x ]) ++ s ‚àæ‚ü® III ‚ü©
       inv s ++ s                       ‚àæ‚ü® IV ‚ü©
       []                               ‚àæ‚àé
    where
     I   = =-‚àæ (++-assoc (inv s) [ x ‚Åª ] (x ‚à∑ s))
     II  = =-‚àæ (ap (inv s ++_) ((++-assoc [ x ‚Åª ] [ x ] s)‚Åª¬π))
     III = ++-cong-right (inv s) (++-cong-left _ _ _ (inv-lemma' x))
     IV  = inv-property' s

\end{code}

The insertion of generators is left cancellable before quotienting:

\begin{code}

 Œ∑-lc : (a b : A) ‚Üí Œ∑ a ‚â° Œ∑ b ‚Üí a ‚â° b
 Œ∑-lc a b = ap f
  where
   f : FA ‚Üí A
   f []            = a
   f ((n , c) ‚à∑ s) = c

\end{code}

Now we should be able to prove this from the Church-Rosser property,
which will give that the insertion of generators is injective after
quotienting:

\begin{code}
{-
 Œ∑-‚àæ : (a b : A) ‚Üí Œ∑ a ‚àæ Œ∑ b ‚Üí a ‚â° b
 Œ∑-‚àæ a b e = ?

 Œ∑-‚àæ‚Çö : (a b : A) ‚Üí is-set A ‚Üí Œ∑ a ‚àæ‚Çö Œ∑ b ‚Üí a ‚â° b
 Œ∑-‚àæ‚Çö = by Œ∑-‚àæ because A is a set and hence a ‚â° b is a
        proposition and because Œ∑ a ‚àæ‚Çö Œ∑ b is ‚à• Œ∑ a ‚àæ Œ∑ b ‚à•
-}
\end{code}

To be continued.

TODO. Quotient FA to get the free group, with a proof that the insertion
of generators is left-cancellable and hence, being a map of sets, an
embedding.
