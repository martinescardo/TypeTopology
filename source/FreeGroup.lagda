Martin Escardo, January - February 2021.

Ongoing joint work with Marc Bezem, Thierry Coquand, and Peter Dybjer.

For the moment this file is not for public consumption, but it is
publicly visible.

We construct free groups in HoTT/UF in Agda without HIT's other than
propositional truncation, and with no consequence of univalence other
than function extensionality and propositional extensionality.

This is based on Fred Richman's book on constructive algebra. In
particular, this construction shows that the inclusion of generators
is injective (and hence an embedding in the sense of HoTT/UF). It is
noteworthy and surprising that the set of generators is not required
to have decidable equality.

This is part of Martin Escardo's Agda development TypeTopology,
whose philosophy is to be Spartan. At the moment we are a little bit
Athenian, though, with the use of Agda lists rather than Spartan-MLTT
constructed lists, although we intend to fix this in the future. (The
way to do it is already present in the module Fin.lagda.)

\begin{code}

{-# OPTIONS --without-K --safe #-} -- --exact-split

\end{code}

NB. This repository is supposed to use exact-split, but even though
everything has been developed using case-split, the exact-split check
fails (in Agda 2.6.1) in the helper function f of the function
churros. This seems to be a bug, but we are not sure.

\begin{code}

module FreeGroup where

open import SpartanMLTT
open import Two
open import Two-Properties

open import UF-PropTrunc
open import UF-Univalence
open import UF-Base
open import UF-Subsingletons
open import UF-Subsingletons-FunExt
open import UF-Equiv
open import UF-UA-FunExt
open import UF-FunExt

\end{code}

It is possible to work with lists *defined* from the ingredients of
our Spartan MLTT (see the module Fin.lagda). For the moment we are
Athenian in this respect:

\begin{code}

data List {ğ“¤} (X : ğ“¤ Ì‡ ) : ğ“¤ Ì‡  where
 [] : List X
 _âˆ·_ : X â†’ List X â†’ List X

infixr 3 _âˆ·_

equal-heads : {X : ğ“¤ Ì‡ } {x y : X} {s t : List X}
            â†’ x âˆ· s â‰¡ y âˆ· t
            â†’ x â‰¡ y
equal-heads refl = refl

equal-tails : {X : ğ“¤ Ì‡ } {x y : X} {s t : List X}
            â†’ x âˆ· s â‰¡ y âˆ· t
            â†’ s â‰¡ t
equal-tails {ğ“¤} {X} refl = refl

\end{code}

It will be convenient to have a notation for singleton lists:

\begin{code}

[_] : {X : ğ“¤ Ì‡ } â†’ X â†’ List X
[ x ] = x âˆ· []

_++_ : {X : ğ“¤ Ì‡ } â†’ List X â†’ List X â†’ List X
[]      ++ t = t
(x âˆ· s) ++ t = x âˆ· (s ++ t)

infixr 4 _++_

[]-right-neutral : {X : ğ“¤ Ì‡ } (s : List X) â†’ s â‰¡ s ++ []
[]-right-neutral []      = refl
[]-right-neutral (x âˆ· s) = ap (x âˆ·_) ([]-right-neutral s)

++-assoc : {X : ğ“¤ Ì‡ } â†’ associative (_++_ {ğ“¤} {X})
++-assoc []      t u = refl
++-assoc (x âˆ· s) t u = ap (x âˆ·_) (++-assoc s t u)

\end{code}

The above is all we need about lists.

We now construct the group freely generated by a set A. The set-hood
requirement is needed later only, and so we don't include it as an
assumption in the following anonymous module:

\begin{code}

module _ {ğ“¤ : Universe}
         {A : ğ“¤ Ì‡ }
       where

 X : ğ“¤ Ì‡
 X = ğŸš Ã— A

 _â» : X â†’ X
 (n , a)â» = (complement n , a)

 inv-invol : (x : X) â†’ (x â»)â» â‰¡ x
 inv-invol (n , a) = ap (_, a) (complement-involutive n)

\end{code}

The idea is that list concatenation _++_ will be the group operation
after suitable quotienting, with the empty list [] as the neutral
element.

We will quotient the following type FA to get the undelying type of
the free group:

\begin{code}

 FA : ğ“¤ Ì‡
 FA = List X

 Î· : A â†’ FA
 Î· a = [ (â‚€ , a) ]

\end{code}

The type ğŸš has two elements â‚€ and â‚, and a prefix â‚ to an element a of
the type A means it is formally inverted. So in the inclusion of
generators Î· we indicate that the element a is not inverted by
prefixing it with â‚€.

We will quotient by the equivalence relation generated by the
following reduction relation:

\begin{code}

 _â–·_ : FA â†’ FA â†’ ğ“¤ Ì‡
 s â–· t = Î£ u ê‰ FA , Î£ v ê‰ FA , Î£ x ê‰ X , (s â‰¡ u ++ [ x ] ++ [ x â» ] ++ v)
                                       Ã— (t â‰¡ u ++ v)

 infix 1 _â–·_

 âˆ·-â–· : {s t : FA} (x : X) â†’ s â–· t â†’ x âˆ· s â–· x âˆ· t
 âˆ·-â–· x (u , v , y , p , q) = (x âˆ· u) , v , y , ap (x âˆ·_) p , ap (x âˆ·_) q

\end{code}

The following is a lemma for the Church-Rosser property, proved by
induction on uâ‚€ and uâ‚:

\begin{code}

 churros : (uâ‚€ vâ‚€ uâ‚ vâ‚ : FA) (xâ‚€ xâ‚ : X)

         â†’ uâ‚€ ++  [ xâ‚€ ] ++ [ xâ‚€ â» ] ++ vâ‚€
         â‰¡ uâ‚ ++  [ xâ‚ ] ++ [ xâ‚ â» ] ++ vâ‚

         â†’ (uâ‚€ ++ vâ‚€ â‰¡ uâ‚ ++ vâ‚)
         + (Î£ t ê‰ FA , (uâ‚€ ++ vâ‚€ â–· t) Ã— (uâ‚ ++ vâ‚ â–· t))

 churros uâ‚€ vâ‚€ uâ‚ vâ‚ xâ‚€ xâ‚ = f uâ‚€ uâ‚
  where
   f : (uâ‚€ uâ‚ : FA)
     â†’ uâ‚€ ++  [ xâ‚€ ] ++ [ xâ‚€ â» ] ++ vâ‚€ â‰¡ uâ‚ ++  [ xâ‚ ] ++ [ xâ‚ â» ] ++ vâ‚
     â†’ (uâ‚€ ++ vâ‚€ â‰¡ uâ‚ ++ vâ‚) + (Î£ t ê‰ FA , (uâ‚€ ++ vâ‚€ â–· t) Ã— (uâ‚ ++ vâ‚ â–· t))

   f [] [] p = inl Î³
    where
     have : xâ‚€ âˆ· xâ‚€ â»  âˆ· vâ‚€
          â‰¡ xâ‚ âˆ· xâ‚ â»  âˆ· vâ‚
     have = p

     Î³ : vâ‚€ â‰¡ vâ‚
     Î³ = equal-tails (equal-tails p)

   f [] (yâ‚ âˆ· []) p = inl Î³
    where
     have : xâ‚€ âˆ· xâ‚€ â» âˆ· vâ‚€
          â‰¡ yâ‚ âˆ· xâ‚   âˆ· xâ‚ â» âˆ· vâ‚
     have = p

     q = xâ‚ â»    â‰¡âŸ¨ ap _â» ((equal-heads (equal-tails p))â»Â¹) âŸ©
         (xâ‚€ â»)â» â‰¡âŸ¨ inv-invol xâ‚€ âŸ©
         xâ‚€      â‰¡âŸ¨ equal-heads p âŸ©
         yâ‚      âˆ

     Î³ : vâ‚€ â‰¡ yâ‚ âˆ· vâ‚
     Î³ = transport (Î» - â†’ vâ‚€ â‰¡ - âˆ· vâ‚) q (equal-tails (equal-tails p))

   f [] (yâ‚ âˆ· zâ‚ âˆ· uâ‚) p = inr Î³
    where
     have : xâ‚€ âˆ· xâ‚€ â» âˆ· vâ‚€
          â‰¡ yâ‚ âˆ· zâ‚   âˆ· uâ‚ ++ [ xâ‚ ] ++ [ xâ‚ â» ] ++ vâ‚
     have = p

     d' : uâ‚ ++ [ xâ‚ ] ++ [ xâ‚ â» ] ++ vâ‚ â–· uâ‚ ++ vâ‚
     d' = uâ‚ , vâ‚ , xâ‚ , refl , refl

     d : vâ‚€ â–· uâ‚ ++ vâ‚
     d = transport (_â–· uâ‚ ++ vâ‚) ((equal-tails (equal-tails p))â»Â¹) d'

     q = yâ‚ â» â‰¡âŸ¨ (ap (_â») (equal-heads p)â»Â¹) âŸ©
         xâ‚€ â» â‰¡âŸ¨ equal-heads (equal-tails p) âŸ©
         zâ‚   âˆ

     e' : yâ‚ âˆ· yâ‚ â» âˆ· uâ‚ ++ vâ‚ â–· uâ‚ ++ vâ‚
     e' = [] , (uâ‚ ++ vâ‚) , yâ‚ , refl , refl

     e : yâ‚ âˆ· zâ‚ âˆ· uâ‚ ++ vâ‚ â–· uâ‚ ++ vâ‚
     e = transport (Î» - â†’ yâ‚ âˆ· - âˆ· uâ‚ ++ vâ‚ â–· uâ‚ ++ vâ‚) q e'

     Î³ : Î£ t ê‰ FA , (vâ‚€ â–· t) Ã— (yâ‚ âˆ· zâ‚ âˆ· uâ‚ ++ vâ‚ â–· t)
     Î³ = (uâ‚ ++ vâ‚) , d , e

   f (yâ‚€ âˆ· []) [] p = inl Î³
    where
     have : yâ‚€ âˆ· xâ‚€   âˆ· xâ‚€ â» âˆ· vâ‚€
          â‰¡ xâ‚ âˆ· xâ‚ â» âˆ· vâ‚
     have = p

     Î³ = yâ‚€ âˆ· vâ‚€      â‰¡âŸ¨ ap (_âˆ· vâ‚€) (equal-heads p) âŸ©
         xâ‚ âˆ· vâ‚€      â‰¡âŸ¨ ap (_âˆ· vâ‚€) ((inv-invol xâ‚)â»Â¹) âŸ©
         (xâ‚ â»)â» âˆ· vâ‚€ â‰¡âŸ¨ ap (Î» - â†’ - â» âˆ· vâ‚€) ((equal-heads (equal-tails p))â»Â¹) âŸ©
         xâ‚€ â» âˆ· vâ‚€    â‰¡âŸ¨ equal-tails (equal-tails p) âŸ©
         vâ‚           âˆ

   f (yâ‚€ âˆ· zâ‚€ âˆ· uâ‚€) [] p = inr Î³
    where
     have : yâ‚€ âˆ· zâ‚€   âˆ· uâ‚€ ++ [ xâ‚€ ] ++ [ xâ‚€ â» ] ++ vâ‚€
          â‰¡ xâ‚ âˆ· xâ‚ â» âˆ· vâ‚
     have = p

     q = yâ‚€ â» â‰¡âŸ¨ ap (_â») (equal-heads p) âŸ©
         xâ‚ â» â‰¡âŸ¨ (equal-heads (equal-tails p))â»Â¹ âŸ©
         zâ‚€   âˆ

     d' : yâ‚€ âˆ· yâ‚€ â» âˆ· uâ‚€ ++ vâ‚€ â–· uâ‚€ ++ vâ‚€
     d' = [] , (uâ‚€ ++ vâ‚€) , yâ‚€ , refl , refl

     d : yâ‚€ âˆ· zâ‚€ âˆ· uâ‚€ ++ vâ‚€ â–· uâ‚€ ++ vâ‚€
     d = transport (Î» - â†’ yâ‚€ âˆ· - âˆ· uâ‚€ ++ vâ‚€ â–· uâ‚€ ++ vâ‚€) q d'

     e' : uâ‚€ ++ [ xâ‚€ ] ++ [ xâ‚€ â» ] ++ vâ‚€ â–· uâ‚€ ++ vâ‚€
     e' = uâ‚€ , vâ‚€ , xâ‚€ , refl , refl

     e : vâ‚ â–· uâ‚€ ++ vâ‚€
     e = transport (_â–· uâ‚€ ++ vâ‚€) (equal-tails (equal-tails p)) e'

     Î³ : Î£ t ê‰ FA , (yâ‚€ âˆ· zâ‚€ âˆ· uâ‚€ ++ vâ‚€ â–· t) Ã— (vâ‚ â–· t)
     Î³ = (uâ‚€ ++ vâ‚€) , d , e

   f (yâ‚€ âˆ· uâ‚€) (yâ‚ âˆ· uâ‚) p = Î³
    where
     have : yâ‚€ âˆ· uâ‚€ ++ [ xâ‚€ ] ++ [ xâ‚€ â» ] ++ vâ‚€
          â‰¡ yâ‚ âˆ· uâ‚ ++ [ xâ‚ ] ++ [ xâ‚ â» ] ++ vâ‚
     have = p

     IH : (uâ‚€ ++ vâ‚€ â‰¡ uâ‚ ++ vâ‚) + (Î£ t ê‰ FA , (uâ‚€ ++ vâ‚€ â–· t) Ã— (uâ‚ ++ vâ‚ â–· t))
     IH = f uâ‚€ uâ‚ (equal-tails p)

     Î“ : X â†’ X â†’ ğ“¤ Ì‡
     Î“ yâ‚€ yâ‚ = (yâ‚€ âˆ· uâ‚€ ++ vâ‚€ â‰¡ yâ‚ âˆ· uâ‚ ++ vâ‚)
             + (Î£ t ê‰ FA , (yâ‚€ âˆ· uâ‚€ ++ vâ‚€ â–· t) Ã— (yâ‚ âˆ· uâ‚ ++ vâ‚ â–· t))

     Î´ : type-of IH â†’ âˆ€ {yâ‚€ yâ‚} â†’ yâ‚€ â‰¡ yâ‚ â†’ Î“ yâ‚€ yâ‚
     Î´ (inl q)           {yâ‚€} refl = inl (ap (yâ‚€ âˆ·_) q)
     Î´ (inr (t , d , e)) {yâ‚€} refl = inr ((yâ‚€ âˆ· t) , âˆ·-â–· yâ‚€ d , âˆ·-â–· yâ‚€ e)

     Î³ : Î“ yâ‚€ yâ‚
     Î³ = Î´ IH (equal-heads p)

 Church-Rosser : (s tâ‚€ tâ‚ : FA)
               â†’ s â–· tâ‚€
               â†’ s â–· tâ‚
               â†’ (tâ‚€ â‰¡ tâ‚) + (Î£ t ê‰ FA , (tâ‚€ â–· t) Ã— (tâ‚ â–· t))
 Church-Rosser s tâ‚€ tâ‚ (uâ‚€ , vâ‚€ , xâ‚€ , pâ‚€ , qâ‚€) (uâ‚ , vâ‚ , xâ‚ , pâ‚ , qâ‚) = Î³ Î´
  where
   Î´ : (uâ‚€ ++ vâ‚€ â‰¡ uâ‚ ++ vâ‚) + (Î£ t ê‰ FA , (uâ‚€ ++ vâ‚€ â–· t) Ã— (uâ‚ ++ vâ‚ â–· t))
   Î´ = churros uâ‚€ vâ‚€ uâ‚ vâ‚ xâ‚€ xâ‚ (pâ‚€ â»Â¹ âˆ™ pâ‚)

   Î³ : type-of Î´ â†’ (tâ‚€ â‰¡ tâ‚) + (Î£ t ê‰ FA , (tâ‚€ â–· t) Ã— (tâ‚ â–· t))
   Î³ (inl q)           = inl (qâ‚€ âˆ™ q âˆ™ qâ‚ â»Â¹)
   Î³ (inr (t , p , q)) = inr (t , transport (_â–· t) (qâ‚€ â»Â¹) p ,
                                  transport (_â–· t) (qâ‚ â»Â¹) q)
\end{code}

It is noteworthy and remarkable that the above doesn't need decidable
equality on A. We repeat that this construction is due to Fred
Richman.

The following import defines

  _â—â–·_       the symmetric closure of _â–·_,
  _âˆ¿_        the symmetric, reflexive, transitive closure of _â–·_,
  _â–·*_       the reflexive, transitive closure of _â–·_,
  _â–·[ n ]_   the n-fold iteration of _â–·_.
  _â—â–·[ n ]_  the n-fold iteration of _â—â–·_.

and its submodule Church-Rosser-consequences develops some useful
consequences of the Church-Rosser property in a general setting.

\begin{code}

 open import SRTclosure
 open Church-Rosser-consequences _â–·_

\end{code}

The insertion of generators is trivially left cancellable before
quotienting:

\begin{code}

 Î·-lc : {a b : A} â†’ Î· a â‰¡ Î· b â†’ a â‰¡ b
 Î·-lc refl = refl

\end{code}

The following less trivial result, which relies on the Church-Rosser
property, will give that the insertion of generators is injective
after quotienting:

\begin{code}

 Î·-irreducible : {a : A} {s : FA} â†’ Â¬ (Î· a â–· s)
 Î·-irreducible ((x âˆ· []) , v , y , () , refl)
 Î·-irreducible ((x âˆ· y âˆ· u) , v , z , () , q)

 Î·-irreducible* : {a : A} {s : FA} â†’ Î· a â–·* s â†’ Î· a â‰¡ s
 Î·-irreducible* {a} {s} (n , r) = f n r
  where
   f : (n : â„•) â†’ Î· a â–·[ n ] s â†’ Î· a â‰¡ s
   f zero     refl = refl
   f (succ n) (t , r , i) = ğŸ˜-elim (Î·-irreducible r)

 Î·-identifies-âˆ¿-related-points : {a b : A} â†’ Î· a âˆ¿ Î· b â†’ a â‰¡ b
 Î·-identifies-âˆ¿-related-points {a} {b} e = Î·-lc p
  where
   Ïƒ : Î£ s ê‰ FA , (Î· a â–·* s) Ã— (Î· b â–·* s)
   Ïƒ = from-âˆ¿ Church-Rosser (Î· a) (Î· b) e
   s = prâ‚ Ïƒ

   p = Î· a â‰¡âŸ¨  Î·-irreducible* (prâ‚ (prâ‚‚ Ïƒ)) âŸ©
       s   â‰¡âŸ¨ (Î·-irreducible* (prâ‚‚ (prâ‚‚ Ïƒ)))â»Â¹ âŸ©
       Î· b âˆ

\end{code}

We need to work with the propositional truncation of _âˆ¿_ to construct
the free group, but most of the work will be done before truncation.

The following is for reasoning with chains of equivalences _âˆ¿_:

\begin{code}

 _âˆ¿âŸ¨_âŸ©_ : (s : FA) {t u : FA} â†’ s âˆ¿ t â†’ t âˆ¿ u â†’ s âˆ¿ u
 _ âˆ¿âŸ¨ p âŸ© q = srt-transitive _â–·_ _ _ _ p q

 _âˆ¿âˆ : (s : FA) â†’ s âˆ¿ s
 _âˆ¿âˆ _ = srt-reflexive _â–·_ _

 infixr 0 _âˆ¿âŸ¨_âŸ©_
 infix  1 _âˆ¿âˆ

 â‰¡-gives-âˆ¿ : {s s' : FA} â†’ s â‰¡ s' â†’ s âˆ¿ s'
 â‰¡-gives-âˆ¿ {s} refl = srt-reflexive _â–·_ s

\end{code}

As discussed above, the group operation before quotienting is simply
concatenation, with the empty list as the neutral element.

Concatenation is a left congruence. We establish this in several
steps:

\begin{code}

 ++-â–·-left : (s s' t : FA) â†’ s â–· s' â†’ s ++ t â–· s' ++ t
 ++-â–·-left s s' t (u , v , x , p , q) = u , (v ++ t) , x , p' , q'
  where
   p' = s ++ t                            â‰¡âŸ¨ ap (_++ t) p âŸ©
        (u ++ [ x ] ++ [ x â» ] ++ v) ++ t â‰¡âŸ¨ ++-assoc u ([ x ] ++ [ x â» ] ++ v) t âŸ©
        u ++ [ x ] ++ [ x â» ] ++ v ++ t   âˆ

   q' = s' ++ t       â‰¡âŸ¨ ap (_++ t) q âŸ©
        (u ++ v) ++ t â‰¡âŸ¨ ++-assoc u v t âŸ©
        u ++ v ++ t   âˆ

 ++-â—â–·-left : (s s' t : FA) â†’ s â—â–· s' â†’ s ++ t â—â–· s' ++ t
 ++-â—â–·-left s s' t (inl a) = inl (++-â–·-left s s' t a)
 ++-â—â–·-left s s' t (inr a) = inr (++-â–·-left s' s t a)

 ++-iteration-left : (s s' t : FA) (n : â„•)
                   â†’ s â—â–·[ n ] s'
                   â†’ s ++ t â—â–·[ n ] s' ++ t
 ++-iteration-left s s  t zero     refl        = refl
 ++-iteration-left s s' t (succ n) (u , b , c) = (u ++ t) ,
                                                 ++-â—â–·-left s u t b ,
                                                 ++-iteration-left u s' t n c

 ++-cong-left : (s s' t : FA) â†’ s âˆ¿ s' â†’ s ++ t âˆ¿ s' ++ t
 ++-cong-left s s' t (n , a) = n , ++-iteration-left s s' t n a

\end{code}

It is also a right congruence:

\begin{code}

 âˆ·-â—â–· : (x : X) {s t : FA} â†’ s â—â–· t â†’ x âˆ· s â—â–· x âˆ· t
 âˆ·-â—â–· x (inl e) = inl (âˆ·-â–· x e)
 âˆ·-â—â–· x (inr e) = inr (âˆ·-â–· x e)

 âˆ·-iteration : (x : X) {s t : FA} (n : â„•)
             â†’ s â—â–·[ n ] t
             â†’ x âˆ· s â—â–·[ n ] x âˆ· t
 âˆ·-iteration x zero refl = refl
 âˆ·-iteration x (succ n) (u , b , c) = (x âˆ· u) , âˆ·-â—â–· x b , âˆ·-iteration x n c

 âˆ·-cong : (x : X) {s t : FA} â†’ s âˆ¿ t â†’ x âˆ· s âˆ¿ x âˆ· t
 âˆ·-cong x (n , a) = n , âˆ·-iteration x n a

 ++-cong-right : (s {t t'} : FA) â†’ t âˆ¿ t' â†’ s ++ t âˆ¿ s ++ t'
 ++-cong-right []      e = e
 ++-cong-right (x âˆ· s) e = âˆ·-cong x (++-cong-right s e)

\end{code}

And therefore it is a two-sided congruence:

\begin{code}

 ++-cong-âˆ¿ : {s s' t t' : FA} â†’ s âˆ¿ s' â†’ t âˆ¿ t' â†’ s ++ t âˆ¿ s' ++ t'
 ++-cong-âˆ¿ {s} {s'} {t} {t'} d e = s ++ t   âˆ¿âŸ¨ ++-cong-left s s' t d âŸ©
                                   s' ++ t  âˆ¿âŸ¨ ++-cong-right s' e âŸ©
                                   s' ++ t' âˆ¿âˆ
\end{code}

We now construct the group inverse before quotienting. We reverse the
given list and formally invert all its elements:

\begin{code}

 inv : FA â†’ FA
 inv [] = []
 inv (x âˆ· s) = inv s ++ [ x â» ]

\end{code}

It is a congruence, which is proved in several steps:

\begin{code}

 inv-++ : (s t : FA) â†’ inv (s ++ t) â‰¡ inv t ++ inv s
 inv-++ []      t = []-right-neutral (inv t)
 inv-++ (x âˆ· s) t = inv (s ++ t) ++ [ x â» ]     â‰¡âŸ¨ IH âŸ©
                    (inv t ++ inv s) ++ [ x â» ] â‰¡âŸ¨ assoc âŸ©
                    inv t ++ (inv s ++ [ x â» ]) âˆ
  where
   IH    = ap (_++ [ x â» ]) (inv-++ s t)
   assoc = ++-assoc (inv t) (inv s) [ x â» ]

 inv-â–· : {s t : FA} â†’ s â–· t â†’ inv s â–· inv t
 inv-â–· {s} {t} (u , v , y , p , q) = inv v , inv u , y , p' , q'
  where
   p' = inv s                                     â‰¡âŸ¨ I âŸ©
        inv (u ++ [ y ] ++ [ y â» ] ++ v)          â‰¡âŸ¨ II âŸ©
        inv ([ y ] ++ [ y â» ] ++ v) ++ inv u      â‰¡âŸ¨ III âŸ©
        inv (([ y ] ++ [ y â» ]) ++ v) ++ inv u    â‰¡âŸ¨ IV âŸ©
        (inv v ++ [ (y â»)â» ] ++ [ y â» ]) ++ inv u â‰¡âŸ¨ V âŸ©
        (inv v ++ [ y ] ++ [ y â» ]) ++ inv u      â‰¡âŸ¨ VI âŸ©
        inv v ++ [ y ] ++ [ y â» ] ++ inv u        âˆ
    where
     I   = ap inv p
     II  = inv-++ u ([ y ] ++ [ y â» ] ++ v)
     III = ap (Î» - â†’ inv - ++ inv u) ((++-assoc [ y ] [ y â» ] v)â»Â¹)
     IV  = ap (_++ inv u) (inv-++ ([ y ] ++ [ y â» ]) v)
     V   = ap (Î» - â†’ (inv v ++ [ - ] ++ [ y â» ]) ++ inv u) (inv-invol y)
     VI  = ++-assoc (inv v) ([ y ] ++ [ y â» ]) (inv u)

   q' = inv t          â‰¡âŸ¨ ap inv q âŸ©
        inv (u ++ v)   â‰¡âŸ¨ inv-++ u v âŸ©
        inv v ++ inv u âˆ

 inv-â—â–· : {s t : FA} â†’ s â—â–· t â†’ inv s â—â–· inv t
 inv-â—â–· (inl e) = inl (inv-â–· e)
 inv-â—â–· (inr e) = inr (inv-â–· e)

 inv-iteration : {s t : FA} (n : â„•)
               â†’ s â—â–·[ n ] t
               â†’ inv s â—â–·[ n ] inv t
 inv-iteration zero refl = refl
 inv-iteration (succ n) (u , b , c) = inv u , inv-â—â–· b , inv-iteration n c

 inv-cong-âˆ¿ : {s t : FA} â†’ s âˆ¿ t â†’ inv s âˆ¿ inv t
 inv-cong-âˆ¿ (n , a) = n , inv-iteration n a

\end{code}

The inverse really is an inverse:

\begin{code}

 inv-lemma-right : (x : X) â†’ [ x ] ++ [ x â» ] âˆ¿ []
 inv-lemma-right x = srt-extension _â–·_ _ [] ([] , [] , x , refl , refl)

 inv-lemma-left : (x : X) â†’ [ x â» ] ++ [ x ] âˆ¿ []
 inv-lemma-left x = srt-extension _â–·_ _ _
                 ([] ,
                  [] ,
                  (x â») ,
                  ap (Î» - â†’ [ x â» ] ++ [ - ]) ((inv-invol x)â»Â¹) , refl)

 inv-right-âˆ¿ : (s : FA) â†’ s ++ inv s âˆ¿ []
 inv-right-âˆ¿ []      = srt-reflexive _â–·_ []
 inv-right-âˆ¿ (x âˆ· s) = Î³
  where
   IH : s ++ inv s âˆ¿ []
   IH = inv-right-âˆ¿ s

   Î³ = [ x ] ++ s ++ inv s ++ [ x â» ]   âˆ¿âŸ¨ I âŸ©
       [ x ] ++ (s ++ inv s) ++ [ x â» ] âˆ¿âŸ¨ II âŸ©
       [ x ] ++ [ x â» ]                 âˆ¿âŸ¨ III âŸ©
       []                               âˆ¿âˆ
    where
     I   = â‰¡-gives-âˆ¿  (ap (x âˆ·_) (++-assoc s (inv s) [ x â» ])â»Â¹)
     II  = ++-cong-right [ x ] (++-cong-left _ _ _ IH)
     III = inv-lemma-right x

 inv-left-âˆ¿ : (s : FA) â†’ inv s ++ s âˆ¿ []
 inv-left-âˆ¿ []      = srt-reflexive _â–·_ []
 inv-left-âˆ¿ (x âˆ· s) = Î³
  where
   Î³ = (inv s ++ [ x â» ]) ++ (x âˆ· s)    âˆ¿âŸ¨ I âŸ©
       inv s ++ ([ x â» ] ++ [ x ] ++ s) âˆ¿âŸ¨ II âŸ©
       inv s ++ ([ x â» ] ++ [ x ]) ++ s âˆ¿âŸ¨ III âŸ©
       inv s ++ s                       âˆ¿âŸ¨ IV âŸ©
       []                               âˆ¿âˆ
    where
     I   = â‰¡-gives-âˆ¿ (++-assoc (inv s) [ x â» ] (x âˆ· s))
     II  = â‰¡-gives-âˆ¿ (ap (inv s ++_) ((++-assoc [ x â» ] [ x ] s)â»Â¹))
     III = ++-cong-right (inv s) (++-cong-left _ _ _ (inv-lemma-left x))
     IV  = inv-left-âˆ¿ s

\end{code}

The propositional, symmetric, reflexive, transitive closure of _â–·_:

\begin{code}

 module _ (pt : propositional-truncations-exist) where

  open PropositionalTruncation pt

  _âˆ¾_ : FA â†’ FA â†’ ğ“¤ Ì‡
  x âˆ¾ y = âˆ¥ x âˆ¿ y âˆ¥

  infix 1 _âˆ¾_

  Î·-identifies-âˆ¾-related-points : {a b : A} â†’ is-set A â†’ Î· a âˆ¾ Î· b â†’ a â‰¡ b
  Î·-identifies-âˆ¾-related-points i = âˆ¥âˆ¥-rec i Î·-identifies-âˆ¿-related-points

  ++-cong : {s s' t t' : FA} â†’ s âˆ¾ s' â†’ t âˆ¾ t' â†’ s ++ t âˆ¾ s' ++ t'
  ++-cong = âˆ¥âˆ¥-functorâ‚‚ ++-cong-âˆ¿

  inv-cong : {s t : FA} â†’ s âˆ¾ t â†’ inv s âˆ¾ inv t
  inv-cong = âˆ¥âˆ¥-functor inv-cong-âˆ¿

  inv-right : (s : FA) â†’ s ++ inv s âˆ¾ []
  inv-right s = âˆ£ inv-right-âˆ¿ s âˆ£

  inv-left : (s : FA) â†’ inv s ++ s âˆ¾ []
  inv-left s = âˆ£ inv-left-âˆ¿ s âˆ£

\end{code}

To perform the quotient, we assume functional and propositional
extensionality.

\begin{code}

  module _ (fe' : FunExt)
           (pe  : propext ğ“¤)
        where

   fe : Fun-Ext
   fe {ğ“¤} {ğ“¥} = fe' ğ“¤ ğ“¥

\end{code}

We work with quotients constructed in the module UF-Quotient using
functional extensionality and propositional extensionality, and no
higher-inductive types other than propositional truncation:

\begin{code}

   open import UF-Quotient
   open Quotient ğ“¤ ğ“¤ pt fe' pe
   open psrt pt _â–·_

\end{code}

We have that _âˆ¾_ is an equivalence relation:

\begin{code}

   -âˆ¾- : EqRel FA
   -âˆ¾- = _âˆ¾_ , psrt-is-prop-valued , psrt-reflexive , psrt-symmetric , psrt-transitive

\end{code}

The acronym "psrt" stands for propositional, reflexive, symmetric and
transitive closure of a relation, in this case _â–·_.

Our quotients constructed via propositional truncation increase
universe levels (this won't be a problem for our intended application,
the free group over the type of ordinals, because although this type
is large, it is locally small):

\begin{code}

   FA/âˆ¾ : ğ“¤ âº Ì‡
   FA/âˆ¾ = FA / -âˆ¾-

   Î·/âˆ¾ : FA â†’ FA/âˆ¾
   Î·/âˆ¾ = Î·/ -âˆ¾-

\end{code}

The above function Î·/âˆ¾ is the universal map into the quotient.

We have too many Î·'s now. The insertion of generators of the free
group is obtained by composing the universal map into the quotient
with our original map Î· : A â†’ FA that inserts the generators into the
freely generated "pre-group" of lists. Because the insertion of
generators into the "real group" is the composition of these two Î·'s,
we use a double Î· to denote it.

\begin{code}

   Î·Î· : A â†’ FA/âˆ¾
   Î·Î· a = Î·/âˆ¾ (Î· a)

\end{code}

It is noteworthy, and what we wanted to know, constructively, that the
inclusion of generators in the free group is an injection, or a
left-cancellable map:

\begin{code}

   Î·Î·-lc : is-set A â†’ (a b : A) â†’ Î·Î· a â‰¡ Î·Î· b â†’ a â‰¡ b
   Î·Î·-lc i a b p = Î·-identifies-âˆ¾-related-points i
                     (Î·/-relates-identified-points -âˆ¾- p)

   Î·/âˆ¾-identifies-related-points : {s t : FA} â†’ s âˆ¾ t â†’ Î·/âˆ¾ s â‰¡ Î·/âˆ¾ t
   Î·/âˆ¾-identifies-related-points = Î·/-identifies-related-points -âˆ¾-

\end{code}

We now need to make FA/âˆ¾ into a group. We will use "/" in names to
indicate constructions on the quotient type FA/âˆ¾.

\begin{code}

   e/ : FA/âˆ¾
   e/ = Î·/âˆ¾ []

   inv/ : FA/âˆ¾ â†’ FA/âˆ¾
   inv/ = extensionâ‚/ -âˆ¾- inv inv-cong

   _Â·_ : FA/âˆ¾ â†’ FA/âˆ¾ â†’ FA/âˆ¾
   _Â·_ = extensionâ‚‚/ -âˆ¾- _++_ ++-cong

\end{code}

The following two naturality conditions (in the categorical sense) are
crucial:

\begin{code}

   inv/-natural : (s : FA) â†’ inv/ (Î·/âˆ¾ s) â‰¡ Î·/âˆ¾ (inv s)
   inv/-natural = naturality/ -âˆ¾- inv inv-cong

   Â·-natural : (s t : FA) â†’ Î·/âˆ¾ s Â· Î·/âˆ¾ t â‰¡ Î·/âˆ¾ (s ++ t)
   Â·-natural = naturalityâ‚‚/ -âˆ¾- _++_ ++-cong

\end{code}

Next, to prove the groups laws, we use quotient induction "/-induction".

One can think of elements of FA/âˆ¾ as equivalence classes, and of Î·/âˆ¾ s
as the equivalence class of s. Then quotient induction says that in
order to prove a property of equivalence classes, it is enough to
prove it for all equivalence classes of given elements (this is proved
in the module UF-Quotient).

The following proofs rely on the above naturality conditions:

\begin{code}

   ln/ : left-neutral e/ _Â·_
   ln/ = /-induction -âˆ¾- (Î» x â†’ e/ Â· x â‰¡ x) (Î» x â†’ quotient-is-set -âˆ¾-) Î³
    where
     Î³ : (s : FA) â†’ Î·/âˆ¾ [] Â· Î·/âˆ¾ s â‰¡ Î·/âˆ¾ s
     Î³ = Â·-natural []

   rn/ : right-neutral e/ _Â·_
   rn/ = /-induction -âˆ¾- (Î» x â†’ x Â· e/ â‰¡ x) (Î» x â†’ quotient-is-set -âˆ¾-) Î³
    where
     Î³ : (s : FA) â†’ Î·/âˆ¾ s Â· Î·/âˆ¾ [] â‰¡ Î·/âˆ¾ s
     Î³ s = Î·/âˆ¾ s Â· Î·/âˆ¾ [] â‰¡âŸ¨ Â·-natural s [] âŸ©
           Î·/âˆ¾ (s ++ [])  â‰¡âŸ¨ ap Î·/âˆ¾ ([]-right-neutral s â»Â¹) âŸ©
           Î·/âˆ¾ s          âˆ

   invl/ : (x : FA/âˆ¾) â†’ inv/ x Â· x â‰¡ e/
   invl/ = /-induction -âˆ¾- (Î» x â†’ (inv/ x Â· x) â‰¡ e/) (Î» x â†’ quotient-is-set -âˆ¾-) Î³
    where
     Î³ : (s : FA) â†’ inv/ (Î·/âˆ¾ s) Â· Î·/âˆ¾ s â‰¡ e/
     Î³ s = inv/ (Î·/âˆ¾ s) Â· Î·/âˆ¾ s â‰¡âŸ¨ ap (_Â· Î·/âˆ¾ s) (inv/-natural s) âŸ©
           Î·/âˆ¾ (inv s) Â· Î·/âˆ¾ s  â‰¡âŸ¨ Â·-natural (inv s) s âŸ©
           Î·/âˆ¾ (inv s ++ s)     â‰¡âŸ¨ Î·/âˆ¾-identifies-related-points (inv-left s) âŸ©
           Î·/âˆ¾ []               â‰¡âŸ¨ refl âŸ©
           e/                   âˆ

   invr/ : (x : FA/âˆ¾) â†’ x Â· inv/ x â‰¡ e/
   invr/ = /-induction -âˆ¾- (Î» x â†’ x Â· inv/ x â‰¡ e/) (Î» x â†’ quotient-is-set -âˆ¾-) Î³
    where
     Î³ : (s : FA) â†’ Î·/âˆ¾ s Â· inv/ (Î·/âˆ¾ s) â‰¡ e/
     Î³ s = Î·/âˆ¾ s Â· inv/ (Î·/âˆ¾ s) â‰¡âŸ¨ ap (Î·/âˆ¾ s Â·_) (inv/-natural s) âŸ©
           Î·/âˆ¾ s Â· Î·/âˆ¾ (inv s)  â‰¡âŸ¨ Â·-natural s (inv s) âŸ©
           Î·/âˆ¾ (s ++ inv s)     â‰¡âŸ¨ Î·/âˆ¾-identifies-related-points (inv-right s) âŸ©
           Î·/âˆ¾ []               â‰¡âŸ¨ refl âŸ©
           e/                   âˆ

   assoc/ : associative _Â·_
   assoc/ = /-induction -âˆ¾- (Î» x â†’ âˆ€ y z â†’ (x Â· y) Â· z â‰¡ x Â· (y Â· z))
              (Î» x â†’ Î â‚‚-is-prop fe (Î» y z â†’ quotient-is-set -âˆ¾-))
              (Î» s â†’ /-induction -âˆ¾- (Î» y â†’ âˆ€ z â†’ (Î·/âˆ¾ s Â· y) Â· z â‰¡ Î·/âˆ¾ s Â· (y Â· z))
                       (Î» y â†’ Î -is-prop fe (Î» z â†’ quotient-is-set -âˆ¾-))
                       (Î» t â†’ /-induction -âˆ¾- (Î» z â†’ (Î·/âˆ¾ s Â· Î·/âˆ¾ t) Â· z â‰¡ Î·/âˆ¾ s Â· (Î·/âˆ¾ t Â· z))
                                (Î» z â†’ quotient-is-set -âˆ¾-)
                                (Î³ s t)))
    where
     Î³ : (s t u : FA) â†’ (Î·/âˆ¾ s Â· Î·/âˆ¾ t) Â· Î·/âˆ¾ u â‰¡ Î·/âˆ¾ s Â· (Î·/âˆ¾ t Â· Î·/âˆ¾ u)
     Î³ s t u = (Î·/âˆ¾ s Â· Î·/âˆ¾ t) Â· Î·/âˆ¾ u â‰¡âŸ¨ ap (_Â· Î·/âˆ¾ u) (Â·-natural s t) âŸ©
               Î·/âˆ¾ (s ++ t) Â· Î·/âˆ¾ u    â‰¡âŸ¨ Â·-natural (s ++ t) u âŸ©
               Î·/âˆ¾ ((s ++ t) ++ u)     â‰¡âŸ¨ ap Î·/âˆ¾ (++-assoc s t u) âŸ©
               Î·/âˆ¾ (s ++ (t ++ u))     â‰¡âŸ¨ (Â·-natural s (t ++ u))â»Â¹ âŸ©
               Î·/âˆ¾ s Â· Î·/âˆ¾ (t ++ u)    â‰¡âŸ¨ ap (Î·/âˆ¾ s Â·_) ((Â·-natural t u)â»Â¹) âŸ©
               Î·/âˆ¾ s Â· (Î·/âˆ¾ t Â· Î·/âˆ¾ u) âˆ
\end{code}

So we have constructed a group with underlying set FA/âˆ¾ and a map
Î·Î· : A â†’ FA/âˆ¾.

To prove that Î·Î· is the universal map of the set A into a group, we
assume another group G with a map f : A â†’ G:

\begin{code}

   module _ {ğ“¥ : Universe}
            (G : ğ“¥ Ì‡ )
            (G-is-set : is-set G)
            (e : G)
            (invg : G â†’ G)
            (_â‹†_ : G â†’ G â†’ G)
            (ln : left-neutral e _â‹†_)
            (rn : right-neutral e _â‹†_)
            (invl : (g : G) â†’ invg g â‹† g â‰¡ e)
            (invr : (g : G) â†’ g â‹† invg g â‰¡ e)
            (assoc : associative _â‹†_)
            (f : A â†’ G)
         where

\end{code}

Our objective is to constructe f' from f making the universality
triangle commute. As a first step in the construction of f', we
construct a map h by induction of lists:

\begin{code}

    h : FA â†’ G
    h [] = e
    h ((â‚€ , a) âˆ· s) = f a â‹† h s
    h ((â‚ , a) âˆ· s) = invg (f a) â‹† h s

\end{code}

We need the following property of h with respect to formal inverses:

\begin{code}

    hâ» : (x : X) â†’ h ([ x ] ++ [ x â» ]) â‰¡ e

    hâ» (â‚€ , a) = f a â‹† (invg (f a) â‹† e)â‰¡âŸ¨ ap (f a â‹†_) (rn (invg (f a))) âŸ©
                 f a â‹† invg (f a)      â‰¡âŸ¨ invr (f a) âŸ©
                 e                     âˆ

    hâ» (â‚ , a) = invg (f a) â‹† (f a â‹† e)â‰¡âŸ¨ ap (invg (f a) â‹†_) (rn (f a)) âŸ©
                 invg (f a) â‹† f a      â‰¡âŸ¨ invl (f a) âŸ©
                 e                     âˆ
\end{code}

By construction, the function h is a list homomorphism. It is also a
monoid homomorphism (it would be a group homomorphism if FA were a
group, which it isn't):

\begin{code}

    h-is-hom : (s t : FA) â†’ h (s ++ t) â‰¡ h s â‹† h t

    h-is-hom [] t = h  t    â‰¡âŸ¨ (ln (h t))â»Â¹ âŸ©
                    e â‹† h t âˆ

    h-is-hom ((â‚€ , a) âˆ· s) t = f a â‹† h (s ++ t)    â‰¡âŸ¨ ap (f a â‹†_) (h-is-hom s t) âŸ©
                               f a â‹† (h s â‹† h t)   â‰¡âŸ¨ (assoc (f a) (h s) (h t))â»Â¹ âŸ©
                               (f a â‹† h s) â‹† h t   â‰¡âŸ¨ refl âŸ©
                               h (â‚€ , a âˆ· s) â‹† h t âˆ

    h-is-hom (â‚ , a âˆ· s) t = invg (f a) â‹† h (s ++ t)  â‰¡âŸ¨ ap (invg (f a) â‹†_) (h-is-hom s t) âŸ©
                             invg (f a) â‹† (h s â‹† h t) â‰¡âŸ¨ (assoc (invg (f a)) (h s) (h t))â»Â¹ âŸ©
                             (invg (f a) â‹† h s) â‹† h t â‰¡âŸ¨ refl âŸ©
                             h (â‚ , a âˆ· s) â‹† h t      âˆ

\end{code}

We also need the following property of the map h in order to construct
our desired group homomorphism f':

\begin{code}

    h-identifies-â–·-related-points : {s t : FA} â†’ s â–· t â†’ h s â‰¡ h t
    h-identifies-â–·-related-points {s} {t} (u , v , y , p , q) =
       h s â‰¡âŸ¨ ap h p âŸ©
       h (u ++ [ y ] ++ [ y â» ] ++ v)   â‰¡âŸ¨ h-is-hom u ([ y ] ++ [ y â» ] ++ v) âŸ©
       h u â‹† h (y âˆ· y â» âˆ· v)            â‰¡âŸ¨ ap (h u â‹†_) (h-is-hom (y âˆ· y â» âˆ· []) v) âŸ©
       h u â‹† (h (y âˆ· (y â») âˆ· []) â‹† h v) â‰¡âŸ¨ ap (Î» - â†’ h u â‹† (- â‹† h v)) (hâ» y) âŸ©
       h u â‹† (e â‹† h v)                  â‰¡âŸ¨ ap (h u â‹†_) (ln (h v)) âŸ©
       h u â‹† h v                        â‰¡âŸ¨ (h-is-hom u v)â»Â¹ âŸ©
       h (u ++ v)                       â‰¡âŸ¨ ap h (q â»Â¹) âŸ©
       h t âˆ

    h-identifies-â–·*-related-points : {s t : FA} â†’ s â–·* t â†’ h s â‰¡ h t
    h-identifies-â–·*-related-points {s} {t} (n , r) = Î³ n s t r
     where
      Î³ : (n : â„•) (s t : FA) â†’ s â–·[ n ] t â†’ h s â‰¡ h t
      Î³ zero s s refl  = refl
      Î³ (succ n) s t (u , r , i) = h s â‰¡âŸ¨ h-identifies-â–·-related-points r âŸ©
                                   h u â‰¡âŸ¨ Î³ n u t i âŸ©
                                   h t âˆ

    h-identifies-âˆ¾-related-points : {s t : FA} â†’ s âˆ¾ t â†’ h s â‰¡ h t
    h-identifies-âˆ¾-related-points {s} {t} e = Î³
     where
      Î´ : (Î£ u ê‰ FA , (s â–·* u) Ã— (t â–·* u)) â†’ h s â‰¡ h t
      Î´ (u , Ïƒ , Ï„) = h s â‰¡âŸ¨ (h-identifies-â–·*-related-points Ïƒ) âŸ©
                      h u â‰¡âŸ¨ (h-identifies-â–·*-related-points Ï„)â»Â¹ âŸ©
                      h t âˆ
      Î³ : h s â‰¡ h t
      Î³ = âˆ¥âˆ¥-rec G-is-set Î´ (âˆ¥âˆ¥-functor (from-âˆ¿ Church-Rosser s t) e)

\end{code}

We can then finally construct the unique homorphism f' extending f
using the universal property of quotients, using the above map h:

\begin{code}

    f' : FA/âˆ¾ â†’ G
    f' = mediating-map/ -âˆ¾- G-is-set h h-identifies-âˆ¾-related-points

    f'-/triangle : f' âˆ˜ Î·/âˆ¾ âˆ¼ h
    f'-/triangle = universality-triangle/ -âˆ¾- G-is-set h h-identifies-âˆ¾-related-points

\end{code}

And from this we get the triangle for the universal property of the
free group:

\begin{code}

    f'-triangle : f' âˆ˜ Î·Î· âˆ¼ f
    f'-triangle a = f' (Î·/âˆ¾ (Î· a)) â‰¡âŸ¨ f'-/triangle (Î· a) âŸ©
                    h (Î· a)        â‰¡âŸ¨ refl âŸ©
                    f a â‹† e        â‰¡âŸ¨ rn (f a) âŸ©
                    f a            âˆ

\end{code}

Which is a group homormorphism (rather than merely a monoid
homomorphism like h):

\begin{code}

    f'-is-hom : (x y : FA/âˆ¾) â†’ f' (x Â· y) â‰¡ f' x â‹† f' y
    f'-is-hom = /-induction -âˆ¾- (Î» x â†’ âˆ€ y â†’ f' (x Â· y) â‰¡ (f' x â‹† f' y))
                  (Î» x â†’ Î -is-prop fe (Î» y â†’ G-is-set))
                  (Î» s â†’ /-induction -âˆ¾- (Î» y â†’ f' (Î·/âˆ¾ s Â· y) â‰¡ (f' (Î·/âˆ¾ s) â‹† f' y))
                           (Î» a â†’ G-is-set)
                           (Î³ s))
     where
      Î³ : (s t : FA) â†’ f' (Î·/âˆ¾ s Â· Î·/âˆ¾ t) â‰¡ f' (Î·/âˆ¾ s) â‹† f' (Î·/âˆ¾ t)
      Î³ s t = f' (Î·/âˆ¾ s Â· Î·/âˆ¾ t)      â‰¡âŸ¨ ap f' (Â·-natural s t) âŸ©
              f' (Î·/âˆ¾ (s ++ t))       â‰¡âŸ¨ f'-/triangle (s ++ t) âŸ©
              h (s ++ t)              â‰¡âŸ¨ h-is-hom s t âŸ©
              h s â‹† h t               â‰¡âŸ¨ apâ‚‚ _â‹†_ ((f'-/triangle s)â»Â¹) ((f'-/triangle t)â»Â¹) âŸ©
              f' (Î·/âˆ¾ s) â‹† f' (Î·/âˆ¾ t) âˆ

\end{code}

Notice that for the following uniqueness property of f' we don't need
to assume that fâ‚€ and fâ‚ are group homomorphisms:

\begin{code}

    f'-uniqueness-âˆ¾ : (fâ‚€ fâ‚ : FA/âˆ¾ â†’ G) â†’ fâ‚€ âˆ˜ Î·/âˆ¾ âˆ¼ h â†’ fâ‚ âˆ˜ Î·/âˆ¾ âˆ¼ h â†’ fâ‚€ âˆ¼ fâ‚
    f'-uniqueness-âˆ¾ fâ‚€ fâ‚ p q = at-most-one-mediating-map/ -âˆ¾- G-is-set fâ‚€ fâ‚
                                 (Î» s â†’ p s âˆ™ (q s)â»Â¹)

{- Oh. We forgot to prove this, which will require fâ‚€ and fâ‚ to be homomorphisms:
    f'-uniqueness : (fâ‚€ fâ‚ : FA/âˆ¾ â†’ G) â†’ fâ‚€ âˆ˜ Î·Î· âˆ¼ f â†’ fâ‚ âˆ˜ Î·Î· âˆ¼ f â†’ fâ‚€ âˆ¼ fâ‚
    f'-uniqueness fâ‚€ fâ‚ p q = {!!}
-}

\end{code}

What we wanted to know is now proved.

Last thing to do: Package the above into a single theorem, using a
type of groups, asserting the existence of free groups with injective
insertion of generators.

Last remark: the packaging of all the above into a single theorem will
allow us to be confident that we didn't forget to prove anything.
