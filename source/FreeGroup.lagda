Martin Escardo, 04 January 2021.

Ongoing joint work with Marc Bezem, Thierry Coquand, and Peter Dybjer.

We construct free groups in HoTT/UF in Agda without HIT's other than
propositional truncation.

Based on Richman's book on constructive algebra.

For the moment this file is not for public consumption, but it is
publicly visible.

This is part of the Martin Escardo's Agda development TypeTopology,
whose philosophy is to be Spartan. At the moment we are a bit
Athenian, though, although we intend to fix this in the
future.

\begin{code}

{-# OPTIONS --without-K --safe #-} -- --exact-split

\end{code}

NB. This repository is supposed to use --exact-split, but even though everything has been developed using case-split, the --exact-split check fails (in Agda 2.6.1) in the helper function f of the function churros. This seems to be a bug.

\begin{code}

open import UF-PropTrunc
open import UF-Univalence

module FreeGroup
       (pt : propositional-truncations-exist)
       (ua : Univalence)
       where

open import SpartanMLTT
open import Two
open import Two-Properties

open import UF-Base
open import UF-Subsingletons
open import UF-Equiv
open import UF-UA-FunExt
open import UF-FunExt

\end{code}

It is possible to work with lists *defined* from the ingredients of
our Spartan MLTT (see the module Fin.lagda).

\begin{code}

data List {ğ“¤} (X : ğ“¤ Ì‡ ) : ğ“¤ Ì‡  where
 [] : List X
 _âˆ·_ : X â†’ List X â†’ List X

infixr 2 _âˆ·_

equal-heads : {X : ğ“¤ Ì‡ } {x y : X} {s t : List X}
             â†’ x âˆ· s â‰¡ y âˆ· t
             â†’ x â‰¡ y
equal-heads {ğ“¤} {X} {x} {y} {s} {t} = ap f
 where
  f : List X â†’ X
  f []      = x
  f (z âˆ· s) = z

equal-tails : {X : ğ“¤ Ì‡ } {x y : X} {s t : List X}
             â†’ x âˆ· s â‰¡ y âˆ· t
             â†’ s â‰¡ t
equal-tails {ğ“¤} {X} {x} {y} {s} {t} = ap f
 where
  f : List X â†’ List X
  f []      = []
  f (z âˆ· s) = s

[_] : {X : ğ“¤ Ì‡ } â†’ X â†’ List X
[ x ] = x âˆ· []

_++_ : {X : ğ“¤ Ì‡ } â†’ List X â†’ List X â†’ List X
[]      ++ t = t
(x âˆ· s) ++ t = x âˆ· (s ++ t)

infixr 4 _++_

[]-right-neutral : {X : ğ“¤ Ì‡ } (s : List X) â†’ s â‰¡ s ++ []
[]-right-neutral []      = refl
[]-right-neutral (x âˆ· s) = ap (x âˆ·_) ([]-right-neutral s)

++-assoc : {X : ğ“¤ Ì‡ } â†’ associative (_++_ {ğ“¤} {X})
++-assoc []      t u = refl
++-assoc (x âˆ· s) t u = ap (x âˆ·_) (++-assoc s t u)

\end{code}

We now construct the group freely generated by a set A. The set-hood
requirement is needed later only, and so we don't include it as an
assumption in the following anonymous module:

\begin{code}

module _ {ğ“¤ : Universe}
         {A : ğ“¤ Ì‡ }
       where

 X : ğ“¤ Ì‡
 X = ğŸš Ã— A

 _â» : X â†’ X
 (n , a)â» = (complement n , a)

 inv-invol : (x : X) â†’ (x â»)â» â‰¡ x
 inv-invol (n , a) = ap (_, a) (complement-involutive n)

\end{code}

We will quotient the following type FA to get undelying type of the
free group:

\begin{code}

 FA : ğ“¤ Ì‡
 FA = List X

 Î· : A â†’ FA
 Î· a = [ â‚€ , a ]

\end{code}

We will quotient by the equivalence relation generated by the
following reduction relation:

\begin{code}

 _â–·_ : FA â†’ FA â†’ ğ“¤ Ì‡
 s â–· t = Î£ u ê‰ FA , Î£ v ê‰ FA , Î£ x ê‰ X , (s â‰¡ u ++ [ x ] ++ [ x â» ] ++ v)
                                       Ã— (t â‰¡ u ++ v)

 infix 1 _â–·_

 âˆ·-â–· : {s t : FA} (x : X) â†’ s â–· t â†’ x âˆ· s â–· x âˆ· t
 âˆ·-â–· x (u , v , y , p , q) = (x âˆ· u) , v , y , ap (x âˆ·_) p , ap (x âˆ·_) q

\end{code}

The following is a lemma for the Church-Rosser property, proved by
induction on uâ‚€ and uâ‚:

\begin{code}

 churros : (uâ‚€ vâ‚€ uâ‚ vâ‚ : FA) (xâ‚€ xâ‚ : X)

         â†’ uâ‚€ ++  [ xâ‚€ ] ++ [ xâ‚€ â» ] ++ vâ‚€
         â‰¡ uâ‚ ++  [ xâ‚ ] ++ [ xâ‚ â» ] ++ vâ‚

         â†’ (uâ‚€ ++ vâ‚€ â‰¡ uâ‚ ++ vâ‚)
         + (Î£ t ê‰ FA , (uâ‚€ ++ vâ‚€ â–· t) Ã— (uâ‚ ++ vâ‚ â–· t))

 churros uâ‚€ vâ‚€ uâ‚ vâ‚ xâ‚€ xâ‚ = f uâ‚€ uâ‚
  where
   f : (uâ‚€ uâ‚ : FA)
     â†’ uâ‚€ ++  [ xâ‚€ ] ++ [ xâ‚€ â» ] ++ vâ‚€ â‰¡ uâ‚ ++  [ xâ‚ ] ++ [ xâ‚ â» ] ++ vâ‚
     â†’ (uâ‚€ ++ vâ‚€ â‰¡ uâ‚ ++ vâ‚) + (Î£ t ê‰ FA , (uâ‚€ ++ vâ‚€ â–· t) Ã— (uâ‚ ++ vâ‚ â–· t))

   f [] [] p = inl (equal-tails (equal-tails p))
    where
     have : xâ‚€ âˆ· xâ‚€ â»  âˆ· vâ‚€
          â‰¡ xâ‚ âˆ· xâ‚ â»  âˆ· vâ‚
     have = p

   f [] (yâ‚ âˆ· []) p = inl Î³
    where
     have : xâ‚€ âˆ· xâ‚€ â» âˆ· vâ‚€
          â‰¡ yâ‚ âˆ· xâ‚   âˆ· xâ‚ â» âˆ· vâ‚
     have = p

     q = xâ‚ â»     â‰¡âŸ¨ ap _â» ((equal-heads (equal-tails p))â»Â¹) âŸ©
         (xâ‚€ â») â» â‰¡âŸ¨ inv-invol xâ‚€ âŸ©
         xâ‚€       â‰¡âŸ¨ equal-heads p âŸ©
         yâ‚       âˆ

     Î³ : vâ‚€ â‰¡ yâ‚ âˆ· vâ‚
     Î³ = transport (Î» - â†’ vâ‚€ â‰¡ - âˆ· vâ‚) q (equal-tails (equal-tails p))

   f [] (yâ‚ âˆ· zâ‚ âˆ· uâ‚) p = inr ((uâ‚ ++ vâ‚) , d , e)
    where
     have : xâ‚€ âˆ· xâ‚€ â» âˆ· vâ‚€
          â‰¡ yâ‚ âˆ· zâ‚   âˆ· uâ‚ ++ [ xâ‚ ] ++ [ xâ‚ â» ] ++ vâ‚
     have = p

     d' : uâ‚ ++ [ xâ‚ ] ++ [ xâ‚ â» ] ++ vâ‚ â–· uâ‚ ++ vâ‚
     d' = uâ‚ , vâ‚ , xâ‚ , refl , refl

     d : vâ‚€ â–· uâ‚ ++ vâ‚
     d = transport (_â–· uâ‚ ++ vâ‚) ((equal-tails (equal-tails p))â»Â¹) d'

     q = yâ‚ â» â‰¡âŸ¨ (ap (_â») (equal-heads p)â»Â¹) âŸ©
         xâ‚€ â» â‰¡âŸ¨ equal-heads (equal-tails p) âŸ©
         zâ‚   âˆ

     e' : yâ‚ âˆ· yâ‚ â» âˆ· uâ‚ ++ vâ‚ â–· uâ‚ ++ vâ‚
     e' = [] , (uâ‚ ++ vâ‚) , yâ‚ , refl , refl

     e : yâ‚ âˆ· zâ‚ âˆ· uâ‚ ++ vâ‚ â–· uâ‚ ++ vâ‚
     e = transport (Î» - â†’ yâ‚ âˆ· - âˆ· uâ‚ ++ vâ‚ â–· uâ‚ ++ vâ‚) q e'

   f (yâ‚€ âˆ· []) [] p = inl Î³
    where
     have : yâ‚€ âˆ· xâ‚€   âˆ· xâ‚€ â» âˆ· vâ‚€
          â‰¡ xâ‚ âˆ· xâ‚ â» âˆ· vâ‚
     have = p

     Î³ = yâ‚€ âˆ· vâ‚€       â‰¡âŸ¨ ap (_âˆ· vâ‚€) (equal-heads p) âŸ©
         xâ‚ âˆ· vâ‚€       â‰¡âŸ¨ ap (_âˆ· vâ‚€) ((inv-invol xâ‚)â»Â¹) âŸ©
         (xâ‚ â») â» âˆ· vâ‚€ â‰¡âŸ¨ ap (Î» - â†’ - â» âˆ· vâ‚€) ((equal-heads (equal-tails p))â»Â¹) âŸ©
         xâ‚€ â» âˆ· vâ‚€     â‰¡âŸ¨ equal-tails (equal-tails p) âŸ©
         vâ‚            âˆ

   f (yâ‚€ âˆ· zâ‚€ âˆ· uâ‚€) [] p = inr ((uâ‚€ ++ vâ‚€) , d , e)
    where
     have-p : yâ‚€ âˆ· zâ‚€   âˆ· uâ‚€ ++ [ xâ‚€ ] ++ [ xâ‚€ â» ] ++ vâ‚€ â‰¡
              xâ‚ âˆ· xâ‚ â» âˆ· vâ‚
     have-p = p

     q = yâ‚€ â» â‰¡âŸ¨ ap (_â») (equal-heads p) âŸ©
         xâ‚ â» â‰¡âŸ¨ (equal-heads (equal-tails p))â»Â¹ âŸ©
         zâ‚€   âˆ

     d' : yâ‚€ âˆ· yâ‚€ â» âˆ· uâ‚€ ++ vâ‚€ â–· uâ‚€ ++ vâ‚€
     d' = [] , (uâ‚€ ++ vâ‚€) , yâ‚€ , refl , refl

     d : yâ‚€ âˆ· zâ‚€ âˆ· uâ‚€ ++ vâ‚€ â–· uâ‚€ ++ vâ‚€
     d = transport (Î» - â†’ yâ‚€ âˆ· - âˆ· uâ‚€ ++ vâ‚€ â–· uâ‚€ ++ vâ‚€) q d'

     e' : uâ‚€ ++ [ xâ‚€ ] ++ [ xâ‚€ â» ] ++ vâ‚€ â–· uâ‚€ ++ vâ‚€
     e' = uâ‚€ , vâ‚€ , xâ‚€ , refl , refl

     e : vâ‚ â–· uâ‚€ ++ vâ‚€
     e = transport (_â–· uâ‚€ ++ vâ‚€) (equal-tails (equal-tails p)) e'

   f (yâ‚€ âˆ· uâ‚€) (yâ‚ âˆ· uâ‚) p = Î³
    where
     have : yâ‚€ âˆ· uâ‚€ ++ [ xâ‚€ ] ++ [ xâ‚€ â» ] ++ vâ‚€
          â‰¡ yâ‚ âˆ· uâ‚ ++ [ xâ‚ ] ++ [ xâ‚ â» ] ++ vâ‚
     have = p

     IH : (uâ‚€ ++ vâ‚€ â‰¡ uâ‚ ++ vâ‚) + (Î£ t ê‰ FA , (uâ‚€ ++ vâ‚€ â–· t) Ã— (uâ‚ ++ vâ‚ â–· t))
     IH = f uâ‚€ uâ‚ (equal-tails p)

     Î“ : X â†’ X â†’ ğ“¤ Ì‡
     Î“ yâ‚€ yâ‚ = (yâ‚€ âˆ· uâ‚€ ++ vâ‚€ â‰¡ yâ‚ âˆ· uâ‚ ++ vâ‚)
             + (Î£ t ê‰ FA , (yâ‚€ âˆ· uâ‚€ ++ vâ‚€ â–· t) Ã— (yâ‚ âˆ· uâ‚ ++ vâ‚ â–· t))

     Î´ : type-of IH â†’ âˆ€ {yâ‚€ yâ‚} â†’ yâ‚€ â‰¡ yâ‚ â†’ Î“ yâ‚€ yâ‚
     Î´ (inl q)           {yâ‚€} refl = inl (ap (yâ‚€ âˆ·_) q)
     Î´ (inr (t , d , e)) {yâ‚€} refl = inr ((yâ‚€ âˆ· t) , âˆ·-â–· yâ‚€ d , âˆ·-â–· yâ‚€ e)

     Î³ : Î“ yâ‚€ yâ‚
     Î³ = Î´ IH (equal-heads p)

 Church-Rosser : (s tâ‚€ tâ‚ : FA)
               â†’ s â–· tâ‚€
               â†’ s â–· tâ‚
               â†’ (tâ‚€ â‰¡ tâ‚) + (Î£ t ê‰ FA , (tâ‚€ â–· t) Ã— (tâ‚ â–· t))
 Church-Rosser s tâ‚€ tâ‚ (uâ‚€ , vâ‚€ , xâ‚€ , pâ‚€ , qâ‚€) (uâ‚ , vâ‚ , xâ‚ , pâ‚ , qâ‚) = Î³ Î´
  where
   Î´ : (uâ‚€ ++ vâ‚€ â‰¡ uâ‚ ++ vâ‚) + (Î£ t ê‰ FA , (uâ‚€ ++ vâ‚€ â–· t) Ã— (uâ‚ ++ vâ‚ â–· t))
   Î´ = churros uâ‚€ vâ‚€ uâ‚ vâ‚ xâ‚€ xâ‚ (pâ‚€ â»Â¹ âˆ™ pâ‚)

   Î³ : type-of Î´ â†’ (tâ‚€ â‰¡ tâ‚) + (Î£ t ê‰ FA , (tâ‚€ â–· t) Ã— (tâ‚ â–· t))
   Î³ (inl q)           = inl (qâ‚€ âˆ™ q âˆ™ qâ‚ â»Â¹)
   Î³ (inr (t , p , q)) = inr (t , transport (_â–· t) (qâ‚€ â»Â¹) p ,
                                  transport (_â–· t) (qâ‚ â»Â¹) q)

 open import SRTclosure

 _â—â–·_ : FA â†’ FA â†’ ğ“¤ Ì‡
 _â—â–·_ = s-closure _â–·_

 infix 1 _â—â–·_

 open psrt pt

 _âˆ¾_ : FA â†’ FA â†’ ğ“¤ Ì‡
 _âˆ¾_ = srt-closure _â–·_

 _âˆ¾â‚š_ : FA â†’ FA â†’ ğ“¤ Ì‡
 _âˆ¾â‚š_ = psrt-closure _â–·_

 infix 1 _âˆ¾_

 _âˆ¾âŸ¨_âŸ©_ : (s : FA) {t u : FA} â†’ s âˆ¾ t â†’ t âˆ¾ u â†’ s âˆ¾ u
 _ âˆ¾âŸ¨ p âŸ© q = srt-transitive _â–·_ _ _ _ p q

 _âˆ¾âˆ : (s : FA) â†’ s âˆ¾ s
 _âˆ¾âˆ _ = srt-reflexive _â–·_ _

 infix  1 _âˆ¾âˆ
 infixr 0 _âˆ¾âŸ¨_âŸ©_

 ++-â–·-left : (s s' t : FA) â†’ s â–· s' â†’ s ++ t â–· s' ++ t
 ++-â–·-left s s' t (u , v , x , p , q) = u , (v ++ t) , x , p' , q'
  where
   p' = s ++ t                            â‰¡âŸ¨ ap (_++ t) p âŸ©
        (u ++ [ x ] ++ [ x â» ] ++ v) ++ t â‰¡âŸ¨ ++-assoc u ([ x ] ++ [ x â» ] ++ v) t âŸ©
        u ++ [ x ] ++ [ x â» ] ++ v ++ t   âˆ

   q' = s' ++ t       â‰¡âŸ¨ ap (_++ t) q âŸ©
        (u ++ v) ++ t â‰¡âŸ¨ ++-assoc u v t âŸ©
        u ++ v ++ t   âˆ

 ++-â—â–·-left : (s s' t : FA) â†’ s â—â–· s' â†’ s ++ t â—â–· s' ++ t
 ++-â—â–·-left s s' t (inl a) = inl (++-â–·-left s s' t a)
 ++-â—â–·-left s s' t (inr a) = inr (++-â–·-left s' s t a)

 ++-iteration-left : (s s' t : FA) (n : â„•)
                   â†’ iteration _â—â–·_ n s s'
                   â†’ iteration _â—â–·_ n (s ++ t) (s' ++ t)
 ++-iteration-left s s  t zero     refl        = refl
 ++-iteration-left s s' t (succ n) (u , b , c) = (u ++ t) ,
                                                 ++-â—â–·-left s u t b ,
                                                 ++-iteration-left u s' t n c

 ++-cong-left : (s s' t : FA) â†’ s âˆ¾ s' â†’ s ++ t âˆ¾ s' ++ t
 ++-cong-left s s' t (n , a) = n , ++-iteration-left s s' t n a

 âˆ·-â—â–· : (x : X) {s t : FA} â†’ s â—â–· t â†’ x âˆ· s â—â–· x âˆ· t
 âˆ·-â—â–· x (inl e) = inl (âˆ·-â–· x e)
 âˆ·-â—â–· x (inr e) = inr (âˆ·-â–· x e)

 âˆ·-iteration : (x : X) {s t : FA} (n : â„•)
             â†’ iteration _â—â–·_ n s t
             â†’ iteration _â—â–·_ n (x âˆ· s) (x âˆ· t)
 âˆ·-iteration x zero refl = refl
 âˆ·-iteration x (succ n) (u , b , c) = (x âˆ· u) , âˆ·-â—â–· x b , âˆ·-iteration x n c

 âˆ·-cong : (x : X) {s t : FA} â†’ s âˆ¾ t â†’ x âˆ· s âˆ¾ x âˆ· t
 âˆ·-cong x (n , a) = n , âˆ·-iteration x n a

 ++-cong-right : (s {t t'} : FA) â†’ t âˆ¾ t' â†’ s ++ t âˆ¾ s ++ t'
 ++-cong-right []      e = e
 ++-cong-right (x âˆ· s) e = âˆ·-cong x (++-cong-right s e)

 ++-cong : {s s' t t' : FA} â†’ s âˆ¾ s' â†’ t âˆ¾ t' â†’ s ++ t âˆ¾ s' ++ t'
 ++-cong {s} {s'} {t} {t'} d e = s ++ t   âˆ¾âŸ¨ ++-cong-left s s' t d âŸ©
                                 s' ++ t  âˆ¾âŸ¨ ++-cong-right s' e âŸ©
                                 s' ++ t' âˆ¾âˆ
 inv : FA â†’ FA
 inv [] = []
 inv (x âˆ· s) = inv s ++ [ x â» ]

 inv-++ : (s t : FA) â†’ inv (s ++ t) â‰¡ inv t ++ inv s
 inv-++ []      t = []-right-neutral (inv t)
 inv-++ (x âˆ· s) t = inv (s ++ t) ++ [ x â» ]     â‰¡âŸ¨ IH âŸ©
                    (inv t ++ inv s) ++ [ x â» ] â‰¡âŸ¨ assoc âŸ©
                    inv t ++ (inv s ++ [ x â» ]) âˆ
  where
   IH    = ap (_++ [ x â» ]) (inv-++ s t)
   assoc = ++-assoc (inv t) (inv s) [ x â» ]

 inv-â–· : {s t : FA} â†’ s â–· t â†’ inv s â–· inv t
 inv-â–· {s} {t} (u , v , y , p , q) = inv v , inv u , y , p' , q'
  where
   p' = inv s                                     â‰¡âŸ¨ I âŸ©
        inv (u ++ [ y ] ++ [ y â» ] ++ v)          â‰¡âŸ¨ II âŸ©
        inv ([ y ] ++ [ y â» ] ++ v) ++ inv u      â‰¡âŸ¨ III âŸ©
        inv (([ y ] ++ [ y â» ]) ++ v) ++ inv u    â‰¡âŸ¨ IV âŸ©
        (inv v ++ [ (y â»)â» ] ++ [ y â» ]) ++ inv u â‰¡âŸ¨ V âŸ©
        (inv v ++ [ y ] ++ [ y â» ]) ++ inv u      â‰¡âŸ¨ VI âŸ©
        inv v ++ [ y ] ++ [ y â» ] ++ inv u        âˆ
    where
     I   = ap inv p
     II  = inv-++ u ([ y ] ++ [ y â» ] ++ v)
     III = ap (Î» - â†’ inv - ++ inv u) ((++-assoc [ y ] [ y â» ] v)â»Â¹)
     IV  = ap (_++ inv u) (inv-++ ([ y ] ++ [ y â» ]) v)
     V   = ap (Î» - â†’ (inv v ++ [ - ] ++ [ y â» ]) ++ inv u) (inv-invol y)
     VI  = ++-assoc (inv v) ([ y ] ++ [ y â» ]) (inv u)

   q' = inv t          â‰¡âŸ¨ ap inv q âŸ©
        inv (u ++ v)   â‰¡âŸ¨ inv-++ u v âŸ©
        inv v ++ inv u âˆ

 inv-â—â–· : {s t : FA} â†’ s â—â–· t â†’ inv s â—â–· inv t
 inv-â—â–· (inl e) = inl (inv-â–· e)
 inv-â—â–· (inr e) = inr (inv-â–· e)

 inv-iteration : {s t : FA} (n : â„•)
               â†’ iteration _â—â–·_ n s t
               â†’ iteration _â—â–·_ n (inv s) (inv t)
 inv-iteration zero refl = refl
 inv-iteration (succ n) (u , b , c) = inv u , inv-â—â–· b , inv-iteration n c

 inv-cong : {s t : FA} â†’ s âˆ¾ t â†’ inv s âˆ¾ inv t
 inv-cong (n , a) = n , inv-iteration n a

 =-âˆ¾ : {s s' : FA} â†’ s â‰¡ s' â†’ s âˆ¾ s'
 =-âˆ¾ {s} refl = srt-reflexive _â–·_ s

 inv-lemma : (x : X) â†’ [ x ] ++ [ x â» ] âˆ¾ []
 inv-lemma x = srt-extension _â–·_ _ [] ([] , [] , x , refl , refl)

 inv-lemma' : (x : X) â†’ [ x â» ] ++ [ x ] âˆ¾ []
 inv-lemma' x = srt-extension _â–·_ _ _
                 ([] ,
                  [] ,
                  (x â») ,
                  ap (Î» - â†’ [ x â» ] ++ [ - ]) ((inv-invol x)â»Â¹) , refl)

 inv-property : (s : FA) â†’ s ++ inv s âˆ¾ []
 inv-property []      = srt-reflexive _â–·_ []
 inv-property (x âˆ· s) = Î³
  where
   IH : s ++ inv s âˆ¾ []
   IH = inv-property s

   Î³ = [ x ] ++ s ++ inv s ++ [ x â» ]   âˆ¾âŸ¨ I âŸ©
       [ x ] ++ (s ++ inv s) ++ [ x â» ] âˆ¾âŸ¨ II âŸ©
       [ x ] ++ [ x â» ]                 âˆ¾âŸ¨ III âŸ©
       []                               âˆ¾âˆ
    where
     I   = =-âˆ¾  (ap (x âˆ·_) (++-assoc s (inv s) [ x â» ])â»Â¹)
     II  = ++-cong-right [ x ] (++-cong-left _ _ _ IH)
     III = inv-lemma x

 inv-property' : (s : FA) â†’ inv s ++ s âˆ¾ []
 inv-property' []      = srt-reflexive _â–·_ []
 inv-property' (x âˆ· s) = Î³
  where
   Î³ = (inv s ++ [ x â» ]) ++ (x âˆ· s)    âˆ¾âŸ¨ I âŸ©
       inv s ++ ([ x â» ] ++ [ x ] ++ s) âˆ¾âŸ¨ II âŸ©
       inv s ++ ([ x â» ] ++ [ x ]) ++ s âˆ¾âŸ¨ III âŸ©
       inv s ++ s                       âˆ¾âŸ¨ IV âŸ©
       []                               âˆ¾âˆ
    where
     I   = =-âˆ¾ (++-assoc (inv s) [ x â» ] (x âˆ· s))
     II  = =-âˆ¾ (ap (inv s ++_) ((++-assoc [ x â» ] [ x ] s)â»Â¹))
     III = ++-cong-right (inv s) (++-cong-left _ _ _ (inv-lemma' x))
     IV  = inv-property' s

 Î·-injective : (a b : A) â†’ Î· a â‰¡ Î· b â†’ a â‰¡ b
 Î·-injective a b = ap f
  where
   f : FA â†’ A
   f []            = a
   f ((n , c) âˆ· s) = c

\end{code}

Now we should be able to prove this from the Church-Rosser property:

\begin{code}
{-
 Î·-âˆ¾ : (a b : A) â†’ Î· a âˆ¾ Î· b â†’ a â‰¡ b
 Î·-âˆ¾ a b e = ?

 Î·-âˆ¾â‚š : (a b : A) â†’ is-set A â†’ Î· a âˆ¾â‚š Î· b â†’ a â‰¡ b
 Î·-âˆ¾â‚š = by Î·-âˆ¾ because A is a set and hence a â‰¡ b is a
        proposition and because Î· a âˆ¾â‚š Î· b is âˆ¥ Î· a âˆ¾ Î· b âˆ¥
-}
\end{code}

To be continued.

TODO. Quotient FA to get the free group, with a proof that the insertion
of generators is left-cancellable and hence, being a map of sets, an
embedding.
