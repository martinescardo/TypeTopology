Martin Escardo, January - February 2021.

Ongoing joint work with Marc Bezem, Thierry Coquand, and Peter Dybjer.

We construct free groups in HoTT/UF in Agda without HIT's other than
propositional truncation, and no consequence of univalence other than
function extensionality and propositional extensionality.

Based on Richman's book on constructive algebra.

For the moment this file is not for public consumption, but it is
publicly visible.

This is part of the Martin Escardo's Agda development TypeTopology,
whose philosophy is to be Spartan. At the moment we are a bit
Athenian, though, although we intend to fix this in the
future.

\begin{code}

{-# OPTIONS --without-K --safe #-} -- --exact-split

\end{code}

NB. This repository is supposed to use exact-split, but even though
everything has been developed using case-split, the exact-split check
fails (in Agda 2.6.1) in the helper function f of the function
churros. This seems to be a bug.

\begin{code}

module FreeGroup where

open import SpartanMLTT
open import Two
open import Two-Properties

open import UF-PropTrunc
open import UF-Univalence
open import UF-Base
open import UF-Subsingletons
open import UF-Subsingletons-FunExt
open import UF-Equiv
open import UF-UA-FunExt
open import UF-FunExt

\end{code}

It is possible to work with lists *defined* from the ingredients of
our Spartan MLTT (see the module Fin.lagda). For the moment we are
Athenian in this respect:

\begin{code}

data List {ğ“¤} (X : ğ“¤ Ì‡ ) : ğ“¤ Ì‡  where
 [] : List X
 _âˆ·_ : X â†’ List X â†’ List X

infixr 3 _âˆ·_

equal-heads : {X : ğ“¤ Ì‡ } {x y : X} {s t : List X}
            â†’ x âˆ· s â‰¡ y âˆ· t
            â†’ x â‰¡ y
equal-heads refl = refl

equal-tails : {X : ğ“¤ Ì‡ } {x y : X} {s t : List X}
            â†’ x âˆ· s â‰¡ y âˆ· t
            â†’ s â‰¡ t
equal-tails {ğ“¤} {X} refl = refl

[_] : {X : ğ“¤ Ì‡ } â†’ X â†’ List X
[ x ] = x âˆ· []

_++_ : {X : ğ“¤ Ì‡ } â†’ List X â†’ List X â†’ List X
[]      ++ t = t
(x âˆ· s) ++ t = x âˆ· (s ++ t)

infixr 4 _++_

[]-right-neutral : {X : ğ“¤ Ì‡ } (s : List X) â†’ s â‰¡ s ++ []
[]-right-neutral []      = refl
[]-right-neutral (x âˆ· s) = ap (x âˆ·_) ([]-right-neutral s)

++-assoc : {X : ğ“¤ Ì‡ } â†’ associative (_++_ {ğ“¤} {X})
++-assoc []      t u = refl
++-assoc (x âˆ· s) t u = ap (x âˆ·_) (++-assoc s t u)

\end{code}

We now construct the group freely generated by a set A. The set-hood
requirement is needed later only, and so we don't include it as an
assumption in the following anonymous module:

\begin{code}

module _ {ğ“¤ : Universe}
         {A : ğ“¤ Ì‡ }
       where

 X : ğ“¤ Ì‡
 X = ğŸš Ã— A

 _â» : X â†’ X
 (n , a)â» = (complement n , a)

 inv-invol : (x : X) â†’ (x â»)â» â‰¡ x
 inv-invol (n , a) = ap (_, a) (complement-involutive n)

\end{code}

We will quotient the following type FA to get the undelying type of
the free group:

\begin{code}

 FA : ğ“¤ Ì‡
 FA = List X

 Î· : A â†’ FA
 Î· a = [ â‚€ , a ]

\end{code}

We will quotient by the equivalence relation generated by the
following reduction relation:

\begin{code}

 _â–·_ : FA â†’ FA â†’ ğ“¤ Ì‡
 s â–· t = Î£ u ê‰ FA , Î£ v ê‰ FA , Î£ x ê‰ X , (s â‰¡ u ++ [ x ] ++ [ x â» ] ++ v)
                                       Ã— (t â‰¡ u ++ v)

 infix 1 _â–·_

 âˆ·-â–· : {s t : FA} (x : X) â†’ s â–· t â†’ x âˆ· s â–· x âˆ· t
 âˆ·-â–· x (u , v , y , p , q) = (x âˆ· u) , v , y , ap (x âˆ·_) p , ap (x âˆ·_) q

\end{code}

The following is a lemma for the Church-Rosser property, proved by
induction on uâ‚€ and uâ‚:

\begin{code}

 churros : (uâ‚€ vâ‚€ uâ‚ vâ‚ : FA) (xâ‚€ xâ‚ : X)

         â†’ uâ‚€ ++  [ xâ‚€ ] ++ [ xâ‚€ â» ] ++ vâ‚€
         â‰¡ uâ‚ ++  [ xâ‚ ] ++ [ xâ‚ â» ] ++ vâ‚

         â†’ (uâ‚€ ++ vâ‚€ â‰¡ uâ‚ ++ vâ‚)
         + (Î£ t ê‰ FA , (uâ‚€ ++ vâ‚€ â–· t) Ã— (uâ‚ ++ vâ‚ â–· t))

 churros uâ‚€ vâ‚€ uâ‚ vâ‚ xâ‚€ xâ‚ = f uâ‚€ uâ‚
  where
   f : (uâ‚€ uâ‚ : FA)
     â†’ uâ‚€ ++  [ xâ‚€ ] ++ [ xâ‚€ â» ] ++ vâ‚€ â‰¡ uâ‚ ++  [ xâ‚ ] ++ [ xâ‚ â» ] ++ vâ‚
     â†’ (uâ‚€ ++ vâ‚€ â‰¡ uâ‚ ++ vâ‚) + (Î£ t ê‰ FA , (uâ‚€ ++ vâ‚€ â–· t) Ã— (uâ‚ ++ vâ‚ â–· t))

   f [] [] p = inl Î³
    where
     have : xâ‚€ âˆ· xâ‚€ â»  âˆ· vâ‚€
          â‰¡ xâ‚ âˆ· xâ‚ â»  âˆ· vâ‚
     have = p

     Î³ : vâ‚€ â‰¡ vâ‚
     Î³ = equal-tails (equal-tails p)

   f [] (yâ‚ âˆ· []) p = inl Î³
    where
     have : xâ‚€ âˆ· xâ‚€ â» âˆ· vâ‚€
          â‰¡ yâ‚ âˆ· xâ‚   âˆ· xâ‚ â» âˆ· vâ‚
     have = p

     q = xâ‚ â»    â‰¡âŸ¨ ap _â» ((equal-heads (equal-tails p))â»Â¹) âŸ©
         (xâ‚€ â»)â» â‰¡âŸ¨ inv-invol xâ‚€ âŸ©
         xâ‚€      â‰¡âŸ¨ equal-heads p âŸ©
         yâ‚      âˆ

     Î³ : vâ‚€ â‰¡ yâ‚ âˆ· vâ‚
     Î³ = transport (Î» - â†’ vâ‚€ â‰¡ - âˆ· vâ‚) q (equal-tails (equal-tails p))

   f [] (yâ‚ âˆ· zâ‚ âˆ· uâ‚) p = inr Î³
    where
     have : xâ‚€ âˆ· xâ‚€ â» âˆ· vâ‚€
          â‰¡ yâ‚ âˆ· zâ‚   âˆ· uâ‚ ++ [ xâ‚ ] ++ [ xâ‚ â» ] ++ vâ‚
     have = p

     d' : uâ‚ ++ [ xâ‚ ] ++ [ xâ‚ â» ] ++ vâ‚ â–· uâ‚ ++ vâ‚
     d' = uâ‚ , vâ‚ , xâ‚ , refl , refl

     d : vâ‚€ â–· uâ‚ ++ vâ‚
     d = transport (_â–· uâ‚ ++ vâ‚) ((equal-tails (equal-tails p))â»Â¹) d'

     q = yâ‚ â» â‰¡âŸ¨ (ap (_â») (equal-heads p)â»Â¹) âŸ©
         xâ‚€ â» â‰¡âŸ¨ equal-heads (equal-tails p) âŸ©
         zâ‚   âˆ

     e' : yâ‚ âˆ· yâ‚ â» âˆ· uâ‚ ++ vâ‚ â–· uâ‚ ++ vâ‚
     e' = [] , (uâ‚ ++ vâ‚) , yâ‚ , refl , refl

     e : yâ‚ âˆ· zâ‚ âˆ· uâ‚ ++ vâ‚ â–· uâ‚ ++ vâ‚
     e = transport (Î» - â†’ yâ‚ âˆ· - âˆ· uâ‚ ++ vâ‚ â–· uâ‚ ++ vâ‚) q e'

     Î³ : Î£ t ê‰ FA , (vâ‚€ â–· t) Ã— (yâ‚ âˆ· zâ‚ âˆ· uâ‚ ++ vâ‚ â–· t)
     Î³ = (uâ‚ ++ vâ‚) , d , e

   f (yâ‚€ âˆ· []) [] p = inl Î³
    where
     have : yâ‚€ âˆ· xâ‚€   âˆ· xâ‚€ â» âˆ· vâ‚€
          â‰¡ xâ‚ âˆ· xâ‚ â» âˆ· vâ‚
     have = p

     Î³ = yâ‚€ âˆ· vâ‚€      â‰¡âŸ¨ ap (_âˆ· vâ‚€) (equal-heads p) âŸ©
         xâ‚ âˆ· vâ‚€      â‰¡âŸ¨ ap (_âˆ· vâ‚€) ((inv-invol xâ‚)â»Â¹) âŸ©
         (xâ‚ â»)â» âˆ· vâ‚€ â‰¡âŸ¨ ap (Î» - â†’ - â» âˆ· vâ‚€) ((equal-heads (equal-tails p))â»Â¹) âŸ©
         xâ‚€ â» âˆ· vâ‚€    â‰¡âŸ¨ equal-tails (equal-tails p) âŸ©
         vâ‚           âˆ

   f (yâ‚€ âˆ· zâ‚€ âˆ· uâ‚€) [] p = inr Î³
    where
     have : yâ‚€ âˆ· zâ‚€   âˆ· uâ‚€ ++ [ xâ‚€ ] ++ [ xâ‚€ â» ] ++ vâ‚€
          â‰¡ xâ‚ âˆ· xâ‚ â» âˆ· vâ‚
     have = p

     q = yâ‚€ â» â‰¡âŸ¨ ap (_â») (equal-heads p) âŸ©
         xâ‚ â» â‰¡âŸ¨ (equal-heads (equal-tails p))â»Â¹ âŸ©
         zâ‚€   âˆ

     d' : yâ‚€ âˆ· yâ‚€ â» âˆ· uâ‚€ ++ vâ‚€ â–· uâ‚€ ++ vâ‚€
     d' = [] , (uâ‚€ ++ vâ‚€) , yâ‚€ , refl , refl

     d : yâ‚€ âˆ· zâ‚€ âˆ· uâ‚€ ++ vâ‚€ â–· uâ‚€ ++ vâ‚€
     d = transport (Î» - â†’ yâ‚€ âˆ· - âˆ· uâ‚€ ++ vâ‚€ â–· uâ‚€ ++ vâ‚€) q d'

     e' : uâ‚€ ++ [ xâ‚€ ] ++ [ xâ‚€ â» ] ++ vâ‚€ â–· uâ‚€ ++ vâ‚€
     e' = uâ‚€ , vâ‚€ , xâ‚€ , refl , refl

     e : vâ‚ â–· uâ‚€ ++ vâ‚€
     e = transport (_â–· uâ‚€ ++ vâ‚€) (equal-tails (equal-tails p)) e'

     Î³ : Î£ t ê‰ FA , (yâ‚€ âˆ· zâ‚€ âˆ· uâ‚€ ++ vâ‚€ â–· t) Ã— (vâ‚ â–· t)
     Î³ = (uâ‚€ ++ vâ‚€) , d , e

   f (yâ‚€ âˆ· uâ‚€) (yâ‚ âˆ· uâ‚) p = Î³
    where
     have : yâ‚€ âˆ· uâ‚€ ++ [ xâ‚€ ] ++ [ xâ‚€ â» ] ++ vâ‚€
          â‰¡ yâ‚ âˆ· uâ‚ ++ [ xâ‚ ] ++ [ xâ‚ â» ] ++ vâ‚
     have = p

     IH : (uâ‚€ ++ vâ‚€ â‰¡ uâ‚ ++ vâ‚) + (Î£ t ê‰ FA , (uâ‚€ ++ vâ‚€ â–· t) Ã— (uâ‚ ++ vâ‚ â–· t))
     IH = f uâ‚€ uâ‚ (equal-tails p)

     Î“ : X â†’ X â†’ ğ“¤ Ì‡
     Î“ yâ‚€ yâ‚ = (yâ‚€ âˆ· uâ‚€ ++ vâ‚€ â‰¡ yâ‚ âˆ· uâ‚ ++ vâ‚)
             + (Î£ t ê‰ FA , (yâ‚€ âˆ· uâ‚€ ++ vâ‚€ â–· t) Ã— (yâ‚ âˆ· uâ‚ ++ vâ‚ â–· t))

     Î´ : type-of IH â†’ âˆ€ {yâ‚€ yâ‚} â†’ yâ‚€ â‰¡ yâ‚ â†’ Î“ yâ‚€ yâ‚
     Î´ (inl q)           {yâ‚€} refl = inl (ap (yâ‚€ âˆ·_) q)
     Î´ (inr (t , d , e)) {yâ‚€} refl = inr ((yâ‚€ âˆ· t) , âˆ·-â–· yâ‚€ d , âˆ·-â–· yâ‚€ e)

     Î³ : Î“ yâ‚€ yâ‚
     Î³ = Î´ IH (equal-heads p)

 Church-Rosser : (s tâ‚€ tâ‚ : FA)
               â†’ s â–· tâ‚€
               â†’ s â–· tâ‚
               â†’ (tâ‚€ â‰¡ tâ‚) + (Î£ t ê‰ FA , (tâ‚€ â–· t) Ã— (tâ‚ â–· t))
 Church-Rosser s tâ‚€ tâ‚ (uâ‚€ , vâ‚€ , xâ‚€ , pâ‚€ , qâ‚€) (uâ‚ , vâ‚ , xâ‚ , pâ‚ , qâ‚) = Î³ Î´
  where
   Î´ : (uâ‚€ ++ vâ‚€ â‰¡ uâ‚ ++ vâ‚) + (Î£ t ê‰ FA , (uâ‚€ ++ vâ‚€ â–· t) Ã— (uâ‚ ++ vâ‚ â–· t))
   Î´ = churros uâ‚€ vâ‚€ uâ‚ vâ‚ xâ‚€ xâ‚ (pâ‚€ â»Â¹ âˆ™ pâ‚)

   Î³ : type-of Î´ â†’ (tâ‚€ â‰¡ tâ‚) + (Î£ t ê‰ FA , (tâ‚€ â–· t) Ã— (tâ‚ â–· t))
   Î³ (inl q)           = inl (qâ‚€ âˆ™ q âˆ™ qâ‚ â»Â¹)
   Î³ (inr (t , p , q)) = inr (t , transport (_â–· t) (qâ‚€ â»Â¹) p ,
                                  transport (_â–· t) (qâ‚ â»Â¹) q)

\end{code}

The following import defines

  _â—â–·_       the symmetric closure of _â–·_,
  _âˆ¿_        the symmetric, reflexive, transitive closure of _â–·_,
  _â–·*_       the reflexive, transitive closure of _â–·_,
  _â–·[ n ]_   the n-fold iteration of _â–·_.
  _â—â–·[ n ]_  the n-fold iteration of _â—â–·_.

\begin{code}

 open import SRTclosure
 open Church-Rosser _â–·_

\end{code}

The insertion of generators is left cancellable before quotienting:

\begin{code}

 Î·-lc : {a b : A} â†’ Î· a â‰¡ Î· b â†’ a â‰¡ b
 Î·-lc refl = refl

\end{code}

The following will give that the insertion of generators is injective
after quotienting:

\begin{code}

 Î·-irreducible : {a : A} {s : FA} â†’ Â¬ (Î· a â–· s)
 Î·-irreducible ((x âˆ· []) , v , y , () , refl)
 Î·-irreducible ((x âˆ· y âˆ· u) , v , z , () , q)

 Î·-irreducible* : {a : A} {s : FA} â†’ Î· a â–·* s â†’ Î· a â‰¡ s
 Î·-irreducible* {a} {s} (n , r) = f n r
  where
   f : (n : â„•) â†’ Î· a â–·[ n ] s â†’ Î· a â‰¡ s
   f zero     refl = refl
   f (succ n) (t , r , i) = ğŸ˜-elim (Î·-irreducible r)

 Î·-âˆ¿ : {a b : A} â†’ Î· a âˆ¿ Î· b â†’ a â‰¡ b
 Î·-âˆ¿ {a} {b} e = Î·-lc p
  where
   Ïƒ : Î£ s ê‰ FA , (Î· a â–·* s) Ã— (Î· b â–·* s)
   Ïƒ = from-âˆ¿ Church-Rosser (Î· a) (Î· b) e
   s = prâ‚ Ïƒ

   p = Î· a â‰¡âŸ¨  Î·-irreducible* (prâ‚ (prâ‚‚ Ïƒ)) âŸ©
       s   â‰¡âŸ¨ (Î·-irreducible* (prâ‚‚ (prâ‚‚ Ïƒ)))â»Â¹ âŸ©
       Î· b âˆ

\end{code}

We need to work with the truncation of _âˆ¿_ to construct the free
group, but most of the work will be done before truncation.

The following is for reasoning with chains of equivalences _âˆ¿_:

\begin{code}

 _âˆ¿âŸ¨_âŸ©_ : (s : FA) {t u : FA} â†’ s âˆ¿ t â†’ t âˆ¿ u â†’ s âˆ¿ u
 _ âˆ¿âŸ¨ p âŸ© q = srt-transitive _â–·_ _ _ _ p q

 _âˆ¿âˆ : (s : FA) â†’ s âˆ¿ s
 _âˆ¿âˆ _ = srt-reflexive _â–·_ _

 infixr 0 _âˆ¿âŸ¨_âŸ©_
 infix  1 _âˆ¿âˆ

\end{code}

The group operation before quotienting is simply concatenation.

Concatenation is a left congruence:

\begin{code}

 ++-â–·-left : (s s' t : FA) â†’ s â–· s' â†’ s ++ t â–· s' ++ t
 ++-â–·-left s s' t (u , v , x , p , q) = u , (v ++ t) , x , p' , q'
  where
   p' = s ++ t                            â‰¡âŸ¨ ap (_++ t) p âŸ©
        (u ++ [ x ] ++ [ x â» ] ++ v) ++ t â‰¡âŸ¨ ++-assoc u ([ x ] ++ [ x â» ] ++ v) t âŸ©
        u ++ [ x ] ++ [ x â» ] ++ v ++ t   âˆ

   q' = s' ++ t       â‰¡âŸ¨ ap (_++ t) q âŸ©
        (u ++ v) ++ t â‰¡âŸ¨ ++-assoc u v t âŸ©
        u ++ v ++ t   âˆ

 ++-â—â–·-left : (s s' t : FA) â†’ s â—â–· s' â†’ s ++ t â—â–· s' ++ t
 ++-â—â–·-left s s' t (inl a) = inl (++-â–·-left s s' t a)
 ++-â—â–·-left s s' t (inr a) = inr (++-â–·-left s' s t a)

 ++-iteration-left : (s s' t : FA) (n : â„•)
                   â†’ s â—â–·[ n ] s'
                   â†’ s ++ t â—â–·[ n ] s' ++ t
 ++-iteration-left s s  t zero     refl        = refl
 ++-iteration-left s s' t (succ n) (u , b , c) = (u ++ t) ,
                                                 ++-â—â–·-left s u t b ,
                                                 ++-iteration-left u s' t n c

 ++-cong-left : (s s' t : FA) â†’ s âˆ¿ s' â†’ s ++ t âˆ¿ s' ++ t
 ++-cong-left s s' t (n , a) = n , ++-iteration-left s s' t n a

\end{code}

It is also a right congruence:

\begin{code}

 âˆ·-â—â–· : (x : X) {s t : FA} â†’ s â—â–· t â†’ x âˆ· s â—â–· x âˆ· t
 âˆ·-â—â–· x (inl e) = inl (âˆ·-â–· x e)
 âˆ·-â—â–· x (inr e) = inr (âˆ·-â–· x e)

 âˆ·-iteration : (x : X) {s t : FA} (n : â„•)
             â†’ s â—â–·[ n ] t
             â†’ x âˆ· s â—â–·[ n ] x âˆ· t
 âˆ·-iteration x zero refl = refl
 âˆ·-iteration x (succ n) (u , b , c) = (x âˆ· u) , âˆ·-â—â–· x b , âˆ·-iteration x n c

 âˆ·-cong : (x : X) {s t : FA} â†’ s âˆ¿ t â†’ x âˆ· s âˆ¿ x âˆ· t
 âˆ·-cong x (n , a) = n , âˆ·-iteration x n a

 ++-cong-right : (s {t t'} : FA) â†’ t âˆ¿ t' â†’ s ++ t âˆ¿ s ++ t'
 ++-cong-right []      e = e
 ++-cong-right (x âˆ· s) e = âˆ·-cong x (++-cong-right s e)

\end{code}

And therefore it is a two-sided congruence:

\begin{code}

 ++-cong-âˆ¿ : {s s' t t' : FA} â†’ s âˆ¿ s' â†’ t âˆ¿ t' â†’ s ++ t âˆ¿ s' ++ t'
 ++-cong-âˆ¿ {s} {s'} {t} {t'} d e = s ++ t   âˆ¿âŸ¨ ++-cong-left s s' t d âŸ©
                                   s' ++ t  âˆ¿âŸ¨ ++-cong-right s' e âŸ©
                                   s' ++ t' âˆ¿âˆ
\end{code}

The group inverse, before quotienting:

\begin{code}

 inv : FA â†’ FA
 inv [] = []
 inv (x âˆ· s) = inv s ++ [ x â» ]

\end{code}

It is a congruence:

\begin{code}

 inv-++ : (s t : FA) â†’ inv (s ++ t) â‰¡ inv t ++ inv s
 inv-++ []      t = []-right-neutral (inv t)
 inv-++ (x âˆ· s) t = inv (s ++ t) ++ [ x â» ]     â‰¡âŸ¨ IH âŸ©
                    (inv t ++ inv s) ++ [ x â» ] â‰¡âŸ¨ assoc âŸ©
                    inv t ++ (inv s ++ [ x â» ]) âˆ
  where
   IH    = ap (_++ [ x â» ]) (inv-++ s t)
   assoc = ++-assoc (inv t) (inv s) [ x â» ]

 inv-â–· : {s t : FA} â†’ s â–· t â†’ inv s â–· inv t
 inv-â–· {s} {t} (u , v , y , p , q) = inv v , inv u , y , p' , q'
  where
   p' = inv s                                     â‰¡âŸ¨ I âŸ©
        inv (u ++ [ y ] ++ [ y â» ] ++ v)          â‰¡âŸ¨ II âŸ©
        inv ([ y ] ++ [ y â» ] ++ v) ++ inv u      â‰¡âŸ¨ III âŸ©
        inv (([ y ] ++ [ y â» ]) ++ v) ++ inv u    â‰¡âŸ¨ IV âŸ©
        (inv v ++ [ (y â»)â» ] ++ [ y â» ]) ++ inv u â‰¡âŸ¨ V âŸ©
        (inv v ++ [ y ] ++ [ y â» ]) ++ inv u      â‰¡âŸ¨ VI âŸ©
        inv v ++ [ y ] ++ [ y â» ] ++ inv u        âˆ
    where
     I   = ap inv p
     II  = inv-++ u ([ y ] ++ [ y â» ] ++ v)
     III = ap (Î» - â†’ inv - ++ inv u) ((++-assoc [ y ] [ y â» ] v)â»Â¹)
     IV  = ap (_++ inv u) (inv-++ ([ y ] ++ [ y â» ]) v)
     V   = ap (Î» - â†’ (inv v ++ [ - ] ++ [ y â» ]) ++ inv u) (inv-invol y)
     VI  = ++-assoc (inv v) ([ y ] ++ [ y â» ]) (inv u)

   q' = inv t          â‰¡âŸ¨ ap inv q âŸ©
        inv (u ++ v)   â‰¡âŸ¨ inv-++ u v âŸ©
        inv v ++ inv u âˆ

 inv-â—â–· : {s t : FA} â†’ s â—â–· t â†’ inv s â—â–· inv t
 inv-â—â–· (inl e) = inl (inv-â–· e)
 inv-â—â–· (inr e) = inr (inv-â–· e)

 inv-iteration : {s t : FA} (n : â„•)
               â†’ s â—â–·[ n ] t
               â†’ inv s â—â–·[ n ] inv t
 inv-iteration zero refl = refl
 inv-iteration (succ n) (u , b , c) = inv u , inv-â—â–· b , inv-iteration n c

 inv-cong-âˆ¿ : {s t : FA} â†’ s âˆ¿ t â†’ inv s âˆ¿ inv t
 inv-cong-âˆ¿ (n , a) = n , inv-iteration n a

\end{code}

The inverse really is an inverse:

\begin{code}

 =-âˆ¿ : {s s' : FA} â†’ s â‰¡ s' â†’ s âˆ¿ s'
 =-âˆ¿ {s} refl = srt-reflexive _â–·_ s

 inv-lemma : (x : X) â†’ [ x ] ++ [ x â» ] âˆ¿ []
 inv-lemma x = srt-extension _â–·_ _ [] ([] , [] , x , refl , refl)

 inv-lemma' : (x : X) â†’ [ x â» ] ++ [ x ] âˆ¿ []
 inv-lemma' x = srt-extension _â–·_ _ _
                 ([] ,
                  [] ,
                  (x â») ,
                  ap (Î» - â†’ [ x â» ] ++ [ - ]) ((inv-invol x)â»Â¹) , refl)

 inv-property-âˆ¿ : (s : FA) â†’ s ++ inv s âˆ¿ []
 inv-property-âˆ¿ []      = srt-reflexive _â–·_ []
 inv-property-âˆ¿ (x âˆ· s) = Î³
  where
   IH : s ++ inv s âˆ¿ []
   IH = inv-property-âˆ¿ s

   Î³ = [ x ] ++ s ++ inv s ++ [ x â» ]   âˆ¿âŸ¨ I âŸ©
       [ x ] ++ (s ++ inv s) ++ [ x â» ] âˆ¿âŸ¨ II âŸ©
       [ x ] ++ [ x â» ]                 âˆ¿âŸ¨ III âŸ©
       []                               âˆ¿âˆ
    where
     I   = =-âˆ¿  (ap (x âˆ·_) (++-assoc s (inv s) [ x â» ])â»Â¹)
     II  = ++-cong-right [ x ] (++-cong-left _ _ _ IH)
     III = inv-lemma x

 inv-property'-âˆ¿ : (s : FA) â†’ inv s ++ s âˆ¿ []
 inv-property'-âˆ¿ []      = srt-reflexive _â–·_ []
 inv-property'-âˆ¿ (x âˆ· s) = Î³
  where
   Î³ = (inv s ++ [ x â» ]) ++ (x âˆ· s)    âˆ¿âŸ¨ I âŸ©
       inv s ++ ([ x â» ] ++ [ x ] ++ s) âˆ¿âŸ¨ II âŸ©
       inv s ++ ([ x â» ] ++ [ x ]) ++ s âˆ¿âŸ¨ III âŸ©
       inv s ++ s                       âˆ¿âŸ¨ IV âŸ©
       []                               âˆ¿âˆ
    where
     I   = =-âˆ¿ (++-assoc (inv s) [ x â» ] (x âˆ· s))
     II  = =-âˆ¿ (ap (inv s ++_) ((++-assoc [ x â» ] [ x ] s)â»Â¹))
     III = ++-cong-right (inv s) (++-cong-left _ _ _ (inv-lemma' x))
     IV  = inv-property'-âˆ¿ s

\end{code}

The propositional, symmetric, reflexive, transitive closure of _â–·_:

\begin{code}

 module _ (pt : propositional-truncations-exist) where

  open PropositionalTruncation pt

  _âˆ¾_ : FA â†’ FA â†’ ğ“¤ Ì‡
  x âˆ¾ y = âˆ¥ x âˆ¿ y âˆ¥

  infix 1 _âˆ¾_

  Î·-âˆ¾ : {a b : A} â†’ is-set A â†’ Î· a âˆ¾ Î· b â†’ a â‰¡ b
  Î·-âˆ¾ i = âˆ¥âˆ¥-rec i Î·-âˆ¿

  ++-cong : {s s' t t' : FA} â†’ s âˆ¾ s' â†’ t âˆ¾ t' â†’ s ++ t âˆ¾ s' ++ t'
  ++-cong = âˆ¥âˆ¥-functorâ‚‚ ++-cong-âˆ¿

  inv-cong : {s t : FA} â†’ s âˆ¾ t â†’ inv s âˆ¾ inv t
  inv-cong = âˆ¥âˆ¥-functor inv-cong-âˆ¿

  inv-right : (s : FA) â†’ s ++ inv s âˆ¾ []
  inv-right s = âˆ£ inv-property-âˆ¿ s âˆ£

  inv-left : (s : FA) â†’ inv s ++ s âˆ¾ []
  inv-left s = âˆ£ inv-property'-âˆ¿ s âˆ£

\end{code}

To perform the quotient, we assume functional and propositional
extensionality.

\begin{code}

  module _ (fe' : FunExt)
           (pe  : propext ğ“¤)
        where

   fe : Fun-Ext
   fe {ğ“¤} {ğ“¥} = fe' ğ“¤ ğ“¥

   open import UF-Quotient
   open Quotient ğ“¤ ğ“¤ pt fe' pe
   open psrt pt _â–·_

   R : EqRel FA
   R = _âˆ¾_ , psrt-is-prop-valued , psrt-reflexive , psrt-symmetric , psrt-transitive

\end{code}

Our quotients constructed via propositional truncation increase
universe levels (this won't be a problem for our intended application,
the free group over the type of ordinals, because although this type
is large, it is locally small):

\begin{code}

   FA/âˆ¾ : ğ“¤ âº Ì‡
   FA/âˆ¾ = FA / R

   Î·/âˆ¾ : FA â†’ FA/âˆ¾
   Î·/âˆ¾ = Î·/ R

\end{code}

We have too many Î·'s now. The insertion of generators is the following:

\begin{code}

   Î·Î· : A â†’ FA/âˆ¾
   Î·Î· a = Î·/âˆ¾ (Î· a)

   Î·Î·-lc : is-set A â†’ (a b : A) â†’ Î·Î· a â‰¡ Î·Î· b â†’ a â‰¡ b
   Î·Î·-lc i a b p = Î·-âˆ¾ i (Î·/-relates-identified-points R p)

   Î·/âˆ¾-identifies-related-points : {s t : FA} â†’ s âˆ¾ t â†’ Î·/âˆ¾ s â‰¡ Î·/âˆ¾ t
   Î·/âˆ¾-identifies-related-points = Î·/-identifies-related-points R

\end{code}

We now need to make FA/âˆ¾ into a group. We will use "/" in names to
indicate constructions on the quotient FA/âˆ¾.

\begin{code}

   e/ : FA/âˆ¾
   e/ = Î·/âˆ¾ []

   inv/ : FA/âˆ¾ â†’ FA/âˆ¾
   inv/ = extensionâ‚/ R inv inv-cong

   _Â·_ : FA/âˆ¾ â†’ FA/âˆ¾ â†’ FA/âˆ¾
   _Â·_ = extensionâ‚‚/ R _++_ ++-cong

   inv/-natural : (s : FA) â†’ inv/ (Î·/âˆ¾ s) â‰¡ Î·/âˆ¾ (inv s)
   inv/-natural = naturality/ R inv inv-cong

   Â·-natural : (s t : FA) â†’ Î·/âˆ¾ s Â· Î·/âˆ¾ t â‰¡ Î·/âˆ¾ (s ++ t)
   Â·-natural = naturalityâ‚‚/ R _++_ ++-cong

   ln/ : left-neutral e/ _Â·_
   ln/ = /-induction R (Î» x â†’ e/ Â· x â‰¡ x) (Î» x â†’ quotient-is-set R) Î³
    where
     Î³ : (s : FA) â†’ Î·/âˆ¾ [] Â· Î·/âˆ¾ s â‰¡ Î·/âˆ¾ s
     Î³ = Â·-natural []

   rn/ : right-neutral e/ _Â·_
   rn/ = /-induction R (Î» x â†’ x Â· e/ â‰¡ x) (Î» x â†’ quotient-is-set R) Î³
    where
     Î³ : (s : FA) â†’ Î·/âˆ¾ s Â· Î·/âˆ¾ [] â‰¡ Î·/âˆ¾ s
     Î³ s = Î·/âˆ¾ s Â· Î·/âˆ¾ [] â‰¡âŸ¨ Â·-natural s [] âŸ©
           Î·/âˆ¾ (s ++ [])  â‰¡âŸ¨ ap Î·/âˆ¾ ([]-right-neutral s â»Â¹) âŸ©
           Î·/âˆ¾ s          âˆ

   invl/ : (x : FA/âˆ¾) â†’ inv/ x Â· x â‰¡ e/
   invl/ = /-induction R (Î» x â†’ (inv/ x Â· x) â‰¡ e/) (Î» x â†’ quotient-is-set R) Î³
    where
     Î³ : (s : FA) â†’ inv/ (Î·/âˆ¾ s) Â· Î·/âˆ¾ s â‰¡ e/
     Î³ s = inv/ (Î·/âˆ¾ s) Â· Î·/âˆ¾ s â‰¡âŸ¨ ap (_Â· Î·/âˆ¾ s) (inv/-natural s) âŸ©
           Î·/âˆ¾ (inv s) Â· Î·/âˆ¾ s  â‰¡âŸ¨ Â·-natural (inv s) s âŸ©
           Î·/âˆ¾ (inv s ++ s)     â‰¡âŸ¨ Î·/âˆ¾-identifies-related-points (inv-left s) âŸ©
           Î·/âˆ¾ []               â‰¡âŸ¨ refl âŸ©
           e/                   âˆ

   invr/ : (x : FA/âˆ¾) â†’ x Â· inv/ x â‰¡ e/
   invr/ = /-induction R (Î» x â†’ x Â· inv/ x â‰¡ e/) (Î» x â†’ quotient-is-set R) Î³
    where
     Î³ : (s : FA) â†’ Î·/âˆ¾ s Â· inv/ (Î·/âˆ¾ s) â‰¡ e/
     Î³ s = Î·/âˆ¾ s Â· inv/ (Î·/âˆ¾ s) â‰¡âŸ¨ ap (Î·/âˆ¾ s Â·_) (inv/-natural s) âŸ©
           Î·/âˆ¾ s Â· Î·/âˆ¾ (inv s)  â‰¡âŸ¨ Â·-natural s (inv s) âŸ©
           Î·/âˆ¾ (s ++ inv s)     â‰¡âŸ¨ Î·/âˆ¾-identifies-related-points (inv-right s) âŸ©
           Î·/âˆ¾ []               â‰¡âŸ¨ refl âŸ©
           e/                   âˆ

   assoc/ : associative _Â·_
   assoc/ = /-induction R (Î» x â†’ âˆ€ y z â†’ (x Â· y) Â· z â‰¡ x Â· (y Â· z))
              (Î» x â†’ Î â‚‚-is-prop fe (Î» y z â†’ quotient-is-set R))
              (Î» s â†’ /-induction R (Î» y â†’ âˆ€ z â†’ (Î·/âˆ¾ s Â· y) Â· z â‰¡ Î·/âˆ¾ s Â· (y Â· z))
                       (Î» y â†’ Î -is-prop fe (Î» z â†’ quotient-is-set R))
                       (Î» t â†’ /-induction R (Î» z â†’ (Î·/âˆ¾ s Â· Î·/âˆ¾ t) Â· z â‰¡ Î·/âˆ¾ s Â· (Î·/âˆ¾ t Â· z))
                                (Î» z â†’ quotient-is-set R)
                                (Î³ s t)))
    where
     Î³ : (s t u : FA) â†’ (Î·/âˆ¾ s Â· Î·/âˆ¾ t) Â· Î·/âˆ¾ u â‰¡ Î·/âˆ¾ s Â· (Î·/âˆ¾ t Â· Î·/âˆ¾ u)
     Î³ s t u = (Î·/âˆ¾ s Â· Î·/âˆ¾ t) Â· Î·/âˆ¾ u â‰¡âŸ¨ ap (_Â· Î·/âˆ¾ u) (Â·-natural s t) âŸ©
               Î·/âˆ¾ (s ++ t) Â· Î·/âˆ¾ u    â‰¡âŸ¨ Â·-natural (s ++ t) u âŸ©
               Î·/âˆ¾ ((s ++ t) ++ u)     â‰¡âŸ¨ ap Î·/âˆ¾ (++-assoc s t u) âŸ©
               Î·/âˆ¾ (s ++ (t ++ u))     â‰¡âŸ¨ (Â·-natural s (t ++ u))â»Â¹ âŸ©
               Î·/âˆ¾ s Â· Î·/âˆ¾ (t ++ u)    â‰¡âŸ¨ ap (Î·/âˆ¾ s Â·_) ((Â·-natural t u)â»Â¹) âŸ©
               Î·/âˆ¾ s Â· (Î·/âˆ¾ t Â· Î·/âˆ¾ u) âˆ
\end{code}

So we have constructed a group with underlying set FA/âˆ¾ and a map Î·Î· :
A â†’ FA/âˆ¾.

To prove that Î·Î· is the universal map of the set A into a group, we
assume another group G:

\begin{code}

   module _ {ğ“¥ : Universe}
            (G : ğ“¥ Ì‡ )
            (G-is-set : is-set G)
            (e : G)
            (invg : G â†’ G)
            (_â‹†_ : G â†’ G â†’ G)
            (ln : left-neutral e _â‹†_)
            (rn : right-neutral e _â‹†_)
            (invl : (g : G) â†’ invg g â‹† g â‰¡ e)
            (invr : (g : G) â†’ g â‹† invg g â‰¡ e)
            (assoc : associative _â‹†_)
            (f : A â†’ G)
         where

    h : FA â†’ G
    h [] = e
    h ((â‚€ , a) âˆ· s) = f a â‹† h s
    h ((â‚ , a) âˆ· s) = invg (f a) â‹† h s

    hâ» : (x : X) â†’ h (x  âˆ·  x â» âˆ· []) â‰¡ e

    hâ» (â‚€ , a) = f a â‹† (invg (f a) â‹† e)â‰¡âŸ¨ ap (f a â‹†_) (rn (invg (f a))) âŸ©
                 f a â‹† invg (f a)      â‰¡âŸ¨ invr (f a) âŸ©
                 e                     âˆ

    hâ» (â‚ , a) = invg (f a) â‹† (f a â‹† e)â‰¡âŸ¨ ap (invg (f a) â‹†_) (rn (f a)) âŸ©
                 invg (f a) â‹† f a      â‰¡âŸ¨ invl (f a) âŸ©
                 e                     âˆ

    h-is-hom : (s t : FA) â†’ h (s ++ t) â‰¡ h s â‹† h t

    h-is-hom [] t = h  t    â‰¡âŸ¨ (ln (h t))â»Â¹ âŸ©
                    e â‹† h t âˆ

    h-is-hom ((â‚€ , a) âˆ· s) t = f a â‹† h (s ++ t)    â‰¡âŸ¨ ap (f a â‹†_) (h-is-hom s t) âŸ©
                               f a â‹† (h s â‹† h t)   â‰¡âŸ¨ (assoc (f a) (h s) (h t))â»Â¹ âŸ©
                               (f a â‹† h s) â‹† h t   â‰¡âŸ¨ refl âŸ©
                               h (â‚€ , a âˆ· s) â‹† h t âˆ

    h-is-hom (â‚ , a âˆ· s) t = invg (f a) â‹† h (s ++ t)  â‰¡âŸ¨ ap (invg (f a) â‹†_) (h-is-hom s t) âŸ©
                             invg (f a) â‹† (h s â‹† h t) â‰¡âŸ¨ (assoc (invg (f a)) (h s) (h t))â»Â¹ âŸ©
                             (invg (f a) â‹† h s) â‹† h t â‰¡âŸ¨ refl âŸ©
                             h (â‚ , a âˆ· s) â‹† h t      âˆ

    h-identifies-â–·-related-points : {s t : FA} â†’ s â–· t â†’ h s â‰¡ h t
    h-identifies-â–·-related-points {s} {t} (u , v , y , p , q) =
       h s â‰¡âŸ¨ ap h p âŸ©
       h (u ++ [ y ] ++ [ y â» ] ++ v)   â‰¡âŸ¨ h-is-hom u ([ y ] ++ [ y â» ] ++ v) âŸ©
       h u â‹† h (y âˆ· y â» âˆ· v)            â‰¡âŸ¨ ap (h u â‹†_) (h-is-hom (y âˆ· y â» âˆ· []) v) âŸ©
       h u â‹† (h (y âˆ· (y â») âˆ· []) â‹† h v) â‰¡âŸ¨ ap (Î» - â†’ h u â‹† (- â‹† h v)) (hâ» y) âŸ©
       h u â‹† (e â‹† h v)                  â‰¡âŸ¨ ap (h u â‹†_) (ln (h v)) âŸ©
       h u â‹† h v                        â‰¡âŸ¨ (h-is-hom u v)â»Â¹ âŸ©
       h (u ++ v)                       â‰¡âŸ¨ ap h (q â»Â¹) âŸ©
       h t âˆ

    h-identifies-â–·*-related-points : {s t : FA} â†’ s â–·* t â†’ h s â‰¡ h t
    h-identifies-â–·*-related-points {s} {t} (n , r) = Î³ n s t r
     where
      Î³ : (n : â„•) (s t : FA) â†’ s â–·[ n ] t â†’ h s â‰¡ h t
      Î³ zero s s refl  = refl
      Î³ (succ n) s t (u , r , i) = h s â‰¡âŸ¨ h-identifies-â–·-related-points r âŸ©
                                   h u â‰¡âŸ¨ Î³ n u t i âŸ©
                                   h t âˆ

    h-identifies-âˆ¾-related-points : {s t : FA} â†’ s âˆ¾ t â†’ h s â‰¡ h t
    h-identifies-âˆ¾-related-points {s} {t} e = Î³
     where
      Î´ : (Î£ u ê‰ FA , (s â–·* u) Ã— (t â–·* u)) â†’ h s â‰¡ h t
      Î´ (u , Ïƒ , Ï„) = h s â‰¡âŸ¨ (h-identifies-â–·*-related-points Ïƒ) âŸ©
                      h u â‰¡âŸ¨ (h-identifies-â–·*-related-points Ï„)â»Â¹ âŸ©
                      h t âˆ
      Î³ : h s â‰¡ h t
      Î³ = âˆ¥âˆ¥-rec G-is-set Î´ (âˆ¥âˆ¥-functor (from-âˆ¿ Church-Rosser s t) e)

\end{code}

We then construct the unique homorphism extending f using the
universal property of quotients:

\begin{code}


    f' : FA/âˆ¾ â†’ G
    f' = mediating-map/ R G-is-set h h-identifies-âˆ¾-related-points

    f'-/triangle : f' âˆ˜ Î·/âˆ¾ âˆ¼ h
    f'-/triangle = universality-triangle/ R G-is-set h h-identifies-âˆ¾-related-points

\end{code}

And from this we get the triangle for the universal property of the
free group:

\begin{code}


    f'-triangle : f' âˆ˜ Î·Î· âˆ¼ f
    f'-triangle a = f' (Î·/âˆ¾ (Î· a)) â‰¡âŸ¨ f'-/triangle (Î· a) âŸ©
                    h (Î· a)        â‰¡âŸ¨ refl âŸ©
                    f a â‹† e        â‰¡âŸ¨ rn (f a) âŸ©
                    f a            âˆ

    f'-is-hom : (x y : FA/âˆ¾) â†’ f' (x Â· y) â‰¡ f' x â‹† f' y
    f'-is-hom = /-induction R (Î» x â†’ âˆ€ y â†’ f' (x Â· y) â‰¡ (f' x â‹† f' y))
                  (Î» x â†’ Î -is-prop fe (Î» y â†’ G-is-set))
                  (Î» s â†’ /-induction R (Î» y â†’ f' (Î·/âˆ¾ s Â· y) â‰¡ (f' (Î·/âˆ¾ s) â‹† f' y))
                           (Î» a â†’ G-is-set)
                           (Î³ s))
     where
      Î³ : (s t : FA) â†’ f' (Î·/âˆ¾ s Â· Î·/âˆ¾ t) â‰¡ f' (Î·/âˆ¾ s) â‹† f' (Î·/âˆ¾ t)
      Î³ s t = f' (Î·/âˆ¾ s Â· Î·/âˆ¾ t)      â‰¡âŸ¨ ap f' (Â·-natural s t) âŸ©
              f' (Î·/âˆ¾ (s ++ t))       â‰¡âŸ¨ f'-/triangle (s ++ t) âŸ©
              h (s ++ t)              â‰¡âŸ¨ h-is-hom s t âŸ©
              h s â‹† h t               â‰¡âŸ¨ apâ‚‚ _â‹†_ ((f'-/triangle s)â»Â¹) ((f'-/triangle t)â»Â¹) âŸ©
              f' (Î·/âˆ¾ s) â‹† f' (Î·/âˆ¾ t) âˆ

    f'-uniqueness : (fâ‚€ fâ‚ : FA/âˆ¾ â†’ G) â†’ fâ‚€ âˆ˜ Î·/âˆ¾ âˆ¼ h â†’ fâ‚ âˆ˜ Î·/âˆ¾ âˆ¼ h â†’ fâ‚€ âˆ¼ fâ‚
    f'-uniqueness fâ‚€ fâ‚ p q = at-most-one-mediating-map/ R G-is-set fâ‚€ fâ‚
                                 (Î» s â†’ p s âˆ™ (q s)â»Â¹)

\end{code}

What we wanted to know is now proved.

Last thing to do: Package the above into a single theorem, using a
type of groups, asserting the existence of free groups with injective
insertion of generators.
