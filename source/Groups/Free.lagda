Martin Escardo
January - February 2021, with a modularization of the presentation September 2023.

In collaboration with Marc Bezem, Thierry Coquand and Peter Dybjer.

We construct free groups in HoTT/UF in Agda notation without HIT's
other than propositional truncation, and optionally quotient types,
but quotients are not really necessary, although they make the proofs
marginally shorter.

This is based on the book [1]. It is noteworthy and surprising that
the set of generators is not required to have decidable equality.

One application of free groups in this development is to show,
constructively, that "there are more groups in the next universe", in
the sense that for any universe ğ“¤ there is a group in the next
universe ğ“¤âº which is not isomorphic to any group in ğ“¤. See the modules
Groups.Large and Ordinals.BuraliForti.

For this particular application, it is important that

 1. The insertion of generators, or universal map, into the free group
    is injective, and hence an embedding in the sense of HoTT/UF if
    the type of generators is a set (its fibers are subsingletons).

 2. The universal map is sufficiently small (its fibers are
    sufficiently small).

Condition (1) follows automatically from [1]. For condition (2) we
need more work, which is explained below.

[1] Ray Mines, Fred Richman and Wim Ruitenburg. "A course in
    constructive algebra", 1988.
    https://doi.org/10.1007/978-1-4419-8640-5

\begin{code}

{-# OPTIONS --safe --without-K --no-exact-split --lossy-unification #-}

module Groups.Free where

open import Groups.Type
open import MLTT.List
            renaming (_âˆ·_ to _â€¢_ ;
                      _++_ to _â—¦_ ;
                      ++-assoc to â—¦-assoc)

open import MLTT.Spartan
open import MLTT.Two
open import MLTT.Two-Properties
open import Quotient.Effectivity
open import Quotient.FromSetReplacement
open import Quotient.GivesPropTrunc
open import Quotient.GivesSetReplacement
open import Quotient.Large
open import Quotient.Type
open import UF.Base
open import UF.Embeddings
open import UF.Equiv hiding (_â‰…_)
open import UF.EquivalenceExamples
open import UF.FunExt
open import UF.PropTrunc
open import UF.Sets
open import UF.Size
open import UF.SmallnessProperties
open import UF.Subsingletons
open import UF.Subsingletons-FunExt
open import UF.UA-FunExt
open import UF.Univalence

\end{code}

In the following definition of existence of free groups, the given
type A of generators lives in the universe ğ“¤, the group freely
generated by A is required to live in the universe ğ“¥, and the
universal propertly eliminates into any universe ğ“¥'.

That the universal map Î· into the free group is an embedding and small
if A is a set is not part of the definition of freely generated group,
but we need it, in some applications, and we just have it, and so we
find it convenient to include it in our definition of the existence of
a "good" freely generated group.

The universe ğ“¦ measures the size of the map Î·. Recall that a map is
said to be ğ“¦-small if its fibers are all ğ“¦-small.

We also include the smallness of Î· in our definition of existence of
good free groups.

\begin{code}

record good-freely-generated-group-exists (A : ğ“¤ Ì‡ ) (ğ“¥ ğ“¦ : Universe) : ğ“¤Ï‰ where
 field
  ğ“• : Group ğ“¥
  Î· : A â†’ âŸ¨ ğ“• âŸ©
  universality : {ğ“¥' : Universe} (ğ“– : Group ğ“¥') (f : A â†’ âŸ¨ ğ“– âŸ©)
               â†’ âˆƒ! fÌ… ê‰ (âŸ¨ ğ“• âŸ© â†’ âŸ¨ ğ“– âŸ©)
                      , is-hom ğ“• ğ“– fÌ…
                      Ã— fÌ… âˆ˜ Î· âˆ¼ f
  Î·-is-embedding : is-set A â†’ is-embedding Î·
  Î·-is-small     : is-set A â†’ Î· is ğ“¦ small-map

\end{code}

We will see that we don't need to assume that the type A of generators
is a set to construct the free group and establish its universal
property. But if A is a set then the universal map Î· is automatically
a small embedding, although not automatically *sufficiently* small for
the application discussed above, and we add some work to the reference
[1] above to make it "tiny" for the purposes of the application.

We first formulate the main results of this file before proving them.

We start with a technical lemma, which assumes a general notion of
quotient, which in turn allows the quotient of a given type to live in
a universe other than that of the given type. The parameter â„“ controls
this - see the explanations in the module Quotient.Type.

\begin{code}

Lemma[free-groups-from-general-set-quotients]
 : propositional-truncations-exist
 â†’ Fun-Ext
 â†’ (â„“ : Universe â†’ Universe)
 â†’ (sq : general-set-quotients-exist â„“)
 â†’ are-effective sq
 â†’ (A : ğ“¤ Ì‡ ) â†’ good-freely-generated-group-exists A (ğ“¤ âŠ” â„“ ğ“¤) (ğ“¤ âŠ” â„“ ğ“¤)

\end{code}

The proof is postponed. We just mention that it follows the above
reference [1], adapting the reasoning to HoTT/UF rather routinely,
except that we have to pay attention to proof (ir)relevance.

We are interested in â„“ = id and â„“ = (_âº) and we are interested in the
following corollaries, which don't mention â„“.

The first one assumes that small set quotients exist and derives their
effectivity from functional and propositional extensionality to get
that small free groups exist, choosing â„“ = id. (Notice that the
HoTT-book also uses propositional extensionality to prove the
effectivity of quotients, although with a rather different proof.)

\begin{code}

Corollaryâ‚[free-groups-from-small-set-quotients]
 : Fun-Ext
 â†’ Prop-Ext
 â†’ set-quotients-exist
 â†’ (A : ğ“¤ Ì‡ ) â†’ good-freely-generated-group-exists A ğ“¤ ğ“¤
Corollaryâ‚[free-groups-from-small-set-quotients] fe pe sq =
 Lemma[free-groups-from-general-set-quotients]
  (propositional-truncations-from-set-quotients sq fe)
  fe (Î» ğ“¤ â†’ ğ“¤) sq
  (effectivity fe pe sq)

\end{code}

The second one assumes Set Replacement to construct quotients, and
again uses â„“ = id.

\begin{code}

Corollaryâ‚‚[free-groups-from-pt-fe-pe-sr]
 : (pt : propositional-truncations-exist)
 â†’ Fun-Ext
 â†’ Prop-Ext
 â†’ Set-Replacement pt
 â†’ (A : ğ“¤ Ì‡ ) â†’ good-freely-generated-group-exists A ğ“¤ ğ“¤
Corollaryâ‚‚[free-groups-from-pt-fe-pe-sr] pt fe pe sr =
 Lemma[free-groups-from-general-set-quotients] pt fe (Î» ğ“¤ â†’ ğ“¤)
  (set-quotients-from-set-replacement pt fe pe sr)
  (set-replacement-gives-effective-set-quotients pt fe pe sr)

\end{code}

Set replacement is equivalent to the existence of small quotients in
the presence of propositional truncations and functional and
propositional extensionality.

\begin{code}

private
 module _ (pt : propositional-truncations-exist)
          (fe : Fun-Ext)
          (pe : Prop-Ext)
        where

  remarkâ†’ : Set-Replacement pt â†’ set-quotients-exist
  remarkâ†’ = set-quotients-from-set-replacement pt fe pe

  remarkâ† : set-quotients-exist â†’ Set-Replacement pt
  remarkâ† sq = set-replacement-from-set-quotients-and-prop-trunc sq pt

\end{code}

The third corollary drops set replacement, and instead constructs
freely generated groups, with â„“ = (_âº), at the price of having the
free group living in the next universe (but still with the universal
property eliminating in all universes).

\begin{code}

Corollaryâ‚ƒ[large-free-groups-from-pt-fe-pe]
 : propositional-truncations-exist
 â†’ Fun-Ext
 â†’ Prop-Ext
 â†’ (A : ğ“¤ Ì‡ ) â†’ good-freely-generated-group-exists A (ğ“¤ âº) (ğ“¤ âº)
Corollaryâ‚ƒ[large-free-groups-from-pt-fe-pe] pt fe pe =
 Lemma[free-groups-from-general-set-quotients] pt fe (_âº)
  (large-set-quotients pt fe pe)
  (large-effective-set-quotients pt fe pe)

\end{code}

The fourth one is the observation that univalence and propositional
truncation suffice to construct large free groups.

\begin{code}

Corollaryâ‚„[large-free-groups-from-ua-pt]
  : Univalence
  â†’ propositional-truncations-exist
  â†’ (A : ğ“¤ Ì‡ ) â†’ good-freely-generated-group-exists A (ğ“¤ âº) (ğ“¤ âº)
Corollaryâ‚„[large-free-groups-from-ua-pt] ua pt =
 Corollaryâ‚ƒ[large-free-groups-from-pt-fe-pe] pt
  (Univalence-gives-Fun-Ext ua)
  (Univalence-gives-Prop-Ext ua)

\end{code}

We also prove the following two theorems, which are not corollaries of
the above technical lemma but instead require a careful enhancement of
its proof. They both assume that the type A of generators lives in the
universe ğ“¤âº, and reduce the size of Î· (compared to the above
corollaries) from ğ“¤âº to ğ“¤, but with different assumptions. For future
reference, we say that Î· is *tiny*.

For both theorems we assume that A is a large, locally small type.

For the first one we assume the existence of small quotients.

\begin{code}

Theoremâ‚[large-free-groups-from-set-quotients]
 : Fun-Ext
 â†’ Prop-Ext
 â†’ set-quotients-exist
 â†’ (A : ğ“¤ âº Ì‡ )
 â†’ is-locally-small A
 â†’ good-freely-generated-group-exists A (ğ“¤ âº) ğ“¤

\end{code}

The proof is posponed. But we mention that it relies on reducing the
size of the equivalence relation on words, in the sense that the
original relation has values on ğ“¤âº, and we get an equivalent
equivalence relation with values on ğ“¤, exploiting the local smallness
of A and introducing other technical tools.

This theorem says that if A is large and locally small, we can
construct the group freely generated by A in the same universe as A,
so that additionally Î· is ğ“¤ small, rather than ğ“¤âº small, which is what
the previous corollaries give. This means that Î· is tiny, using the
terminology introduced above.

The second theorem doesn't assume the existence of quotients, and
instead constructs them from the assumptions, and resizes it down to
ğ“¤âº using the local smallness of A and the lemmas used to prove the
above theorem.

\begin{code}

Theoremâ‚‚[free-groups-of-large-locally-small-types]
 : propositional-truncations-exist
 â†’ Fun-Ext
 â†’ Prop-Ext
 â†’ (A : ğ“¤ âº Ì‡)
 â†’ is-locally-small A
 â†’ good-freely-generated-group-exists A (ğ“¤ âº) ğ“¤

\end{code}

The proof is postponed. It is more or less routine, given the work
done to prove Theoremâ‚.

It is any of these two theorems that we need, in the module
Groups.Large, in order to prove that there is a group in ğ“¤âº with no
isomorphic copy in the universe ğ“¤, where it is crucial that Î· is
tiny. The ğ“¤âº smallness of Î·, given by the previous lemma and
corollaries, is not enough.

Remark. Notice that if propositional resizing is available, then Î· is
automatically tiny, because it is an embedding, and the fibers of
embeddings are propositions, so that the technical lemma is
sufficient. For example, propositional resizing is available if we
assume excluded middle. Additionally, in this case, the construction
of the free group can be considerably simplified, because we can work
with words in normal form, as in classical textbooks.

Organization:

 * The proof of the above technical lemma is in the submodule
   free-group-construction.

 * Its enhancements are in the submodules resize-universal-map
   and resize-free-group.

We now proceed to prove the technical lemma. The set-hood requirement
is needed only later, and so we don't include it as an assumption in
the following anonymous module.

Notational conventions. We have a number of universal maps, such as
those into a quotient and into a free group, all denoted by Î· with
decorations. Moreover, we have a "pre-universal" map of A into the set
of "words with polarity".

 * Given a set A of generators, FA is the type of words over elements
   of A with polarities (formally ğŸš Ã— A).

 * The function Î· : A â†’ FA is the "pre-universal map".

 * The function Î·/âˆ¾ : FA â†’ FA/âˆ¾ is the universal map into the quotient
   FA/âˆ¾ by a suitable equivalence relation _âˆ¾_ on words.

 * The function Î·á´³Ê³áµ– : A â†’ FA/âˆ¾, the composition of the above two
   functions, is the universal map into the (underlying set of the)
   free group.

   So in the above definition of good free group, Î· will be
   instantiated to Î·á´³Ê³áµ–.

\begin{code}

module free-group-construction
        {ğ“¤ : Universe}
        (A : ğ“¤ Ì‡ )
       where

 X : ğ“¤ Ì‡
 X = ğŸš Ã— A

 _â» : X â†’ X
 (n , a)â» = (complement n , a)

 _â»â» : X â†’ X
 x â»â» = (x â»)â»

 inv-invol : (x : X) â†’ x â»â» ï¼ x
 inv-invol (n , a) = ap (_, a) (complement-involutive n)

\end{code}

The idea is that list concatenation _â—¦_ will be the group operation
after suitable quotienting, with the empty list [] as the neutral
element.

We will quotient the following type FA to get the undelying type of
the free group:

\begin{code}

 FA : ğ“¤ Ì‡
 FA = List X

 Î· : A â†’ FA
 Î· a = [ (â‚€ , a) ]

\end{code}

The type ğŸš has two elements â‚€ and â‚, and a prefix â‚ to an element a of
the type A means it is formally inverted. So in the inclusion of
generators Î· we indicate that the element a is not inverted by
prefixing it with â‚€.

We will quotient the type FA, to get the group freely generated by A,
by the equivalence relation generated by the following reduction
relation, where we use _â—¦_ and _â€¢_ for concatenation of words in FA
and letters in X.

\begin{code}

 _â–·_ : FA â†’ FA â†’ ğ“¤ Ì‡
 s â–· t = Î£ u ê‰ FA , Î£ v ê‰ FA , Î£ x ê‰ X , (s ï¼ u â—¦ x â€¢ x â» â€¢ v)
                                       Ã— (t ï¼ u â—¦ v)
 infix 1 _â–·_

 â€¢-â–· : {s t : FA} (x : X) â†’ s â–· t â†’ x â€¢ s â–· x â€¢ t
 â€¢-â–· x (u , v , y , p , q) = (x â€¢ u) , v , y , ap (x â€¢_) p , ap (x â€¢_) q

\end{code}

The following lemma is proved by induction on uâ‚€ and uâ‚:

\begin{code}

 Lemma[Church-Rosser]
  : (uâ‚€ vâ‚€ uâ‚ vâ‚ : FA) (xâ‚€ xâ‚ : X)
  â†’ uâ‚€ â—¦ xâ‚€ â€¢ xâ‚€ â» â€¢ vâ‚€ ï¼ uâ‚ â—¦ xâ‚ â€¢ xâ‚ â» â€¢ vâ‚
  â†’ (uâ‚€ â—¦ vâ‚€ ï¼ uâ‚ â—¦ vâ‚)
  + (Î£ t ê‰ FA , (uâ‚€ â—¦ vâ‚€ â–· t) Ã— (uâ‚ â—¦ vâ‚ â–· t))

 Lemma[Church-Rosser] uâ‚€ vâ‚€ uâ‚ vâ‚ xâ‚€ xâ‚ = f uâ‚€ uâ‚
  where
   f : (uâ‚€ uâ‚ : FA)
     â†’ uâ‚€ â—¦ xâ‚€ â€¢ xâ‚€ â» â€¢ vâ‚€ ï¼ uâ‚ â—¦ xâ‚ â€¢ xâ‚ â» â€¢ vâ‚
     â†’ (uâ‚€ â—¦ vâ‚€ ï¼ uâ‚ â—¦ vâ‚) + (Î£ t ê‰ FA , (uâ‚€ â—¦ vâ‚€ â–· t) Ã— (uâ‚ â—¦ vâ‚ â–· t))

   f [] [] p = inl Î³
    where
     have : xâ‚€ â€¢ xâ‚€ â» â€¢ vâ‚€
         ï¼ xâ‚ â€¢ xâ‚ â» â€¢ vâ‚
     have = p

     Î³ : vâ‚€ ï¼ vâ‚
     Î³ = equal-tails (equal-tails p)

   f [] (yâ‚ â€¢ []) p = inl Î³
    where
     have : xâ‚€ â€¢ xâ‚€ â» â€¢ vâ‚€
         ï¼ yâ‚ â€¢ xâ‚   â€¢ xâ‚ â» â€¢ vâ‚
     have = p

     q = xâ‚ â»  ï¼âŸ¨ ap _â» ((equal-heads (equal-tails p))â»Â¹) âŸ©
         xâ‚€ â»â» ï¼âŸ¨ inv-invol xâ‚€ âŸ©
         xâ‚€    ï¼âŸ¨ equal-heads p âŸ©
         yâ‚    âˆ

     r : vâ‚€ ï¼ xâ‚ â» â€¢ vâ‚
     r = equal-tails (equal-tails p)

     Î³ : vâ‚€ ï¼ yâ‚ â€¢ vâ‚
     Î³ = transport (Î» - â†’ vâ‚€ ï¼ - â€¢ vâ‚) q r

   f [] (yâ‚ â€¢ zâ‚ â€¢ uâ‚) p = inr Î³
    where
     have : xâ‚€ â€¢ xâ‚€ â» â€¢ vâ‚€
         ï¼ yâ‚ â€¢ zâ‚   â€¢ uâ‚ â—¦ xâ‚ â€¢ xâ‚ â» â€¢ vâ‚
     have = p

     d' : uâ‚ â—¦ xâ‚ â€¢ xâ‚ â» â€¢ vâ‚ â–· uâ‚ â—¦ vâ‚
     d' = uâ‚ , vâ‚ , xâ‚ , refl , refl

     p' : uâ‚ â—¦ xâ‚ â€¢ xâ‚ â» â€¢ vâ‚ ï¼ vâ‚€
     p' = (equal-tails (equal-tails p))â»Â¹

     d : vâ‚€ â–· uâ‚ â—¦ vâ‚
     d = transport (_â–· uâ‚ â—¦ vâ‚) p' d'

     q = yâ‚ â» ï¼âŸ¨ (ap (_â») (equal-heads p)â»Â¹) âŸ©
         xâ‚€ â» ï¼âŸ¨ equal-heads (equal-tails p) âŸ©
         zâ‚   âˆ

     e' : yâ‚ â€¢ yâ‚ â» â€¢ uâ‚ â—¦ vâ‚ â–· uâ‚ â—¦ vâ‚
     e' = [] , (uâ‚ â—¦ vâ‚) , yâ‚ , refl , refl

     e : yâ‚ â€¢ zâ‚ â€¢ uâ‚ â—¦ vâ‚ â–· uâ‚ â—¦ vâ‚
     e = transport (Î» - â†’ yâ‚ â€¢ - â€¢ uâ‚ â—¦ vâ‚ â–· uâ‚ â—¦ vâ‚) q e'

     Î³ : Î£ t ê‰ FA , (vâ‚€ â–· t) Ã— (yâ‚ â€¢ zâ‚ â€¢ uâ‚ â—¦ vâ‚ â–· t)
     Î³ = (uâ‚ â—¦ vâ‚) , d , e

   f (yâ‚€ â€¢ []) [] p = inl Î³
    where
     have : yâ‚€ â€¢ xâ‚€   â€¢ xâ‚€ â» â€¢ vâ‚€
         ï¼ xâ‚ â€¢ xâ‚ â» â€¢ vâ‚
     have = p

     Î³ = yâ‚€ â€¢ vâ‚€    ï¼âŸ¨ ap (_â€¢ vâ‚€) (equal-heads p) âŸ©
         xâ‚ â€¢ vâ‚€    ï¼âŸ¨ ap (_â€¢ vâ‚€) ((inv-invol xâ‚)â»Â¹) âŸ©
         xâ‚ â»â» â€¢ vâ‚€ ï¼âŸ¨ ap (Î» - â†’ - â» â€¢ vâ‚€) ((equal-heads (equal-tails p))â»Â¹) âŸ©
         xâ‚€ â» â€¢ vâ‚€  ï¼âŸ¨ equal-tails (equal-tails p) âŸ©
         vâ‚         âˆ

   f (yâ‚€ â€¢ zâ‚€ â€¢ uâ‚€) [] p = inr Î³
    where
     have : yâ‚€ â€¢ zâ‚€   â€¢ uâ‚€ â—¦ xâ‚€ â€¢ xâ‚€ â» â€¢ vâ‚€
         ï¼ xâ‚ â€¢ xâ‚ â» â€¢ vâ‚
     have = p

     q = yâ‚€ â» ï¼âŸ¨ ap (_â») (equal-heads p) âŸ©
         xâ‚ â» ï¼âŸ¨ (equal-heads (equal-tails p))â»Â¹ âŸ©
         zâ‚€   âˆ

     d' : yâ‚€ â€¢ yâ‚€ â» â€¢ uâ‚€ â—¦ vâ‚€ â–· uâ‚€ â—¦ vâ‚€
     d' = [] , (uâ‚€ â—¦ vâ‚€) , yâ‚€ , refl , refl

     d : yâ‚€ â€¢ zâ‚€ â€¢ uâ‚€ â—¦ vâ‚€ â–· uâ‚€ â—¦ vâ‚€
     d = transport (Î» - â†’ yâ‚€ â€¢ - â€¢ uâ‚€ â—¦ vâ‚€ â–· uâ‚€ â—¦ vâ‚€) q d'

     e' : uâ‚€ â—¦ xâ‚€ â€¢ xâ‚€ â» â€¢ vâ‚€ â–· uâ‚€ â—¦ vâ‚€
     e' = uâ‚€ , vâ‚€ , xâ‚€ , refl , refl

     e : vâ‚ â–· uâ‚€ â—¦ vâ‚€
     e = transport (_â–· uâ‚€ â—¦ vâ‚€) (equal-tails (equal-tails p)) e'

     Î³ : Î£ t ê‰ FA , (yâ‚€ â€¢ zâ‚€ â€¢ uâ‚€ â—¦ vâ‚€ â–· t) Ã— (vâ‚ â–· t)
     Î³ = (uâ‚€ â—¦ vâ‚€) , d , e

   f (yâ‚€ â€¢ uâ‚€) (yâ‚ â€¢ uâ‚) p = Î³
    where
     have : yâ‚€ â€¢ uâ‚€ â—¦ xâ‚€ â€¢ xâ‚€ â» â€¢ vâ‚€
         ï¼ yâ‚ â€¢ uâ‚ â—¦ xâ‚ â€¢ xâ‚ â» â€¢ vâ‚
     have = p

     IH : (uâ‚€ â—¦ vâ‚€ ï¼ uâ‚ â—¦ vâ‚) + (Î£ t ê‰ FA , (uâ‚€ â—¦ vâ‚€ â–· t) Ã— (uâ‚ â—¦ vâ‚ â–· t))
     IH = f uâ‚€ uâ‚ (equal-tails p)

     Î“ : X â†’ X â†’ ğ“¤ Ì‡
     Î“ yâ‚€ yâ‚ = (yâ‚€ â€¢ uâ‚€ â—¦ vâ‚€ ï¼ yâ‚ â€¢ uâ‚ â—¦ vâ‚)
             + (Î£ t ê‰ FA , (yâ‚€ â€¢ uâ‚€ â—¦ vâ‚€ â–· t) Ã— (yâ‚ â€¢ uâ‚ â—¦ vâ‚ â–· t))

     Î´ : type-of IH â†’ âˆ€ {yâ‚€ yâ‚} â†’ yâ‚€ ï¼ yâ‚ â†’ Î“ yâ‚€ yâ‚
     Î´ (inl q)           {yâ‚€} refl = inl (ap (yâ‚€ â€¢_) q)
     Î´ (inr (t , d , e)) {yâ‚€} refl = inr ((yâ‚€ â€¢ t) , â€¢-â–· yâ‚€ d , â€¢-â–· yâ‚€ e)

     Î³ : Î“ yâ‚€ yâ‚
     Î³ = Î´ IH (equal-heads p)

\end{code}

We are interested in the following consequence of this lemma.

\begin{code}

 Theorem[Church-Rosser]
  : (s tâ‚€ tâ‚ : FA)
  â†’ s â–· tâ‚€
  â†’ s â–· tâ‚
  â†’ (tâ‚€ ï¼ tâ‚) + (Î£ t ê‰ FA , (tâ‚€ â–· t) Ã— (tâ‚ â–· t))
 Theorem[Church-Rosser] s tâ‚€ tâ‚ (uâ‚€ , vâ‚€ , xâ‚€ , pâ‚€ , qâ‚€)
                                (uâ‚ , vâ‚ , xâ‚ , pâ‚ , qâ‚) = Î³ Î´
  where
   have-pâ‚€ : s ï¼ uâ‚€ â—¦ xâ‚€ â€¢ xâ‚€ â» â€¢ vâ‚€
   have-pâ‚€ = pâ‚€

   have-pâ‚ : s ï¼ uâ‚ â—¦ xâ‚ â€¢ xâ‚ â» â€¢ vâ‚
   have-pâ‚ = pâ‚

   have-qâ‚€ : tâ‚€ ï¼ uâ‚€ â—¦ vâ‚€
   have-qâ‚€ = qâ‚€

   have-qâ‚ : tâ‚ ï¼ uâ‚ â—¦ vâ‚
   have-qâ‚ = qâ‚

   Î´ : (uâ‚€ â—¦ vâ‚€ ï¼ uâ‚ â—¦ vâ‚) + (Î£ t ê‰ FA , (uâ‚€ â—¦ vâ‚€ â–· t) Ã— (uâ‚ â—¦ vâ‚ â–· t))
   Î´ = Lemma[Church-Rosser] uâ‚€ vâ‚€ uâ‚ vâ‚ xâ‚€ xâ‚
        (uâ‚€ â—¦ xâ‚€ â€¢ xâ‚€ â» â€¢ vâ‚€ ï¼âŸ¨ pâ‚€ â»Â¹ âŸ©
         s                   ï¼âŸ¨ pâ‚ âŸ©
         uâ‚ â—¦ xâ‚ â€¢ xâ‚ â» â€¢ vâ‚ âˆ)

   Î³ : type-of Î´ â†’ (tâ‚€ ï¼ tâ‚) + (Î£ t ê‰ FA , (tâ‚€ â–· t) Ã— (tâ‚ â–· t))
   Î³ (inl q)             = inl (tâ‚€      ï¼âŸ¨ qâ‚€ âŸ©
                                uâ‚€ â—¦ vâ‚€ ï¼âŸ¨ q âŸ©
                                uâ‚ â—¦ vâ‚ ï¼âŸ¨ qâ‚ â»Â¹ âŸ©
                                tâ‚      âˆ)
   Î³ (inr (t , pâ‚€ , pâ‚)) = inr (t , Iâ‚€ , Iâ‚)
    where
     Iâ‚€ : tâ‚€ â–· t
     Iâ‚€ = transport (_â–· t) (qâ‚€ â»Â¹) pâ‚€

     Iâ‚ : tâ‚ â–· t
     Iâ‚ = transport (_â–· t) (qâ‚ â»Â¹) pâ‚

\end{code}

It is noteworthy and remarkable that the above doesn't need decidable
equality on A. We repeat that this construction is due to Mines,
Richman and Ruitenburg [1].

The following import defines

  _â—â–·_       the symmetric closure of _â–·_,
  _âˆ¿_        the symmetric, reflexive, transitive closure of _â–·_,
  _â–·*_       the reflexive, transitive closure of _â–·_,
  _â–·[ n ]_   the n-fold iteration of _â–·_.
  _â—â–·[ n ]_  the n-fold iteration of _â—â–·_.

and develops some useful consequences of the Church-Rosser property in
a general setting.

\begin{code}

 open import Relations.SRTclosure public
 open import Relations.ChurchRosser _â–·_ public

\end{code}

The insertion of generators is trivially left cancellable before
quotienting:

\begin{code}

 Î·-lc : {a b : A} â†’ Î· a ï¼ Î· b â†’ a ï¼ b
 Î·-lc refl = refl

\end{code}

The following less trivial result, which relies on the Church-Rosser
property, will give that the insertion of generators is injective
after quotienting:

\begin{code}

 Î·-irreducible : {a : A} {s : FA} â†’ Â¬ (Î· a â–· s)
 Î·-irreducible ((x â€¢ []) , v , y , () , refl)
 Î·-irreducible ((x â€¢ y â€¢ u) , v , z , () , q)

 Î·-irreducibleâ‹† : {a : A} {s : FA} â†’ Î· a â–·â‹† s â†’ Î· a ï¼ s
 Î·-irreducibleâ‹† {a} {s} (n , r) = f n r
  where
   f : (n : â„•) â†’ Î· a â–·[ n ] s â†’ Î· a ï¼ s
   f 0        refl        = refl
   f (succ n) (t , r , i) = ğŸ˜-elim (Î·-irreducible r)

 Î·-identifies-âˆ¿-related-points : {a b : A} â†’ Î· a âˆ¿ Î· b â†’ a ï¼ b
 Î·-identifies-âˆ¿-related-points {a} {b} e = Î·-lc p
  where
   Ïƒ : Î£ s ê‰ FA , (Î· a â–·â‹† s) Ã— (Î· b â–·â‹† s)
   Ïƒ = from-âˆ¿ Theorem[Church-Rosser] (Î· a) (Î· b) e
   s = prâ‚ Ïƒ

   p = Î· a ï¼âŸ¨  Î·-irreducibleâ‹† (prâ‚ (prâ‚‚ Ïƒ)) âŸ©
       s   ï¼âŸ¨ (Î·-irreducibleâ‹† (prâ‚‚ (prâ‚‚ Ïƒ)))â»Â¹ âŸ©
       Î· b âˆ

\end{code}

We need to work with the propositional truncation of _âˆ¿_ to construct
the free group, but most of the work will be done before truncation.

The following is for reasoning with chains of equivalences _âˆ¿_:

\begin{code}

 _âˆ¿âŸ¨_âŸ©_ : (s : FA) {t u : FA} â†’ s âˆ¿ t â†’ t âˆ¿ u â†’ s âˆ¿ u
 _ âˆ¿âŸ¨ p âŸ© q = srt-transitive _â–·_ _ _ _ p q

 _âˆ¿âˆ : (s : FA) â†’ s âˆ¿ s
 _âˆ¿âˆ _ = srt-reflexive _â–·_ _

 infixr 0 _âˆ¿âŸ¨_âŸ©_
 infix  1 _âˆ¿âˆ

\end{code}

We restate the reflexivity of the relation _âˆ¿_ as follows for
technical convenience.

\begin{code}

 ï¼-gives-âˆ¿ : {s s' : FA} â†’ s ï¼ s' â†’ s âˆ¿ s'
 ï¼-gives-âˆ¿ {s} refl = srt-reflexive _â–·_ s

\end{code}

As discussed above, the group operation before quotienting is simply
concatenation, with the empty list as the neutral element.

Concatenation is a left congruence. We establish this in several
steps:

\begin{code}

 â—¦-â–·-left : (s s' t : FA) â†’ s â–· s' â†’ s â—¦ t â–· s' â—¦ t
 â—¦-â–·-left s s' t (u , v , x , p , q) = u , (v â—¦ t) , x , p' , q'
  where
   p' = s â—¦ t                 ï¼âŸ¨ ap (_â—¦ t) p âŸ©
        (u â—¦ x â€¢ x â» â€¢ v) â—¦ t ï¼âŸ¨ â—¦-assoc u _ t âŸ©
        u â—¦ x â€¢ x â» â€¢ v â—¦ t   âˆ

   q' = s' â—¦ t      ï¼âŸ¨ ap (_â—¦ t) q âŸ©
        (u â—¦ v) â—¦ t ï¼âŸ¨ â—¦-assoc u v t âŸ©
        u â—¦ v â—¦ t   âˆ

 â—¦-â—â–·-left : (s s' t : FA) â†’ s â—â–· s' â†’ s â—¦ t â—â–· s' â—¦ t
 â—¦-â—â–·-left s s' t (inl a) = inl (â—¦-â–·-left s s' t a)
 â—¦-â—â–·-left s s' t (inr a) = inr (â—¦-â–·-left s' s t a)

 â—¦-iteration-left : (s s' t : FA) (n : â„•)
                   â†’ s â—â–·[ n ] s'
                   â†’ s â—¦ t â—â–·[ n ] s' â—¦ t
 â—¦-iteration-left s s  t 0        refl        = refl
 â—¦-iteration-left s s' t (succ n) (u , b , c) = (u â—¦ t) ,
                                                 â—¦-â—â–·-left s u t b ,
                                                 â—¦-iteration-left u s' t n c

 â—¦-cong-left : (s s' t : FA) â†’ s âˆ¿ s' â†’ s â—¦ t âˆ¿ s' â—¦ t
 â—¦-cong-left s s' t (n , a) = n , â—¦-iteration-left s s' t n a

\end{code}

It is also a right congruence:

\begin{code}

 â€¢-â—â–· : (x : X) {s t : FA} â†’ s â—â–· t â†’ x â€¢ s â—â–· x â€¢ t
 â€¢-â—â–· x (inl e) = inl (â€¢-â–· x e)
 â€¢-â—â–· x (inr e) = inr (â€¢-â–· x e)

 â€¢-iteration : (x : X) {s t : FA} (n : â„•)
             â†’ s â—â–·[ n ] t
             â†’ x â€¢ s â—â–·[ n ] x â€¢ t
 â€¢-iteration x 0        refl        = refl
 â€¢-iteration x (succ n) (u , b , c) = (x â€¢ u) , â€¢-â—â–· x b , â€¢-iteration x n c

 â€¢-cong : (x : X) {s t : FA} â†’ s âˆ¿ t â†’ x â€¢ s âˆ¿ x â€¢ t
 â€¢-cong x (n , a) = n , â€¢-iteration x n a

 â—¦-cong-right : (s {t t'} : FA) â†’ t âˆ¿ t' â†’ s â—¦ t âˆ¿ s â—¦ t'
 â—¦-cong-right []      e = e
 â—¦-cong-right (x â€¢ s) e = â€¢-cong x (â—¦-cong-right s e)

\end{code}

And therefore it is a two-sided congruence:

\begin{code}

 â—¦-cong-âˆ¿ : {s s' t t' : FA} â†’ s âˆ¿ s' â†’ t âˆ¿ t' â†’ s â—¦ t âˆ¿ s' â—¦ t'
 â—¦-cong-âˆ¿ {s} {s'} {t} {t'} d e = s â—¦ t   âˆ¿âŸ¨ â—¦-cong-left s s' t d âŸ©
                                  s' â—¦ t  âˆ¿âŸ¨ â—¦-cong-right s' e âŸ©
                                  s' â—¦ t' âˆ¿âˆ
\end{code}

We now construct the group inverse before quotienting. We reverse the
given list and formally invert all its elements:

\begin{code}

 finv : FA â†’ FA
 finv []      = []
 finv (x â€¢ s) = finv s â—¦ x â» â€¢ []

\end{code}

It is a congruence, which is proved in several steps:

\begin{code}

 finv-â—¦ : (s t : FA) â†’ finv (s â—¦ t) ï¼ finv t â—¦ finv s
 finv-â—¦ []      t = []-right-neutral (finv t)
 finv-â—¦ (x â€¢ s) t = finv (s â—¦ t) â—¦ x â» â€¢ []       ï¼âŸ¨ IH âŸ©
                     (finv t â—¦ finv s) â—¦ x â» â€¢ [] ï¼âŸ¨ a âŸ©
                     finv t â—¦ (finv s â—¦ x â» â€¢ []) âˆ
  where
   IH = ap (_â—¦ x â» â€¢ []) (finv-â—¦ s t)
   a  = â—¦-assoc (finv t) (finv s) [ x â» ]

 finv-â–· : {s t : FA} â†’ s â–· t â†’ finv s â–· finv t
 finv-â–· {s} {t} (u , v , y , p , q) = finv v , finv u , y , p' , q'
  where
   p' = finv s                                 ï¼âŸ¨ I âŸ©
        finv (u â—¦ y â€¢ y â» â€¢ v)                 ï¼âŸ¨ II âŸ©
        finv (y â€¢ y â» â€¢ v) â—¦ finv u            ï¼âŸ¨ III âŸ©
        (finv v â—¦ [ y â»â» ] â—¦ [ y â» ]) â—¦ finv u ï¼âŸ¨ IV âŸ©
        (finv v â—¦ y â€¢ y â» â€¢ []) â—¦ finv u       ï¼âŸ¨ V âŸ©
        finv v â—¦ y â€¢ y â» â€¢ finv u              âˆ
    where
     I   = ap finv p
     II  = finv-â—¦ u (y â€¢ y â» â€¢ v)
     III = ap (_â—¦ finv u) (finv-â—¦ ([ y ] â—¦ [ y â» ]) v)
     IV  = ap (Î» - â†’ (finv v â—¦ [ - ] â—¦ [ y â» ]) â—¦ finv u) (inv-invol y)
     V   = â—¦-assoc (finv v) ([ y ] â—¦ [ y â» ]) (finv u)

   q' = finv t          ï¼âŸ¨ ap finv q âŸ©
        finv (u â—¦ v)    ï¼âŸ¨ finv-â—¦ u v âŸ©
        finv v â—¦ finv u âˆ

 finv-â—â–· : {s t : FA} â†’ s â—â–· t â†’ finv s â—â–· finv t
 finv-â—â–· (inl e) = inl (finv-â–· e)
 finv-â—â–· (inr e) = inr (finv-â–· e)

 finv-iteration : {s t : FA} (n : â„•)
                â†’ s â—â–·[ n ] t
                â†’ finv s â—â–·[ n ] finv t
 finv-iteration 0        refl        = refl
 finv-iteration (succ n) (u , b , c) = finv u , finv-â—â–· b , finv-iteration n c

 finv-cong-âˆ¿ : {s t : FA} â†’ s âˆ¿ t â†’ finv s âˆ¿ finv t
 finv-cong-âˆ¿ (n , a) = n , finv-iteration n a

\end{code}

The inverse really is an inverse:

\begin{code}

 finv-lemma-right : (x : X) â†’ x â€¢ x â» â€¢ [] âˆ¿ []
 finv-lemma-right x = srt-extension _â–·_ _ [] ([] , [] , x , refl , refl)

 finv-lemma-left : (x : X) â†’ x â» â€¢ [] â—¦ x â€¢ [] âˆ¿ []
 finv-lemma-left x = srt-extension _â–·_ _ _
                      ([] ,
                       [] ,
                       (x â») ,
                       ap (Î» - â†’ x â» â€¢ [] â—¦ - â€¢ []) ((inv-invol x)â»Â¹) , refl)

 finv-right-âˆ¿ : (s : FA) â†’ s â—¦ finv s âˆ¿ []
 finv-right-âˆ¿ []      = srt-reflexive _â–·_ []
 finv-right-âˆ¿ (x â€¢ s) = Î³
  where
   IH : s â—¦ finv s âˆ¿ []
   IH = finv-right-âˆ¿ s

   Î³ = x â€¢ s â—¦ finv s â—¦ x â» â€¢ []   âˆ¿âŸ¨ I âŸ©
       x â€¢ (s â—¦ finv s) â—¦ x â» â€¢ [] âˆ¿âŸ¨ II âŸ©
       x â€¢ x â» â€¢ []                âˆ¿âŸ¨ III âŸ©
       []                          âˆ¿âˆ
    where
     I   = ï¼-gives-âˆ¿  (ap (x â€¢_) (â—¦-assoc s (finv s) [ x â» ])â»Â¹)
     II  = â—¦-cong-right [ x ] (â—¦-cong-left _ _ _ IH)
     III = finv-lemma-right x

 finv-left-âˆ¿ : (s : FA) â†’ finv s â—¦ s âˆ¿ []
 finv-left-âˆ¿ []      = srt-reflexive _â–·_ []
 finv-left-âˆ¿ (x â€¢ s) = Î³
  where
   Î³ = (finv s â—¦ x â» â€¢ []) â—¦ x â€¢ s      âˆ¿âŸ¨ I âŸ©
       finv s â—¦ (x â» â€¢ [] â—¦ x â€¢ s)      âˆ¿âŸ¨ II âŸ©
       finv s â—¦ (x â» â€¢ [] â—¦ x â€¢ []) â—¦ s âˆ¿âŸ¨ III âŸ©
       finv s â—¦ s                       âˆ¿âŸ¨ IV âŸ©
       []                               âˆ¿âˆ
    where
     I   = ï¼-gives-âˆ¿ (â—¦-assoc (finv s) [ x â» ] (x â€¢ s))
     II  = ï¼-gives-âˆ¿ (ap (finv s â—¦_) ((â—¦-assoc [ x â» ] [ x ] s)â»Â¹))
     III = â—¦-cong-right (finv s) (â—¦-cong-left _ _ _ (finv-lemma-left x))
     IV  = finv-left-âˆ¿ s

\end{code}

We now work with the propositional, symmetric, reflexive, transitive
closure of _â–·_, denoted by _âˆ¾_, for which we need to assume the
existence of propositional truncations.

\begin{code}

 module free-group-construction-stepâ‚
         (pt : propositional-truncations-exist)
        where

  open PropositionalTruncation pt public

  _âˆ¾_ : FA â†’ FA â†’ ğ“¤ Ì‡
  x âˆ¾ y = âˆ¥ x âˆ¿ y âˆ¥

  infix 1 _âˆ¾_

  Î·-identifies-âˆ¾-related-points : {a b : A} â†’ is-set A â†’ Î· a âˆ¾ Î· b â†’ a ï¼ b
  Î·-identifies-âˆ¾-related-points i = âˆ¥âˆ¥-rec i Î·-identifies-âˆ¿-related-points

  â—¦-cong : {s s' t t' : FA} â†’ s âˆ¾ s' â†’ t âˆ¾ t' â†’ s â—¦ t âˆ¾ s' â—¦ t'
  â—¦-cong = âˆ¥âˆ¥-functorâ‚‚ â—¦-cong-âˆ¿

  finv-cong : {s t : FA} â†’ s âˆ¾ t â†’ finv s âˆ¾ finv t
  finv-cong = âˆ¥âˆ¥-functor finv-cong-âˆ¿

  finv-right : (s : FA) â†’ s â—¦ finv s âˆ¾ []
  finv-right s = âˆ£ finv-right-âˆ¿ s âˆ£

  finv-left : (s : FA) â†’ finv s â—¦ s âˆ¾ []
  finv-left s = âˆ£ finv-left-âˆ¿ s âˆ£

\end{code}

To perform the quotient, we assume functional extensionality and the
existence of general, effective set quotients, in a universe
controlled by â„“.

\begin{code}

  module free-group-construction-stepâ‚‚
          (fe : Fun-Ext)
          (â„“ : Universe â†’ Universe)
          (sq : general-set-quotients-exist â„“)
          (Î·/-relates-identified-points : are-effective sq)
        where

   ğ“¤Ì… : Universe
   ğ“¤Ì… = ğ“¤ âŠ” â„“ ğ“¤

   open general-set-quotients-exist sq
   open psrt pt _â–·_ public

\end{code}

We have that _âˆ¾_ is an equivalence relation:

\begin{code}

   âˆ¾-is-equiv-rel : is-equiv-rel _âˆ¾_
   âˆ¾-is-equiv-rel = psrt-is-equiv-rel

   -âˆ¾- : EqRel FA
   -âˆ¾- = _âˆ¾_ , âˆ¾-is-equiv-rel

\end{code}

The acronym "psrt" stands for propositional, reflexive, symmetric and
transitive closure of a relation, in this case _â–·_.

We now name the quotient set and the universal map into it.

\begin{code}

   FA/âˆ¾ : ğ“¤Ì…  Ì‡
   FA/âˆ¾ = FA / -âˆ¾-

   Î·/âˆ¾ : FA â†’ FA/âˆ¾
   Î·/âˆ¾ = Î·/ -âˆ¾-

\end{code}

The insertion of generators of the free group is obtained by composing
the universal map into the quotient with our original map Î· : A â†’ FA
that inserts the generators into the freely generated "pre-group" of
lists.

\begin{code}

   Î·á´³Ê³áµ– : A â†’ FA/âˆ¾
   Î·á´³Ê³áµ– a = Î·/âˆ¾ (Î· a)

\end{code}

It is important for our purposes, and what we wanted to know,
constructively, that the inclusion of generators in the free group is
an injection, or a left-cancellable map, which relies on the
effectivity of quotients.

\begin{code}

   Î·/âˆ¾-relates-identified-points : {s t : FA} â†’ Î·/âˆ¾ s ï¼ Î·/âˆ¾ t â†’ s âˆ¾ t
   Î·/âˆ¾-relates-identified-points = Î·/-relates-identified-points -âˆ¾-

   Î·á´³Ê³áµ–-lc : is-set A â†’ {a b : A} â†’ Î·á´³Ê³áµ– a ï¼ Î·á´³Ê³áµ– b â†’ a ï¼ b
   Î·á´³Ê³áµ–-lc i p = Î·-identifies-âˆ¾-related-points i
                  (Î·/âˆ¾-relates-identified-points p)

   Î·á´³Ê³áµ–-is-embedding : is-set A â†’ is-embedding Î·á´³Ê³áµ–
   Î·á´³Ê³áµ–-is-embedding i = lc-maps-into-sets-are-embeddings Î·á´³Ê³áµ–
                          (Î·á´³Ê³áµ–-lc i)
                          (/-is-set -âˆ¾-)

   Î·/âˆ¾-identifies-related-points : {s t : FA} â†’ s âˆ¾ t â†’ Î·/âˆ¾ s ï¼ Î·/âˆ¾ t
   Î·/âˆ¾-identifies-related-points = Î·/-identifies-related-points -âˆ¾-

\end{code}

We now need to make FA/âˆ¾ into a group. We will use "/" in names to
indicate constructions on the quotient type FA/âˆ¾.

\begin{code}

   e/ : FA/âˆ¾
   e/ = Î·/âˆ¾ []

   inv/ : FA/âˆ¾ â†’ FA/âˆ¾
   inv/ = extensionâ‚/ -âˆ¾- finv finv-cong

   _Â·_ : FA/âˆ¾ â†’ FA/âˆ¾ â†’ FA/âˆ¾
   _Â·_ = extensionâ‚‚/ -âˆ¾- _â—¦_ â—¦-cong

\end{code}

The following two naturality conditions are crucial:

\begin{code}

   inv/-natural : (s : FA) â†’ inv/ (Î·/âˆ¾ s) ï¼ Î·/âˆ¾ (finv s)
   inv/-natural = naturality/ -âˆ¾- finv finv-cong

   Â·-natural : (s t : FA) â†’ Î·/âˆ¾ s Â· Î·/âˆ¾ t ï¼ Î·/âˆ¾ (s â—¦ t)
   Â·-natural = naturalityâ‚‚/ -âˆ¾- _â—¦_ â—¦-cong

\end{code}

Next, to prove the groups laws, we use quotient induction, denoted by
`/-induction`.

One can think of elements of FA/âˆ¾ as equivalence classes, and of Î·/âˆ¾ s
as the equivalence class of s. Then quotient induction says that in
order to prove a property of equivalence classes, it is enough to
prove it for all equivalence classes of given elements (this is proved
in the module Quotient.Type).

The following proofs rely on the above naturality conditions:

\begin{code}

   ln/ : left-neutral e/ _Â·_
   ln/ = /-induction -âˆ¾- (Î» _ â†’ /-is-set -âˆ¾-) Î³
    where
     Î³ : (s : FA) â†’ Î·/âˆ¾ [] Â· Î·/âˆ¾ s ï¼ Î·/âˆ¾ s
     Î³ = Â·-natural []

   rn/ : right-neutral e/ _Â·_
   rn/ = /-induction -âˆ¾- (Î» _ â†’ /-is-set -âˆ¾-) Î³
    where
     Î³ : (s : FA) â†’ Î·/âˆ¾ s Â· Î·/âˆ¾ [] ï¼ Î·/âˆ¾ s
     Î³ s = Î·/âˆ¾ s Â· Î·/âˆ¾ [] ï¼âŸ¨ Â·-natural s [] âŸ©
           Î·/âˆ¾ (s â—¦ [])   ï¼âŸ¨ ap Î·/âˆ¾ ([]-right-neutral s â»Â¹) âŸ©
           Î·/âˆ¾ s          âˆ

   invl/ : (x : FA/âˆ¾) â†’ inv/ x Â· x ï¼ e/
   invl/ = /-induction -âˆ¾- (Î» _ â†’ /-is-set -âˆ¾-) Î³
    where
     Î³ : (s : FA) â†’ inv/ (Î·/âˆ¾ s) Â· Î·/âˆ¾ s ï¼ e/
     Î³ s = inv/ (Î·/âˆ¾ s) Â· Î·/âˆ¾ s ï¼âŸ¨ ap (_Â· Î·/âˆ¾ s) (inv/-natural s) âŸ©
           Î·/âˆ¾ (finv s) Â· Î·/âˆ¾ s ï¼âŸ¨ Â·-natural (finv s) s âŸ©
           Î·/âˆ¾ (finv s â—¦ s)     ï¼âŸ¨ Î·/âˆ¾-identifies-related-points (finv-left s) âŸ©
           Î·/âˆ¾ []               ï¼âŸ¨ refl âŸ©
           e/                   âˆ

   invr/ : (x : FA/âˆ¾) â†’ x Â· inv/ x ï¼ e/
   invr/ = /-induction -âˆ¾- (Î» _ â†’ /-is-set -âˆ¾-) Î³
    where
     Î³ : (s : FA) â†’ Î·/âˆ¾ s Â· inv/ (Î·/âˆ¾ s) ï¼ e/
     Î³ s = Î·/âˆ¾ s Â· inv/ (Î·/âˆ¾ s) ï¼âŸ¨ ap (Î·/âˆ¾ s Â·_) (inv/-natural s) âŸ©
           Î·/âˆ¾ s Â· Î·/âˆ¾ (finv s) ï¼âŸ¨ Â·-natural s (finv s) âŸ©
           Î·/âˆ¾ (s â—¦ finv s)     ï¼âŸ¨ Î·/âˆ¾-identifies-related-points (finv-right s) âŸ©
           Î·/âˆ¾ []               ï¼âŸ¨ refl âŸ©
           e/                   âˆ

   assoc/ : associative _Â·_
   assoc/ = /-induction -âˆ¾-
             (Î» x â†’ Î â‚‚-is-prop fe (Î» y z â†’ /-is-set -âˆ¾-))
             (Î» s â†’ /-induction -âˆ¾-
                      (Î» y â†’ Î -is-prop fe (Î» z â†’ /-is-set -âˆ¾-))
                      (Î» t â†’ /-induction -âˆ¾-
                               (Î» z â†’ /-is-set -âˆ¾-)
                               (Î³ s t)))
    where
     Î³ : (s t u : FA) â†’ (Î·/âˆ¾ s Â· Î·/âˆ¾ t) Â· Î·/âˆ¾ u ï¼ Î·/âˆ¾ s Â· (Î·/âˆ¾ t Â· Î·/âˆ¾ u)
     Î³ s t u = (Î·/âˆ¾ s Â· Î·/âˆ¾ t) Â· Î·/âˆ¾ u ï¼âŸ¨ ap (_Â· Î·/âˆ¾ u) (Â·-natural s t) âŸ©
               Î·/âˆ¾ (s â—¦ t) Â· Î·/âˆ¾ u     ï¼âŸ¨ Â·-natural (s â—¦ t) u âŸ©
               Î·/âˆ¾ ((s â—¦ t) â—¦ u)       ï¼âŸ¨ ap Î·/âˆ¾ (â—¦-assoc s t u) âŸ©
               Î·/âˆ¾ (s â—¦ (t â—¦ u))       ï¼âŸ¨ (Â·-natural s (t â—¦ u))â»Â¹ âŸ©
               Î·/âˆ¾ s Â· Î·/âˆ¾ (t â—¦ u)     ï¼âŸ¨ ap (Î·/âˆ¾ s Â·_) ((Â·-natural t u)â»Â¹) âŸ©
               Î·/âˆ¾ s Â· (Î·/âˆ¾ t Â· Î·/âˆ¾ u) âˆ
\end{code}

So we have constructed a group with underlying set FA/âˆ¾ and a map
Î·á´³Ê³áµ– : A â†’ FA/âˆ¾. We now put everyhing together:

\begin{code}

   ğ“• : Group ğ“¤Ì…
   ğ“• = (FA/âˆ¾ , _Â·_ , /-is-set -âˆ¾- , assoc/ , e/ , ln/ , rn/ ,
        (Î» x â†’ inv/ x , invl/ x , invr/ x))

\end{code}

To prove that Î·á´³Ê³áµ– is the universal map of the set A into a group, we
assume another group ğ“– with a map f : A â†’ ğ“–:

\begin{code}

   module free-group-construction-stepâ‚ƒ
            {ğ“¥ : Universe}
            (G : ğ“¥ Ì‡ )
            (G-is-set : is-set G)
            (e : G)
            (invG : G â†’ G)
            (_*_ : G â†’ G â†’ G)
            (G-ln : left-neutral e _*_)
            (G-rn : right-neutral e _*_)
            (G-invl : (g : G) â†’ invG g * g ï¼ e)
            (G-invr : (g : G) â†’ g * invG g ï¼ e)
            (G-assoc : associative _*_)
            (f : A â†’ G)
         where

    ğ“– : Group ğ“¥
    ğ“– = (G , _*_ ,
         G-is-set , G-assoc , e , G-ln , G-rn ,
         (Î» x â†’ invG x , G-invl x , G-invr x))

\end{code}

Our objective is to construct fÌ… from f making the universality
triangle commute. As a first step in the construction of fÌ…, we
construct a map h by induction on lists.

\begin{code}

    h : FA â†’ G
    h []            = e
    h ((â‚€ , a) â€¢ s) = f a * h s
    h ((â‚ , a) â€¢ s) = invG (f a) * h s

\end{code}

We need the following property of h with respect to formal inverses:

\begin{code}

    hâ» : (x : X) â†’ h (x â€¢ x â» â€¢ []) ï¼ e

    hâ» (â‚€ , a) = f a * (invG (f a) * e) ï¼âŸ¨ ap (f a *_) (G-rn (invG (f a))) âŸ©
                 f a * invG (f a)       ï¼âŸ¨ G-invr (f a) âŸ©
                 e                      âˆ

    hâ» (â‚ , a) = invG (f a) * (f a * e) ï¼âŸ¨ ap (invG (f a) *_) (G-rn (f a)) âŸ©
                 invG (f a) * f a       ï¼âŸ¨ G-invl (f a) âŸ©
                 e                      âˆ
\end{code}

By construction, the function h is a list homomorphism. It is also a
monoid homomorphism:

\begin{code}

    h-is-hom : (s t : FA) â†’ h (s â—¦ t) ï¼ h s * h t

    h-is-hom [] t =
     h  t    ï¼âŸ¨ (G-ln (h t))â»Â¹ âŸ©
     e * h t âˆ

    h-is-hom ((â‚€ , a) â€¢ s) t =
     f a * h (s â—¦ t)     ï¼âŸ¨ ap (f a *_) (h-is-hom s t) âŸ©
     f a * (h s * h t)   ï¼âŸ¨ (G-assoc (f a) (h s) (h t))â»Â¹ âŸ©
     (f a * h s) * h t   ï¼âŸ¨ refl âŸ©
     h (â‚€ , a â€¢ s) * h t âˆ

    h-is-hom (â‚ , a â€¢ s) t =
     invG (f a) * h (s â—¦ t)   ï¼âŸ¨ ap (invG (f a) *_) (h-is-hom s t) âŸ©
     invG (f a) * (h s * h t) ï¼âŸ¨ (G-assoc (invG (f a)) (h s) (h t))â»Â¹ âŸ©
     (invG (f a) * h s) * h t ï¼âŸ¨ refl âŸ©
     h (â‚ , a â€¢ s) * h t      âˆ

\end{code}

We also need the following property of the map h in order to construct
our desired group homomorphism fÌ…:

\begin{code}

    h-identifies-â–·-related-points : {s t : FA} â†’ s â–· t â†’ h s ï¼ h t
    h-identifies-â–·-related-points {s} {t} (u , v , y , p , q) =
       h s ï¼âŸ¨ ap h p âŸ©
       h (u â—¦ y â€¢ y â» â€¢ v)            ï¼âŸ¨ h-is-hom u (y â€¢ y â» â€¢ v) âŸ©
       h u * h (y â€¢ y â» â€¢ v)          ï¼âŸ¨ ap (h u *_) (h-is-hom (y â€¢ y â» â€¢ []) v) âŸ©
       h u * (h (y â€¢ y â» â€¢ []) * h v) ï¼âŸ¨ ap (Î» - â†’ h u * (- * h v)) (hâ» y) âŸ©
       h u * (e * h v)                ï¼âŸ¨ ap (h u *_) (G-ln (h v)) âŸ©
       h u * h v                      ï¼âŸ¨ (h-is-hom u v)â»Â¹ âŸ©
       h (u â—¦ v)                      ï¼âŸ¨ ap h (q â»Â¹) âŸ©
       h t                            âˆ

    h-identifies-â–·â‹†-related-points : {s t : FA} â†’ s â–·â‹† t â†’ h s ï¼ h t
    h-identifies-â–·â‹†-related-points {s} {t} (n , r) = Î³ n s t r
     where
      Î³ : (n : â„•) (s t : FA) â†’ s â–·[ n ] t â†’ h s ï¼ h t
      Î³ 0        s s refl        = refl
      Î³ (succ n) s t (u , r , i) = h s ï¼âŸ¨ h-identifies-â–·-related-points r âŸ©
                                   h u ï¼âŸ¨ Î³ n u t i âŸ©
                                   h t âˆ

    h-identifies-âˆ¾-related-points : {s t : FA} â†’ s âˆ¾ t â†’ h s ï¼ h t
    h-identifies-âˆ¾-related-points {s} {t} e = Î³
     where
      Î´ : (Î£ u ê‰ FA , (s â–·â‹† u) Ã— (t â–·â‹† u)) â†’ h s ï¼ h t
      Î´ (u , Ïƒ , Ï„) = h s ï¼âŸ¨ (h-identifies-â–·â‹†-related-points Ïƒ) âŸ©
                      h u ï¼âŸ¨ (h-identifies-â–·â‹†-related-points Ï„)â»Â¹ âŸ©
                      h t âˆ
      Î³ : h s ï¼ h t
      Î³ = âˆ¥âˆ¥-rec G-is-set Î´ (âˆ¥âˆ¥-functor (from-âˆ¿ Theorem[Church-Rosser] s t) e)

\end{code}

We can then finally construct the unique homorphism fÌ… extending f
applying the universal property of quotients to the above map h:

\begin{code}

    fÌ… : FA/âˆ¾ â†’ G
    fÌ… = mediating-map/ -âˆ¾- G-is-set h h-identifies-âˆ¾-related-points

    fÌ…-/triangle : fÌ… âˆ˜ Î·/âˆ¾ âˆ¼ h
    fÌ…-/triangle = universality-triangle/ -âˆ¾-
                   G-is-set h h-identifies-âˆ¾-related-points

\end{code}

And from this we get the triangle for the universal property of the
free group:

\begin{code}

    fÌ…-triangle : fÌ… âˆ˜ Î·á´³Ê³áµ– âˆ¼ f
    fÌ…-triangle a = fÌ… (Î·/âˆ¾ (Î· a)) ï¼âŸ¨ fÌ…-/triangle (Î· a) âŸ©
                    h (Î· a)      ï¼âŸ¨ refl âŸ©
                    f a * e      ï¼âŸ¨ G-rn (f a) âŸ©
                    f a          âˆ

\end{code}

Which is a group homomorphism (rather than merely a monoid
homomorphism like h):

\begin{code}

    fÌ…-is-hom : is-hom ğ“• ğ“– fÌ…
    fÌ…-is-hom {x} {y} = Î³ x y
     where
      Î´ : (s t : FA) â†’ fÌ… (Î·/âˆ¾ s Â· Î·/âˆ¾ t) ï¼ fÌ… (Î·/âˆ¾ s) * fÌ… (Î·/âˆ¾ t)
      Î´ s t = fÌ… (Î·/âˆ¾ s Â· Î·/âˆ¾ t)     ï¼âŸ¨ I âŸ©
              fÌ… (Î·/âˆ¾ (s â—¦ t))       ï¼âŸ¨ II âŸ©
              h (s â—¦ t)             ï¼âŸ¨ III âŸ©
              h s * h t             ï¼âŸ¨ IV âŸ©
              fÌ… (Î·/âˆ¾ s) * fÌ… (Î·/âˆ¾ t) âˆ
        where
         I   = ap fÌ… (Â·-natural s t)
         II  = fÌ…-/triangle (s â—¦ t)
         III = h-is-hom s t
         IV  = apâ‚‚ _*_ ((fÌ…-/triangle s)â»Â¹) ((fÌ…-/triangle t)â»Â¹)

      Î³ : (x y : FA / -âˆ¾-) â†’ fÌ… (x Â· y) ï¼ fÌ… x * fÌ… y
      Î³ = /-induction -âˆ¾-
           (Î» x â†’ Î -is-prop fe (Î» y â†’ G-is-set))
           (Î» s â†’ /-induction -âˆ¾-
                   (Î» a â†’ G-is-set)
                   (Î´ s))
\end{code}

Notice that for the following uniqueness property of fÌ… we don't need
to assume that fâ‚€ and fâ‚ are group homomorphisms:

\begin{code}

    fÌ…-uniqueness-âˆ¾ : (fâ‚€ fâ‚ : FA/âˆ¾ â†’ G) â†’ fâ‚€ âˆ˜ Î·/âˆ¾ âˆ¼ h â†’ fâ‚ âˆ˜ Î·/âˆ¾ âˆ¼ h â†’ fâ‚€ âˆ¼ fâ‚
    fÌ…-uniqueness-âˆ¾ fâ‚€ fâ‚ p q = at-most-one-mediating-map/ -âˆ¾-
                                G-is-set fâ‚€ fâ‚ (Î» s â†’ p s âˆ™ (q s)â»Â¹)

\end{code}

But for this one we do:

\begin{code}

    fÌ…-uniqueness' : (fâ‚€ fâ‚ : FA/âˆ¾ â†’ G)
                  â†’ is-hom ğ“• ğ“– fâ‚€
                  â†’ is-hom ğ“• ğ“– fâ‚
                  â†’ fâ‚€ âˆ˜ Î·á´³Ê³áµ– âˆ¼ f
                  â†’ fâ‚ âˆ˜ Î·á´³Ê³áµ– âˆ¼ f
                  â†’ fâ‚€ âˆ¼ fâ‚
    fÌ…-uniqueness' fâ‚€ fâ‚ iâ‚€ iâ‚ fâ‚€-triangle fâ‚-triangle = Î³
     where
      p : fâ‚€ âˆ˜ Î·á´³Ê³áµ– âˆ¼ fâ‚ âˆ˜ Î·á´³Ê³áµ–
      p x = fâ‚€-triangle x âˆ™ (fâ‚-triangle x)â»Â¹

      Î´ : (s : FA) â†’ fâ‚€ (Î·/âˆ¾ s) ï¼ fâ‚ (Î·/âˆ¾ s)
      Î´ [] = fâ‚€ (Î·/âˆ¾ []) ï¼âŸ¨ homs-preserve-unit ğ“• ğ“– fâ‚€ iâ‚€ âŸ©
             e           ï¼âŸ¨ (homs-preserve-unit ğ“• ğ“– fâ‚ iâ‚)â»Â¹ âŸ©
             fâ‚ (Î·/âˆ¾ []) âˆ
      Î´ ((â‚€ , a) â€¢ s) =
             fâ‚€ (Î·/âˆ¾ (Î· a â—¦ s))       ï¼âŸ¨ ap fâ‚€ ((Â·-natural (Î· a) s)â»Â¹) âŸ©
             fâ‚€ (Î·á´³Ê³áµ– a Â· Î·/âˆ¾ s)      ï¼âŸ¨ iâ‚€  âŸ©
             fâ‚€ (Î·á´³Ê³áµ– a) * fâ‚€ (Î·/âˆ¾ s) ï¼âŸ¨ apâ‚‚ _*_ (p a) (Î´ s) âŸ©
             fâ‚ (Î·á´³Ê³áµ– a) * fâ‚ (Î·/âˆ¾ s) ï¼âŸ¨ iâ‚ â»Â¹ âŸ©
             fâ‚ (Î·á´³Ê³áµ– a Â· Î·/âˆ¾ s)      ï¼âŸ¨ ap fâ‚ (Â·-natural (Î· a) s) âŸ©
             fâ‚ (Î·/âˆ¾ (Î· a â—¦ s))       âˆ
      Î´ ((â‚ , a) â€¢ s) =
             fâ‚€ (Î·/âˆ¾ (finv (Î· a) â—¦ s))          ï¼âŸ¨ I âŸ©
             fâ‚€ (Î·/âˆ¾ (finv (Î· a)) Â· Î·/âˆ¾ s)      ï¼âŸ¨ II âŸ©
             fâ‚€ (Î·/âˆ¾ (finv (Î· a))) * fâ‚€ (Î·/âˆ¾ s) ï¼âŸ¨ III âŸ©
             fâ‚€ (inv/ (Î·á´³Ê³áµ– a)) * fâ‚€ (Î·/âˆ¾ s)    ï¼âŸ¨ IV âŸ©
             invG (fâ‚€ (Î·á´³Ê³áµ– a)) * fâ‚€ (Î·/âˆ¾ s)    ï¼âŸ¨ IH âŸ©
             invG (fâ‚ (Î·á´³Ê³áµ– a)) * fâ‚ (Î·/âˆ¾ s)    ï¼âŸ¨ IV' âŸ©
             fâ‚ (inv/ (Î·á´³Ê³áµ– a)) * fâ‚ (Î·/âˆ¾ s)    ï¼âŸ¨ III' âŸ©
             fâ‚ (Î·/âˆ¾ (finv (Î· a))) * fâ‚ (Î·/âˆ¾ s) ï¼âŸ¨ II' âŸ©
             fâ‚ (Î·/âˆ¾ (finv (Î· a)) Â· Î·/âˆ¾ s)      ï¼âŸ¨ I' âŸ©
             fâ‚ (Î·/âˆ¾ (finv (Î· a) â—¦ s))          âˆ
            where
             I    = ap fâ‚€ ((Â·-natural (finv (Î· a)) s)â»Â¹)
             II   = iâ‚€
             III  = ap (Î» - â†’ fâ‚€ - * fâ‚€ (Î·/âˆ¾ s)) ((inv/-natural (Î· a))â»Â¹)
             IV   = ap (_* fâ‚€ (Î·/âˆ¾ s)) (homs-preserve-invs ğ“• ğ“– fâ‚€ iâ‚€ (Î·á´³Ê³áµ– a))
             IH   = apâ‚‚ (Î» - -' â†’ invG - * -') (p a) (Î´ s)
             IV'  = ap (_* fâ‚ (Î·/âˆ¾ s)) ((homs-preserve-invs ğ“• ğ“– fâ‚ iâ‚ (Î·á´³Ê³áµ– a))â»Â¹)
             III' = ap (Î» - â†’ fâ‚ - * fâ‚ (Î·/âˆ¾ s)) (inv/-natural (Î· a))
             II'  = iâ‚ â»Â¹
             I'   = ap fâ‚ (Â·-natural (finv (Î· a)) s)

      Î³ : fâ‚€ âˆ¼ fâ‚
      Î³ = /-induction -âˆ¾- (Î» x â†’ G-is-set) Î´

    fÌ…-uniqueness : âˆƒ! fÌ… ê‰ (âŸ¨ ğ“• âŸ© â†’ âŸ¨ ğ“– âŸ©)
                        , is-hom ğ“• ğ“– fÌ…
                        Ã— fÌ… âˆ˜ Î·á´³Ê³áµ– âˆ¼ f
    fÌ…-uniqueness = Î³
     where
      c : Î£ fÌ… ê‰ (âŸ¨ ğ“• âŸ© â†’ âŸ¨ ğ“– âŸ©) , is-hom ğ“• ğ“– fÌ… Ã— fÌ… âˆ˜ Î·á´³Ê³áµ– âˆ¼ f
      c = (fÌ… , fÌ…-is-hom , fÌ…-triangle)

      i : is-central _ c
      i (fâ‚€ , fâ‚€-is-hom , fâ‚€-triangle) = to-subtype-ï¼ a b
       where
        a : (fÌ… : âŸ¨ ğ“• âŸ© â†’ âŸ¨ ğ“– âŸ©) â†’ is-prop (is-hom ğ“• ğ“– fÌ… Ã— fÌ… âˆ˜ Î·á´³Ê³áµ– âˆ¼ f)
        a fÌ… = Ã—-is-prop
               (being-hom-is-prop fe ğ“• ğ“– fÌ…)
               (Î -is-prop fe (Î» a â†’ groups-are-sets ğ“–))

        b : fÌ… ï¼ fâ‚€
        b = dfunext fe
             (fÌ…-uniqueness' fÌ… fâ‚€ fÌ…-is-hom fâ‚€-is-hom fÌ…-triangle fâ‚€-triangle)

      Î³ : âˆƒ! fÌ… ê‰ (âŸ¨ ğ“• âŸ© â†’ âŸ¨ ğ“– âŸ©) , is-hom ğ“• ğ“– fÌ… Ã— fÌ… âˆ˜ Î·á´³Ê³áµ– âˆ¼ f
      Î³ = c , i

\end{code}

This completes the construction of the free group.

We summarize the important parts in the following interface:

\begin{code}

module FreeGroupInterface
        (pt : propositional-truncations-exist)
        (fe : Fun-Ext)
        (â„“ : Universe â†’ Universe)
        (sq : general-set-quotients-exist â„“)
        (Î·/-relates-identified-points : are-effective sq)
        {ğ“¤ : Universe}
        (A : ğ“¤ Ì‡ )
       where

 open free-group-construction A
 open free-group-construction-stepâ‚ pt
 open free-group-construction-stepâ‚‚ fe â„“ sq Î·/-relates-identified-points

 free-group : Group ğ“¤Ì…
 free-group = ğ“•

 Î·-free-group : A â†’ âŸ¨ free-group âŸ©
 Î·-free-group = Î·á´³Ê³áµ–

 Î·-free-group-is-small : Î·á´³Ê³áµ– is (ğ“¤ âŠ” â„“ ğ“¤) small-map
 Î·-free-group-is-small = native-size-of-map Î·á´³Ê³áµ–

 Î·-free-group-is-embedding : is-set A â†’ is-embedding Î·-free-group
 Î·-free-group-is-embedding = Î·á´³Ê³áµ–-is-embedding

 module _ ((G , _*_ , G-is-set , G-assoc , e , l , r , inversion) : Group ğ“¥)
          (f : A â†’ G)
        where

  open free-group-construction-stepâ‚ƒ
        G G-is-set e (Î» x â†’ prâ‚ (inversion x)) _*_ l r
        (Î» x â†’ prâ‚ (prâ‚‚ (inversion x))) (Î» x â†’ prâ‚‚ (prâ‚‚ (inversion x))) G-assoc f

  free-group-extension : âŸ¨ free-group âŸ© â†’ âŸ¨ ğ“– âŸ©
  free-group-extension = fÌ…

  free-group-is-hom : is-hom free-group ğ“– free-group-extension
  free-group-is-hom = fÌ…-is-hom

  free-group-triangle : free-group-extension âˆ˜ Î·-free-group âˆ¼ f
  free-group-triangle = fÌ…-triangle

  extension-to-free-group-uniqueness :

    âˆƒ! fÌ… ê‰ (âŸ¨ free-group âŸ© â†’ âŸ¨ ğ“– âŸ©)
         , is-hom free-group ğ“– fÌ…
         Ã— fÌ… âˆ˜ Î·-free-group âˆ¼ f

  extension-to-free-group-uniqueness = fÌ…-uniqueness

\end{code}

With this we have proved the tecnical lemma.

\begin{code}

Lemma[free-groups-from-general-set-quotients] pt fe â„“ sq eff A =
 record
  { ğ“•              = free-group
  ; Î·              = Î·-free-group
  ; universality   = extension-to-free-group-uniqueness
  ; Î·-is-embedding = Î·-free-group-is-embedding
  ; Î·-is-small     = Î» _ â†’ Î·-free-group-is-small -- (*)
  }
 where
  open FreeGroupInterface pt fe â„“ sq eff A

\end{code}

(*) Notice that the assumption that A is a set is not needed for Î· to
be small in this case, but it is needed for Î· to be an embedding.

We now proceed to the proof of Theoremâ‚, which requires an enhancement
of the above proof.

The last three assumptions in the following module parameters are a
slight weakening of the local smallness condition on the type A.

\begin{code}

module resize-universal-map
        (fe : Fun-Ext)
        (pe : Prop-Ext)
        (pt : propositional-truncations-exist)
        {ğ“¤        : Universe}
        (A        : ğ“¤ âº Ì‡)
        (_ï¼â‚€_    : A â†’ A â†’ ğ“¤ Ì‡ )
        (reflâ‚€    : (a : A) â†’ a ï¼â‚€ a)
        (from-ï¼â‚€ : (a b : A) â†’ a ï¼â‚€ b â†’ a ï¼ b)
        (â„“ : Universe â†’ Universe)
        (sq : general-set-quotients-exist â„“)
        (Î·/-relates-identified-points : are-effective sq)
       where

 open free-group-construction A

 ğ“¤âº  = ğ“¤ âº
 ğ“¤âºâº = ğ“¤âº âº

 fe' : FunExt
 fe' ğ“¤ ğ“¥ = fe {ğ“¤} {ğ“¥}

 pe' : PropExt
 pe' ğ“¤ = pe {ğ“¤}

\end{code}

Our free group is constructed as a quotient of a set of words FA by a
certain equivalence relation _âˆ¾_ : FA â†’ FA â†’ ğ“¤âº. To reduce the size of
the universal map, we reduce the size of the (propositional) values of
this equivalence relation using the assumed relation _ï¼â‚€_ and
functions reflâ‚€ and from-ï¼â‚€.

\begin{code}

 _ï¼[X]_ : X â†’ X â†’ ğ“¤ Ì‡
 (m , a) ï¼[X] (n , b) = (m ï¼ n) Ã— (a ï¼â‚€ b)

 from-ï¼[X] : {x y : X} â†’ x ï¼[X] y â†’ x ï¼ y
 from-ï¼[X] {m , a} {n , b} (p , q) = to-Ã—-ï¼ p (from-ï¼â‚€ a b q)

 to-ï¼[X] : {x y : X} â†’ x ï¼ y â†’ x ï¼[X] y
 to-ï¼[X] {m , a} {m , a} refl = refl , reflâ‚€ a

 _ï¼[FA]_ : FA â†’ FA â†’ ğ“¤ Ì‡
 []      ï¼[FA] []      = ğŸ™
 []      ï¼[FA] (y â€¢ t) = ğŸ˜
 (x â€¢ s) ï¼[FA] []      = ğŸ˜
 (x â€¢ s) ï¼[FA] (y â€¢ t) = (x ï¼[X] y) Ã— (s ï¼[FA] t)

 from-ï¼[FA] : {s t : FA} â†’ s ï¼[FA] t â†’ s ï¼ t
 from-ï¼[FA] {[]}    {[]}    e       = refl
 from-ï¼[FA] {x â€¢ s} {y â€¢ t} (p , q) = apâ‚‚ _â€¢_ (from-ï¼[X] p) (from-ï¼[FA] q)

 to-ï¼[FA] : {s t : FA} â†’ s ï¼ t â†’ s ï¼[FA] t
 to-ï¼[FA] {[]} {[]}       p = â‹†
 to-ï¼[FA] {x â€¢ s} {y â€¢ t} p = to-ï¼[X]  (equal-heads p) ,
                               to-ï¼[FA] (equal-tails p)

\end{code}

The crucial idea for the size reduction of the equivalence relation is
to redefine the relation _â–·_ as follows.

\begin{code}

 _â——_ : FA â†’ FA â†’ ğ“¤ Ì‡
 []          â—— t = ğŸ˜
 (x â€¢ [])    â—— t = ğŸ˜
 (x â€¢ y â€¢ s) â—— t = (y ï¼[X] (x â»)) Ã— (s ï¼[FA] t)

 _â–¶_ : FA â†’ FA â†’ ğ“¤ Ì‡
 []      â–¶ t       = ğŸ˜
 (x â€¢ s) â–¶ []      = (x â€¢ s) â—— []
 (x â€¢ s) â–¶ (y â€¢ t) = ((x â€¢ s) â—— (y â€¢ t)) + (x ï¼[X] y Ã— (s â–¶ t))

 â–¶-lemma : (x y : X) (s : List X) â†’ y ï¼ x â» â†’ (x â€¢ y â€¢ s) â–¶ s
 â–¶-lemma x _ []      refl = to-ï¼[X] {x â»} refl , â‹†
 â–¶-lemma x _ (z â€¢ s) refl = inl (to-ï¼[X]  {x â»} refl ,
                                 to-ï¼[X]  {z}   refl ,
                                 to-ï¼[FA] {s}   refl)
\end{code}

We now show that _â–¶_ defined above is logically equivalent to _â–·_.

\begin{code}

 â–¶-gives-â–· : {s t : FA} â†’ s â–¶ t â†’ s â–· t

 â–¶-gives-â–· {[]} {t} r = ğŸ˜-elim r

 â–¶-gives-â–· {x â€¢ y â€¢ s} {[]} (p , q) = [] , s , x ,
                                      ap (Î» - â†’ x â€¢ - â€¢ s) (from-ï¼[X] p) ,
                                      ((from-ï¼[FA] q)â»Â¹)

 â–¶-gives-â–· {x â€¢ y â€¢ s} {z â€¢ t} (inl (p , q)) = Î³ (from-ï¼[X] p) (from-ï¼[FA] q)
  where
   Î³ : y ï¼ x â» â†’ s ï¼ z â€¢ t â†’ x â€¢ y â€¢ s â–· z â€¢ t
   Î³ p q = [] , s , x , ap (Î» - â†’ x â€¢ (- â€¢ s)) p , (q â»Â¹)

 â–¶-gives-â–· {x â€¢ s} {y â€¢ t} (inr (p , r)) = Î³ (from-ï¼[X] p) IH
  where
   IH : s â–· t
   IH = â–¶-gives-â–· r

   Î³ : x ï¼ y â†’ s â–· t â†’ (x â€¢ s) â–· (y â€¢ t)
   Î³ refl = â€¢-â–· x

 â–·-gives-â–¶ : {s t : FA} â†’ s â–· t â†’ s â–¶ t

 â–·-gives-â–¶ (u , v , x , refl , refl) = f u v x
  where
   f : (u v : FA) (x : X) â†’ (u â—¦ x â€¢ x â» â€¢ v) â–¶ (u â—¦ v)
   f []      []      x = to-ï¼[X] {x â»} refl , â‹†
   f []      (y â€¢ v) x = inl (to-ï¼[X] {x â»} refl , to-ï¼[X] {y} refl , to-ï¼[FA] {v} refl)
   f (y â€¢ u) v       x = inr (to-ï¼[X] {y} refl , f u v x)

\end{code}

The usual way to define the transitive closure of a relation (cf. the
file SRTclosure) applied to the relation _â–¶_ would increase universe
level back to that of the relation _âˆ¾_.

In order to overcome this obstacle, we consider a type of redexes.

\begin{code}

 redex : FA â†’ ğ“¤ Ì‡
 redex []          = ğŸ˜
 redex (x â€¢ [])    = ğŸ˜
 redex (x â€¢ y â€¢ s) = (y ï¼[X] (x â»)) + redex (y â€¢ s)

 reduct : (s : FA) â†’ redex s â†’ FA
 reduct (x â€¢ y â€¢ s) (inl p) = s
 reduct (x â€¢ y â€¢ s) (inr r) = x â€¢ reduct (y â€¢ s) r

\end{code}

The idea behind the above definitions is that we want that the
relation s â–¶ t holds if and only the word t is the reduct of s at some
redex r, which is what we prove next:

\begin{code}

 lemma-reductâ†’ : (s : FA) (r : redex s) â†’ s â–¶ reduct s r
 lemma-reductâ†’ (x â€¢ y â€¢ s) (inl p) = â–¶-lemma x y s (from-ï¼[X] p)
 lemma-reductâ†’ (x â€¢ y â€¢ s) (inr r) = inr (to-ï¼[X] {x} refl ,
                                         lemma-reductâ†’ (y â€¢ s) r)

 lemma-reductâ† : (s t : FA) â†’ s â–¶ t â†’ Î£ r ê‰ redex s , reduct s r ï¼ t
 lemma-reductâ† (x â€¢ [])    (z â€¢ t) (inl ())
 lemma-reductâ† (x â€¢ [])    (z â€¢ t) (inr ())
 lemma-reductâ† (x â€¢ y â€¢ s) []      (p , q)       = inl p , from-ï¼[FA] q
 lemma-reductâ† (x â€¢ y â€¢ s) (z â€¢ t) (inl (p , q)) = inl p , from-ï¼[FA] q
 lemma-reductâ† (x â€¢ y â€¢ s) (z â€¢ t) (inr (p , r)) = inr (prâ‚ IH) ,
                                                   apâ‚‚ _â€¢_ (from-ï¼[X] p) (prâ‚‚ IH)
  where
   IH : Î£ r ê‰ redex (y â€¢ s) , reduct (y â€¢ s) r ï¼ t
   IH = lemma-reductâ† (y â€¢ s) t r

\end{code}

Next we define a type of chains of redexes of length n and a
corresponding notion of reduct for such chains:

\begin{code}

 redex-chain : â„• â†’ FA â†’ ğ“¤ Ì‡
 redex-chain 0        s = ğŸ™
 redex-chain (succ n) s = Î£ r ê‰ redex s , redex-chain n (reduct s r)

 chain-reduct : (s : FA) (n : â„•) â†’ redex-chain n s â†’ FA
 chain-reduct s 0        Ï       = s
 chain-reduct s (succ n) (r , Ï) = chain-reduct (reduct s r) n Ï

 chain-lemmaâ†’ : (s : FA) (n : â„•) (Ï : redex-chain n s) â†’ s â–·[ n ] chain-reduct s n Ï
 chain-lemmaâ†’ s 0        Ï       = refl
 chain-lemmaâ†’ s (succ n) (r , Ï) = reduct s r ,
                                   â–¶-gives-â–· (lemma-reductâ†’ s r) ,
                                   chain-lemmaâ†’ (reduct s r) n Ï

 chain-lemmaâ† : (s t : FA) (n : â„•)
              â†’ s â–·[ n ] t
              â†’ Î£ Ï ê‰ redex-chain n s , chain-reduct s n Ï ï¼ t
 chain-lemmaâ† s t 0        r           = â‹† , r
 chain-lemmaâ† s t (succ n) (u , b , c) = Î³ IH l
  where
   IH : Î£ Ï ê‰ redex-chain n u , chain-reduct u n Ï ï¼ t
   IH = chain-lemmaâ† u t n c

   l : Î£ r ê‰ redex s , reduct s r ï¼ u
   l = lemma-reductâ† s u (â–·-gives-â–¶ b)

   Î³ : type-of IH
     â†’ type-of l
     â†’ Î£ Ï' ê‰ redex-chain (succ n) s , chain-reduct s (succ n) Ï' ï¼ t
   Î³ (Ï , refl) (r , refl) = (r , Ï) , refl

\end{code}

Now notice that the native size of Î·á´³Ê³áµ– is large.

\begin{code}

 open free-group-construction-stepâ‚ pt
 open free-group-construction-stepâ‚‚ fe â„“ sq Î·/-relates-identified-points

 Î·á´³Ê³áµ–-is-large : Î·á´³Ê³áµ– is ğ“¤âº âŠ” â„“ ğ“¤âº small-map
 Î·á´³Ê³áµ–-is-large = native-size-of-map Î·á´³Ê³áµ–

\end{code}

For the application discussed above, we need Î·á´³Ê³áµ– to be ğ“¤ small, or
"tiny", which we achieve applying the above development.

Recall that the function Î·/âˆ¾ : FA â†’ FA/âˆ¾ is the universal map into the
quotient, and, by construction, the universal map Î·á´³Ê³áµ– : A â†’ FA/âˆ¾ into
the free group is the composite Î·/âˆ¾ âˆ˜ Î· where Î· : A â†’ FA is the
insertion of generators before quotienting and Î·/âˆ¾ is the universal
map into the quotient.

We now need to assume that A is a set to be able to proceed.

\begin{code}

 module _ (A-is-set : is-set A) where

  smallness-of-Î·á´³Ê³áµ–-fibers-is-prop : {ğ“¦ : Universe} (y : FA/âˆ¾)
                                   â†’ is-prop (fiber Î·á´³Ê³áµ– y is ğ“¦ small)
  smallness-of-Î·á´³Ê³áµ–-fibers-is-prop y = prop-being-small-is-prop pe' fe'
                                        (fiber Î·á´³Ê³áµ– y)
                                        (Î·á´³Ê³áµ–-is-embedding A-is-set y)

\end{code}

We first discuss the fibers of Î·, then those of Î·/âˆ¾, and finally those
of Î·á´³Ê³áµ–.

The fiber type Î£ a ê‰ A , Î· a ï¼ s lives in the universe ğ“¤âº. In the next
step we construct a copy of this fiber type in the first universe ğ“¤â‚€.

\begin{code}

  NB-native-universe-fiber-Î· : Î· is ğ“¤âº small-map
  NB-native-universe-fiber-Î· = native-size-of-map Î·

  Î·-is-decidable : each-fiber-of Î· is-decidable
  Î·-is-decidable = âˆ˜-decidable-embeddings
                    []-is-embedding
                    pairâ‚€-is-decidable
                    []-is-decidable

  Î·-is-embedding : is-embedding Î·
  Î·-is-embedding = âˆ˜-is-embedding pairâ‚€-is-embedding []-is-embedding

  Î·-has-any-size : (ğ“¦ : Universe) â†’ Î· is ğ“¦ small-map
  Î·-has-any-size ğ“¦ = decidable-embeddings-have-any-size ğ“¦
                       Î·-is-embedding
                       Î·-is-decidable
\end{code}

Using this, next we want to reduce the size of the type
Î£ a ê‰ A , Î· a âˆ¾ s, which we informally refer to as "the âˆ¾-fiber of s
over Î·". First, this type is a proposition:

\begin{code}

  the-âˆ¾-fibers-of-Î·-are-props : (s : FA) â†’ is-prop (Î£ a ê‰ A , Î· a âˆ¾ s)
  the-âˆ¾-fibers-of-Î·-are-props s (a , e) (a' , e') = Î³
   where
    Î± : Î· a âˆ¾ Î· a'
    Î± = psrt-transitive (Î· a) s (Î· a') e (psrt-symmetric (Î· a') s e')

    Î² : a ï¼ a'
    Î² = Î·-identifies-âˆ¾-related-points A-is-set Î±

    Î³ : (a , e) ï¼ (a' , e')
    Î³ = to-subtype-ï¼ (Î» x â†’ âˆ¥âˆ¥-is-prop) Î²

  generator : FA â†’ ğ“¤âº Ì‡
  generator s = Î£ n ê‰ â„• , Î£ Ï ê‰ redex-chain n s , fiber Î· (chain-reduct s n Ï)

  is-generator : FA â†’ ğ“¤âº Ì‡
  is-generator s = âˆ¥ generator s âˆ¥

  being-generator-is-small : (s : FA) â†’ is-generator s is ğ“¤ small
  being-generator-is-small s =
   âˆ¥âˆ¥-is-small pt
    (Î£-is-small
      (native-size â„•)
      (Î» n â†’ Î£-is-small
              (native-size (redex-chain n s))
              (Î» Ï â†’ Î·-has-any-size ğ“¤ (chain-reduct s n Ï))))

  âˆ¾-fiber-Î·-lemmaâ†’ : (s : FA) â†’ (Î£ a ê‰ A , Î· a âˆ¾ s) â†’ is-generator s
  âˆ¾-fiber-Î·-lemmaâ†’ s (a , e) = âˆ¥âˆ¥-functor Î³ e
   where
    Î³ : Î· a âˆ¿ s â†’ generator s
    Î³ e = Î´ (d c)
     where
      c : Î£ u ê‰ FA , (Î· a â–·â‹† u) Ã— (s â–·â‹† u)
      c = from-âˆ¿ Theorem[Church-Rosser] (Î· a) s e

      d : type-of c â†’ Î£ n ê‰ â„• , Î£ Ï ê‰ redex-chain n s , chain-reduct s n Ï ï¼ Î· a
      d (u , r , râ‚) = Î´ râ‚‚
       where
        p : Î· a ï¼ u
        p = Î·-irreducibleâ‹† r

        râ‚‚ : s  â–·â‹† Î· a
        râ‚‚ = transport (s â–·â‹†_) (p â»Â¹) râ‚

        Î´ : s  â–·â‹† Î· a â†’ Î£ n ê‰ â„• , Î£ Ï ê‰ redex-chain n s , chain-reduct s n Ï ï¼ Î· a
        Î´ (n , râ‚ƒ) = (n , chain-lemmaâ† s (Î· a) n râ‚ƒ)

      Î´ : type-of (d c) â†’ generator s
      Î´ (n , Ï , p) = n , Ï , a , (p â»Â¹)

  âˆ¾-fiber-Î·-lemmaâ† : (s : FA) â†’ is-generator s â†’ (Î£ a ê‰ A , Î· a âˆ¾ s)
  âˆ¾-fiber-Î·-lemmaâ† s = âˆ¥âˆ¥-rec (the-âˆ¾-fibers-of-Î·-are-props s) Î³
   where
    Î³ : generator s â†’ (Î£ a ê‰ A , Î· a âˆ¾ s)
    Î³ (n , Ï , i) = Î´ i
     where
      r : s â–·[ n ] chain-reduct s n Ï
      r = chain-lemmaâ†’ s n Ï

      e : chain-reduct s n Ï âˆ¾ s
      e = âˆ£ to-âˆ¿ (chain-reduct s n Ï) s (chain-reduct s n Ï , (0 , refl) , (n , r)) âˆ£

      Î´ : fiber Î· (chain-reduct s n Ï) â†’ Î£ a ê‰ A , Î· a âˆ¾ s
      Î´ (a , p) = a , transport (_âˆ¾ s) (p â»Â¹) e

  âˆ¾-fiber-Î·-lemma : (s : FA) â†’ (Î£ a ê‰ A , Î· a âˆ¾ s) â‰ƒ is-generator s
  âˆ¾-fiber-Î·-lemma s = logically-equivalent-props-are-equivalent
                       (the-âˆ¾-fibers-of-Î·-are-props s)
                       âˆ¥âˆ¥-is-prop
                       (âˆ¾-fiber-Î·-lemmaâ†’ s)
                       (âˆ¾-fiber-Î·-lemmaâ† s)
\end{code}

With this we can reduce the size of the universal map Î·á´³Ê³áµ– down to ğ“¤,
as desired:

\begin{code}

  open general-set-quotients-exist sq

  fiber-Î·/âˆ¾-lemma : (a : A) (s : FA) â†’ (Î·/âˆ¾ (Î· a) ï¼ Î·/âˆ¾ s) â‰ƒ (Î· a âˆ¾ s)
  fiber-Î·/âˆ¾-lemma a s = logically-equivalent-props-are-equivalent
                         (/-is-set -âˆ¾-)
                         âˆ¥âˆ¥-is-prop
                         Î·/âˆ¾-relates-identified-points
                         Î·/âˆ¾-identifies-related-points

  fiber-Î·Î·á´³Ê³áµ–-lemma : (s : FA) â†’ fiber Î·á´³Ê³áµ– (Î·/âˆ¾ s) â‰ƒ is-generator s
  fiber-Î·Î·á´³Ê³áµ–-lemma s =
   (Î£ a ê‰ A , Î·/âˆ¾ (Î· a) ï¼ Î·/âˆ¾ s) â‰ƒâŸ¨ Î£-cong (Î» a â†’ fiber-Î·/âˆ¾-lemma a s) âŸ©
   (Î£ a ê‰ A , Î· a âˆ¾ s)            â‰ƒâŸ¨ âˆ¾-fiber-Î·-lemma s âŸ©
   is-generator s                 â– 

  the-Î·á´³Ê³áµ–-fibers-of-equivalence-classes-are-tiny : (s : FA)
                                                  â†’ fiber Î·á´³Ê³áµ– (Î·/âˆ¾ s) is ğ“¤ small
  the-Î·á´³Ê³áµ–-fibers-of-equivalence-classes-are-tiny s =
   smallness-closed-under-â‰ƒ'
    (being-generator-is-small s)
    (fiber-Î·Î·á´³Ê³áµ–-lemma s)

  Î·á´³Ê³áµ–-is-tiny : Î·á´³Ê³áµ– is ğ“¤ small-map
  Î·á´³Ê³áµ–-is-tiny = /-induction -âˆ¾-
                  smallness-of-Î·á´³Ê³áµ–-fibers-is-prop
                  the-Î·á´³Ê³áµ–-fibers-of-equivalence-classes-are-tiny
\end{code}

This concludes the proof of Theoremâ‚.

\begin{code}

Theoremâ‚[large-free-groups-from-set-quotients] {ğ“¤} fe pe sq A A-ls =
 record
  { ğ“• = ğ“•
  ; Î· = Î·á´³Ê³áµ–
  ; universality = extension-to-free-group-uniqueness
  ; Î·-is-embedding = Î·-free-group-is-embedding
  ; Î·-is-small = Î·á´³Ê³áµ–-is-tiny
  }
 where
  pt : propositional-truncations-exist
  pt = propositional-truncations-from-set-quotients sq fe

  open general-set-quotients-exist sq
  open free-group-construction A
  open free-group-construction-stepâ‚ pt
  open free-group-construction-stepâ‚‚ fe (Î» ğ“¤ â†’ ğ“¤) sq (effectivity fe pe sq)
  open FreeGroupInterface pt fe (Î» ğ“¤ â†’ ğ“¤) sq (effectivity fe pe sq) A
  open resize-universal-map fe pe pt
        A
        IdâŸ¦ A-ls âŸ§
        (Î» _ â†’ âŸ¦ A-ls âŸ§-refl)
        (Î» _ _ â†’ ï¼âŸ¦ A-ls âŸ§-gives-ï¼)
        (Î» ğ“¤ â†’ ğ“¤)
        sq
        (effectivity fe pe sq)

\end{code}

We now use the constructions in the module
resize-universal-map to prove Theoremâ‚‚.

\begin{code}

module resize-free-group
        (fe : Fun-Ext)
        (pe : Prop-Ext)
        (pt : propositional-truncations-exist)
        {ğ“¤        : Universe}
        (A        : ğ“¤ âº Ì‡)
        (_ï¼â‚€_    : A â†’ A â†’ ğ“¤ Ì‡ )
        (reflâ‚€    : (a : A) â†’ a ï¼â‚€ a)
        (from-ï¼â‚€ : (a b : A) â†’ a ï¼â‚€ b â†’ a ï¼ b)
       where

 open FreeGroupInterface pt fe (_âº)
  (large-set-quotients pt fe pe)
  (large-effective-set-quotients pt fe pe)

 open resize-universal-map fe pe pt A _ï¼â‚€_ reflâ‚€ from-ï¼â‚€ (_âº)
  (large-set-quotients pt fe pe)
  (large-effective-set-quotients pt fe pe)

 open free-group-construction A

\end{code}

Using the results of the module resize-universal-map, we
obtain a relation _â‰_ whose propositional truncation is logically
equivalent to the equivalence relation _âˆ¾_ used to quotient FA to get
the group freely generated by A. The relation _âˆ¾_ itself is the
propositional truncation of a suitable relation _âˆ¿_, which we now use
for that purpose.

\begin{code}

 _â‰_ : FA â†’ FA â†’ ğ“¤ Ì‡
 s â‰ t = Î£ m ê‰ â„• ,
         Î£ n ê‰ â„• ,
         Î£ Ï ê‰ redex-chain m s ,
         Î£ Ïƒ ê‰ redex-chain n t , chain-reduct s m Ï  ï¼[FA] chain-reduct t n Ïƒ

 â‰-gives-âˆ¿ : (s t : FA) â†’ s â‰ t â†’ s âˆ¿ t
 â‰-gives-âˆ¿ s t (m , n , Ï , Ïƒ , p) = Î³
  where
   a : s â–·â‹† chain-reduct s m Ï
   a = m , chain-lemmaâ†’ s m Ï

   b : t â–·â‹† chain-reduct t n Ïƒ
   b = n , chain-lemmaâ†’ t n Ïƒ

   c : Î£ u ê‰ FA , (s â–·â‹† u) Ã— (t â–·â‹† u)
   c = chain-reduct t n Ïƒ  , transport (s â–·â‹†_) (from-ï¼[FA] p) a , b

   Î³ : s âˆ¿ t
   Î³ = to-âˆ¿ s t c

 âˆ¿-gives-â‰ : (s t : FA) â†’ s âˆ¿ t â†’ s â‰ t
 âˆ¿-gives-â‰ s t e = Î³ a
  where
   a : Î£ u ê‰ FA , (s â–·â‹† u) Ã— (t â–·â‹† u)
   a = from-âˆ¿ Theorem[Church-Rosser] s t e

   Î³ : type-of a â†’ s â‰ t
   Î³ (u , (m , Ï) , (n , Ïƒ)) = Î´ b c
    where
     b : Î£ Ï ê‰ redex-chain m s , chain-reduct s m Ï ï¼ u
     b = chain-lemmaâ† s u m Ï

     c : Î£ Ïƒ ê‰ redex-chain n t , chain-reduct t n Ïƒ ï¼ u
     c = chain-lemmaâ† t u n Ïƒ

     Î´ : type-of b â†’ type-of c â†’ s â‰ t
     Î´ (Ï , p) (Ïƒ , q) = m , n , Ï , Ïƒ , to-ï¼[FA] (p âˆ™ q â»Â¹)

 open free-group-construction-stepâ‚ pt

 _âˆ¥â‰âˆ¥_ : FA â†’ FA â†’ ğ“¤ Ì‡
 s âˆ¥â‰âˆ¥ t = âˆ¥ s â‰ t âˆ¥

 âˆ¾-is-logically-equivalent-to-âˆ¥â‰âˆ¥ : (s t : FA) â†’ s âˆ¾ t â†” s âˆ¥â‰âˆ¥ t
 âˆ¾-is-logically-equivalent-to-âˆ¥â‰âˆ¥ s t = âˆ¥âˆ¥-functor (âˆ¿-gives-â‰ s t) ,
                                       âˆ¥âˆ¥-functor (â‰-gives-âˆ¿ s t)
\end{code}

And so we also get a type equivalence, because logically equivalent
propositions are equivalent types:

\begin{code}

 âˆ¿-is-equivalent-to-âˆ¥â‰âˆ¥ : (s t : FA) â†’ (s âˆ¾ t) â‰ƒ (s âˆ¥â‰âˆ¥ t)
 âˆ¿-is-equivalent-to-âˆ¥â‰âˆ¥ s t =
  logically-equivalent-props-are-equivalent
   âˆ¥âˆ¥-is-prop
   âˆ¥âˆ¥-is-prop
   (lr-implication (âˆ¾-is-logically-equivalent-to-âˆ¥â‰âˆ¥ s t))
   (rl-implication (âˆ¾-is-logically-equivalent-to-âˆ¥â‰âˆ¥ s t))

 open free-group-construction-stepâ‚‚ fe (_âº)
  (large-set-quotients pt fe pe)
  (large-effective-set-quotients pt fe pe)

 -âˆ¥â‰âˆ¥- : EqRel {ğ“¤âº} {ğ“¤} FA
 -âˆ¥â‰âˆ¥- = _âˆ¥â‰âˆ¥_ , is-equiv-rel-transport _âˆ¾_ _âˆ¥â‰âˆ¥_ (Î» s t â†’ âˆ¥âˆ¥-is-prop)
                 âˆ¾-is-logically-equivalent-to-âˆ¥â‰âˆ¥ âˆ¾-is-equiv-rel
\end{code}

Hence we conclude that FA/âˆ¾ â‰ƒ FA/âˆ¥â‰âˆ¥. What is crucial for our purposes
is that FA/âˆ¥â‰âˆ¥ lives in the lower universe ğ“¤âº, as opposed to the
original quotient FA/âˆ¾, which lives in the higher universe ğ“¤âºâº.

\begin{code}

 open general-set-quotients-exist (large-set-quotients pt fe pe)

 FA/âˆ¥â‰âˆ¥ : ğ“¤âº Ì‡
 FA/âˆ¥â‰âˆ¥ = FA / -âˆ¥â‰âˆ¥-

 FA/âˆ¾-to-FA/âˆ¥â‰âˆ¥ : FA/âˆ¾ â‰ƒ FA/âˆ¥â‰âˆ¥
 FA/âˆ¾-to-FA/âˆ¥â‰âˆ¥ = quotients-equivalent FA -âˆ¾- -âˆ¥â‰âˆ¥-
                  (Î» {s} {t} â†’ âˆ¾-is-logically-equivalent-to-âˆ¥â‰âˆ¥ s t)

 private
  native-universe-of-free-group : ğ“¤âºâº Ì‡
  native-universe-of-free-group = âŸ¨ free-group A âŸ©

 resized-free-group-carrier : âŸ¨ free-group A âŸ© is ğ“¤âº small
 resized-free-group-carrier = Î³
  where
   Î³ : Î£ F ê‰ ğ“¤âº Ì‡ , F â‰ƒ âŸ¨ free-group A âŸ©
   Î³ = FA/âˆ¥â‰âˆ¥ , â‰ƒ-sym FA/âˆ¾-to-FA/âˆ¥â‰âˆ¥

\end{code}

The following relies on transporting group structures along
equivalences, which is implemented in the module Group.Type
(unfortunately, one cannot apply univalence for that purpose, because
the types live in different universes and hence one can't form their
identity type, and so this transport has to be done manually).

NB. If we assume cumulativity in our type theory, the above transport
can be done with univalence directly. TODO. Write down the proof here
in mathematical vernacular (and perhaps also in Agda using --cumulativity).

We conclude with a routine applications of the above development.

\begin{code}

 small-free-group : Î£ ğ“•' ê‰ Group ğ“¤âº , ğ“•' â‰… ğ“•
 small-free-group = group-copy ğ“• resized-free-group-carrier

 ğ“•â» : Group ğ“¤âº
 ğ“•â» = prâ‚ small-free-group

 ğ•œ : ğ“•â» â‰… ğ“•
 ğ•œ = prâ‚‚ small-free-group

 k : âŸ¨ ğ“•â» âŸ© â‰ƒ âŸ¨ ğ“• âŸ©
 k = â‰…-to-â‰ƒ ğ“•â» ğ“• ğ•œ

 k-is-hom : is-hom ğ“•â»  ğ“• âŒœ k âŒ
 k-is-hom = â‰…-to-â‰ƒ-is-hom ğ“•â» ğ“• ğ•œ

 Î·â» : A â†’ âŸ¨ ğ“•â» âŸ©
 Î·â» = âŒœ k âŒâ»Â¹ âˆ˜ Î·á´³Ê³áµ–

 universalityâ» : {ğ“¦ : Universe} (ğ“– : Group ğ“¦) (f : A â†’ âŸ¨ ğ“– âŸ©)
               â†’ âˆƒ! fÌ… ê‰ (âŸ¨ ğ“•â» âŸ© â†’ âŸ¨ ğ“– âŸ©)
                      , is-hom ğ“•â» ğ“– fÌ…
                      Ã— fÌ… âˆ˜ Î·â» âˆ¼ f
 universalityâ» ğ“– f =
  equiv-to-singleton I (extension-to-free-group-uniqueness A ğ“– f)
  where
   I : (Î£ g ê‰ (âŸ¨ ğ“•â» âŸ© â†’ âŸ¨ ğ“– âŸ©) , is-hom ğ“•â» ğ“– g  Ã—  g âˆ˜ Î·â» âˆ¼ f)
     â‰ƒ (Î£ h ê‰ (âŸ¨ ğ“• âŸ©  â†’ âŸ¨ ğ“– âŸ©) , is-hom ğ“•  ğ“– h  Ã—  h âˆ˜ Î·á´³Ê³áµ– âˆ¼ f)
   I = qinveq Ï• (Ïˆ , ÏˆÏ• , Ï•Ïˆ)
    where
     Ï• : (Î£ g ê‰ (âŸ¨ ğ“•â» âŸ© â†’ âŸ¨ ğ“– âŸ©) , is-hom ğ“•â» ğ“– g Ã— g âˆ˜ Î·â» âˆ¼ f)
       â†’ (Î£ h ê‰ (âŸ¨ ğ“• âŸ© â†’ âŸ¨ ğ“– âŸ©) , is-hom ğ“• ğ“– h Ã— h âˆ˜ Î·á´³Ê³áµ– âˆ¼ f)
     Ï• (g , i , e) = g âˆ˜ âŒœ k âŒâ»Â¹ ,
                     âˆ˜-is-hom ğ“• ğ“•â» ğ“– âŒœ k âŒâ»Â¹ g
                       (inverses-are-homs' ğ“•â» ğ“• k k-is-hom)
                       i ,
                     e

     Ïˆ : codomain Ï• â†’ domain Ï•
     Ïˆ (h , j , d) =  h âˆ˜ âŒœ k âŒ ,
                      âˆ˜-is-hom ğ“•â» ğ“• ğ“– âŒœ k âŒ h k-is-hom j ,
                      d'
      where
       d' : (a : A) â†’ h (âŒœ k âŒ (Î·â» a)) ï¼ f a
       d' a = h (âŒœ k âŒ (Î·â» a))             ï¼âŸ¨ refl âŸ©
              h (âŒœ k âŒ (âŒœ k âŒâ»Â¹ (Î·á´³Ê³áµ– a))) ï¼âŸ¨ III âŸ©
              h (Î·á´³Ê³áµ– a)                   ï¼âŸ¨ d a âŸ©
              f a                          âˆ
        where
         III = ap h (inverses-are-sections' k (Î·á´³Ê³áµ– a))

     Ï•Ïˆ : Ï• âˆ˜ Ïˆ âˆ¼ id
     Ï•Ïˆ (h , j , d) = to-subtype-ï¼
                       (Î» f â†’ Ã—-is-prop
                               (being-hom-is-prop fe ğ“• ğ“– f)
                               (Î -is-prop fe (Î» _ â†’ groups-are-sets ğ“–)))
                       (dfunext fe (Î» x â†’ ap h (inverses-are-sections' k x)))

     ÏˆÏ• : Ïˆ âˆ˜ Ï• âˆ¼ id
     ÏˆÏ• (g , i , e) = to-subtype-ï¼
                       (Î» f â†’ Ã—-is-prop
                               (being-hom-is-prop fe ğ“•â» ğ“– f)
                               (Î -is-prop fe (Î» _ â†’ groups-are-sets ğ“–)))
                       (dfunext fe (Î» y â†’ ap g (inverses-are-retractions' k y)))

 Î·â»-is-embedding : is-set A â†’ is-embedding Î·â»
 Î·â»-is-embedding i = âˆ˜-is-embedding
                      (Î·-free-group-is-embedding A i)
                      (equivs-are-embeddings' (â‰ƒ-sym k))


 Î·â»-is-large : Î·á´³Ê³áµ– is ğ“¤âºâº small-map
 Î·â»-is-large = native-size-of-map Î·á´³Ê³áµ–

 âŒœkâŒâ»Â¹-is-tiny : âŒœ k âŒâ»Â¹ is ğ“¤ small-map
 âŒœkâŒâ»Â¹-is-tiny = equivs-have-any-size' (â‰ƒ-sym k)

 Î·â»-is-tiny : is-set A â†’ Î·â» is ğ“¤ small-map
 Î·â»-is-tiny i = âˆ˜-small-maps (Î·á´³Ê³áµ–-is-tiny i) âŒœkâŒâ»Â¹-is-tiny

\end{code}

This concludes the proof of Theoremâ‚‚.

\begin{code}

Theoremâ‚‚[free-groups-of-large-locally-small-types] {ğ“¤} pt fe pe A A-ls =
 record
  { ğ“• = ğ“•â»
  ; Î· = Î·â»
  ; universality = universalityâ»
  ; Î·-is-embedding = Î·â»-is-embedding
  ; Î·-is-small = Î·â»-is-tiny
  }
 where
  open resize-free-group fe pe pt
        A
        IdâŸ¦ A-ls âŸ§
        (Î» _ â†’ âŸ¦ A-ls âŸ§-refl)
        (Î» _ _ â†’ ï¼âŸ¦ A-ls âŸ§-gives-ï¼)

\end{code}
