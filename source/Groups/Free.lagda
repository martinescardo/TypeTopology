Martin Escardo
January - February 2021.

In collaboration with Marc Bezem, Thierry Coquand and Peter Dybjer

We construct free groups in HoTT/UF in Agda without HIT's other than
propositional truncation, and with no consequence of univalence other
than function extensionality and propositional extensionality.

This is based on the book "A course in constructive algebra" by Ray
Mines, Fred Richman and Wim Ruitenburg, 1988. In particular, this
construction shows that the inclusion of generators is injective (and
hence an embedding in the sense of HoTT/UF). It is noteworthy and
surprising that the set of generators is not required to have
decidable equality.

This is part of Martin Escardo's Agda development TypeTopology,
whose philosophy is to be Spartan. At the moment we are a little bit
Athenian, though, with the use of Agda lists rather than Spartan-MLTT
constructed lists, although we intend to fix this in the future. (The
way to do it is already present in the module Fin.lagda.)

\begin{code}

{-# OPTIONS --safe --without-K --lossy-unification #-}

module Groups.Free where

open import Groups.Type
open import MLTT.Spartan
open import Quotient.Type
open import UF.Embeddings
open import UF.FunExt
open import UF.PropTrunc
open import UF.Sets
open import UF.Subsingletons

\end{code}

In the following definition, the set A of generators lives in the
universe ğ“¤, the group freely generated by A is required to live in the
universe ğ“¥, and the universal propertly eliminates into any universe ğ“¦.
That the universal map Î· into the free group is an embedding if A is a
set is not part of the definition of freely generated group, but we
have it and we need it, and so we find it convenient to include it in
our definition.

\begin{code}

record freely-generated-group-exists (A : ğ“¤ Ì‡ ) (ğ“¥ : Universe) : ğ“¤Ï‰ where
 field
  ğ“• : Group ğ“¥
  Î· : A â†’ âŸ¨ ğ“• âŸ©
  universality : {ğ“¦ : Universe} (ğ“– : Group ğ“¦) (f : A â†’ âŸ¨ ğ“– âŸ©)
               â†’ âˆƒ! fÌ… ê‰ (âŸ¨ ğ“• âŸ© â†’ âŸ¨ ğ“– âŸ©)
                      , is-hom ğ“• ğ“– fÌ…
                      Ã— fÌ… âˆ˜ Î· âˆ¼ f
  Î·-is-embedding : is-set A â†’ is-embedding Î·

\end{code}

Notice that we don't need to assume that the type A of generators is a
set to construct the free group and establish its universal
property. But if A is a set then the universal map Î· is automatically
and embedding.

We first formulate the main theorems and corollaries of this files
before proving therem.

\begin{code}

general-free-groups-exist
  : propositional-truncations-exist
  â†’ Fun-Ext
  â†’ (â„“ : Universe â†’ Universe)
  â†’ (sq : general-set-quotients-exist â„“)
  â†’ are-effective sq
  â†’ (A : ğ“¤ Ì‡ ) â†’ freely-generated-group-exists A (ğ“¤ âŠ” â„“ ğ“¤)

\end{code}

In our applications, we are interested in â„“ = id and â„“ = (_âº) and we
are interested in the following corollaries, which don't mention â„“.

The first one assumes the small set quotients exist and derives their
effectivity from functional and propositional extensionality to get
that small free groups exist, choosing â„“ = id.

\begin{code}

open import Quotient.Effectivity

small-free-groups-exist
  : propositional-truncations-exist
  â†’ Fun-Ext
  â†’ Prop-Ext
  â†’ set-quotients-exist
  â†’ (A : ğ“¤ Ì‡ ) â†’ freely-generated-group-exists A ğ“¤
small-free-groups-exist pt fe pe sq =
 general-free-groups-exist pt fe id sq (effectivity fe pe sq)

\end{code}

The second one assumes set replacement to construct quotients, and
again uses â„“ = id.

\begin{code}

open import Quotient.FromSetReplacement
open import UF.Size

small-free-groups-exist'
  : (pt : propositional-truncations-exist)
  â†’ Set-Replacement pt
  â†’ Fun-Ext
  â†’ Prop-Ext
  â†’ (A : ğ“¤ Ì‡ ) â†’ freely-generated-group-exists A ğ“¤
small-free-groups-exist' pt sr fe pe =
 general-free-groups-exist pt fe id
  (set-quotients-from-set-replacement pt fe pe sr)
  (set-replacement-gives-effective-set-quotients pt fe pe sr)

\end{code}

Notice that set replacement (defined in UF.Size) is equivalent to the
existence of small quotients in the presence of propositions
truncations and functional and propositional extensionality:

\begin{code}

private
 module _ (pt : propositional-truncations-exist)
          (fe : Fun-Ext)
          (pe : Prop-Ext)
        where

  open import Quotient.GivesSetReplacement

  remarkâ†’ : Set-Replacement pt â†’ set-quotients-exist
  remarkâ†’ = set-quotients-from-set-replacement pt fe pe

  remarkâ† : set-quotients-exist â†’ Set-Replacement pt
  remarkâ† sq = set-replacement-from-set-quotients-and-prop-trunc sq pt

\end{code}

The third one drops set replacement, but instead constructs freely
generated groups, with â„“ = (_âº).

\begin{code}

open import Quotient.Large

large-free-groups-exist
  : propositional-truncations-exist
  â†’ Fun-Ext
  â†’ Prop-Ext
  â†’ (A : ğ“¤ Ì‡ ) â†’ freely-generated-group-exists A (ğ“¤ âº)
large-free-groups-exist pt fe pe =
 general-free-groups-exist pt fe (_âº)
  (large-set-quotients pt fe pe)
  (large-effective-set-quotients pt fe pe)

\end{code}

The fourth one is the observation that univalence and propositional
truncations suffice to construct large free groups.

\begin{code}

open import UF.UA-FunExt
open import UF.Univalence

large-free-groups-exist'
  : Univalence
  â†’ propositional-truncations-exist
  â†’ (A : ğ“¤ Ì‡ ) â†’ freely-generated-group-exists A (ğ“¤ âº)
large-free-groups-exist' ua pt =
 large-free-groups-exist pt
  (Univalence-gives-Fun-Ext ua)
  (Univalence-gives-Prop-Ext ua)

\end{code}

We also prove the following, which is not a corollary of the above
theorem but instead requires a careful enhancement of its proof.

\begin{code}

free-groups-of-large-locally-small-types
  : propositional-truncations-exist
  â†’ Fun-Ext
  â†’ Prop-Ext
  â†’ (A : ğ“¤ âº Ì‡)
  â†’ is-locally-small A
  â†’ freely-generated-group-exists A (ğ“¤ âº)

\end{code}

This means that if A is large and only small, we can construct the
group freely generated by A in the same universe as A, assuming only
propositional truncations and functional and propositional
extensionality.

We now proceed to construct the group freely generated by a set A. The
set-hood requirement is needed later only, and so we don't include it
as an assumption in the following anonymous module:

\begin{code}

open import MLTT.List
open import MLTT.Two
open import MLTT.Two-Properties
open import UF.Base
open import UF.Subsingletons-FunExt

module free-group-construction
        {ğ“¤ : Universe}
        (A : ğ“¤ Ì‡ )
       where

 X : ğ“¤ Ì‡
 X = ğŸš Ã— A

 _â» : X â†’ X
 (n , a)â» = (complement n , a)

 inv-invol : (x : X) â†’ (x â»)â» ï¼ x
 inv-invol (n , a) = ap (_, a) (complement-involutive n)

\end{code}

The idea is that list concatenation _++_ will be the group operation
after suitable quotienting, with the empty list [] as the neutral
element.

We will quotient the following type FA to get the undelying type of
the free group:

\begin{code}

 FA : ğ“¤ Ì‡
 FA = List X

 Î· : A â†’ FA
 Î· a = [ (â‚€ , a) ]

\end{code}

The type ğŸš has two elements â‚€ and â‚, and a prefix â‚ to an element a of
the type A means it is formally inverted. So in the inclusion of
generators Î· we indicate that the element a is not inverted by
prefixing it with â‚€.

We will quotient by the equivalence relation generated by the
following reduction relation:

\begin{code}

 _â–·_ : FA â†’ FA â†’ ğ“¤ Ì‡
 s â–· t = Î£ u ê‰ FA , Î£ v ê‰ FA , Î£ x ê‰ X , (s ï¼ u ++ [ x ] ++ [ x â» ] ++ v)
                                       Ã— (t ï¼ u ++ v)

 infix 1 _â–·_

 âˆ·-â–· : {s t : FA} (x : X) â†’ s â–· t â†’ x âˆ· s â–· x âˆ· t
 âˆ·-â–· x (u , v , y , p , q) = (x âˆ· u) , v , y , ap (x âˆ·_) p , ap (x âˆ·_) q

\end{code}

The following is a lemma for the Church-Rosser property, proved by
induction on uâ‚€ and uâ‚:

\begin{code}

 church-rosser : (uâ‚€ vâ‚€ uâ‚ vâ‚ : FA) (xâ‚€ xâ‚ : X)

               â†’ uâ‚€ ++  [ xâ‚€ ] ++ [ xâ‚€ â» ] ++ vâ‚€
               ï¼ uâ‚ ++  [ xâ‚ ] ++ [ xâ‚ â» ] ++ vâ‚

               â†’ (uâ‚€ ++ vâ‚€ ï¼ uâ‚ ++ vâ‚)
               + (Î£ t ê‰ FA , (uâ‚€ ++ vâ‚€ â–· t) Ã— (uâ‚ ++ vâ‚ â–· t))

 church-rosser uâ‚€ vâ‚€ uâ‚ vâ‚ xâ‚€ xâ‚ = f uâ‚€ uâ‚
  where
   f : (uâ‚€ uâ‚ : FA)
     â†’ uâ‚€ ++  [ xâ‚€ ] ++ [ xâ‚€ â» ] ++ vâ‚€ ï¼ uâ‚ ++  [ xâ‚ ] ++ [ xâ‚ â» ] ++ vâ‚
     â†’ (uâ‚€ ++ vâ‚€ ï¼ uâ‚ ++ vâ‚) + (Î£ t ê‰ FA , (uâ‚€ ++ vâ‚€ â–· t) Ã— (uâ‚ ++ vâ‚ â–· t))

   f [] [] p = inl Î³
    where
     have : xâ‚€ âˆ· xâ‚€ â»  âˆ· vâ‚€
          ï¼ xâ‚ âˆ· xâ‚ â»  âˆ· vâ‚
     have = p

     Î³ : vâ‚€ ï¼ vâ‚
     Î³ = equal-tails (equal-tails p)

   f [] (yâ‚ âˆ· []) p = inl Î³
    where
     have : xâ‚€ âˆ· xâ‚€ â» âˆ· vâ‚€
          ï¼ yâ‚ âˆ· xâ‚   âˆ· xâ‚ â» âˆ· vâ‚
     have = p

     q = xâ‚ â»    ï¼âŸ¨ ap _â» ((equal-heads (equal-tails p))â»Â¹) âŸ©
         (xâ‚€ â»)â» ï¼âŸ¨ inv-invol xâ‚€ âŸ©
         xâ‚€      ï¼âŸ¨ equal-heads p âŸ©
         yâ‚      âˆ

     r : vâ‚€ ï¼ xâ‚ â» âˆ· vâ‚
     r = equal-tails (equal-tails p)

     Î³ : vâ‚€ ï¼ yâ‚ âˆ· vâ‚
     Î³ = transport (Î» - â†’ vâ‚€ ï¼ - âˆ· vâ‚) q r

   f [] (yâ‚ âˆ· zâ‚ âˆ· uâ‚) p = inr Î³
    where
     have : xâ‚€ âˆ· xâ‚€ â» âˆ· vâ‚€
          ï¼ yâ‚ âˆ· zâ‚   âˆ· uâ‚ ++ [ xâ‚ ] ++ [ xâ‚ â» ] ++ vâ‚
     have = p

     d' : uâ‚ ++ [ xâ‚ ] ++ [ xâ‚ â» ] ++ vâ‚ â–· uâ‚ ++ vâ‚
     d' = uâ‚ , vâ‚ , xâ‚ , refl , refl

     p' : uâ‚ ++ [ xâ‚ ] ++ [ xâ‚ â» ] ++ vâ‚ ï¼ vâ‚€
     p' = (equal-tails (equal-tails p))â»Â¹

     d : vâ‚€ â–· uâ‚ ++ vâ‚
     d = transport (_â–· uâ‚ ++ vâ‚) p' d'

     q = yâ‚ â» ï¼âŸ¨ (ap (_â») (equal-heads p)â»Â¹) âŸ©
         xâ‚€ â» ï¼âŸ¨ equal-heads (equal-tails p) âŸ©
         zâ‚   âˆ

     e' : yâ‚ âˆ· yâ‚ â» âˆ· uâ‚ ++ vâ‚ â–· uâ‚ ++ vâ‚
     e' = [] , (uâ‚ ++ vâ‚) , yâ‚ , refl , refl

     e : yâ‚ âˆ· zâ‚ âˆ· uâ‚ ++ vâ‚ â–· uâ‚ ++ vâ‚
     e = transport (Î» - â†’ yâ‚ âˆ· - âˆ· uâ‚ ++ vâ‚ â–· uâ‚ ++ vâ‚) q e'

     Î³ : Î£ t ê‰ FA , (vâ‚€ â–· t) Ã— (yâ‚ âˆ· zâ‚ âˆ· uâ‚ ++ vâ‚ â–· t)
     Î³ = (uâ‚ ++ vâ‚) , d , e

   f (yâ‚€ âˆ· []) [] p = inl Î³
    where
     have : yâ‚€ âˆ· xâ‚€   âˆ· xâ‚€ â» âˆ· vâ‚€
          ï¼ xâ‚ âˆ· xâ‚ â» âˆ· vâ‚
     have = p

     Î³ = yâ‚€ âˆ· vâ‚€      ï¼âŸ¨ ap (_âˆ· vâ‚€) (equal-heads p) âŸ©
         xâ‚ âˆ· vâ‚€      ï¼âŸ¨ ap (_âˆ· vâ‚€) ((inv-invol xâ‚)â»Â¹) âŸ©
         (xâ‚ â»)â» âˆ· vâ‚€ ï¼âŸ¨ ap (Î» - â†’ - â» âˆ· vâ‚€) ((equal-heads (equal-tails p))â»Â¹) âŸ©
         xâ‚€ â» âˆ· vâ‚€    ï¼âŸ¨ equal-tails (equal-tails p) âŸ©
         vâ‚           âˆ

   f (yâ‚€ âˆ· zâ‚€ âˆ· uâ‚€) [] p = inr Î³
    where
     have : yâ‚€ âˆ· zâ‚€   âˆ· uâ‚€ ++ [ xâ‚€ ] ++ [ xâ‚€ â» ] ++ vâ‚€
          ï¼ xâ‚ âˆ· xâ‚ â» âˆ· vâ‚
     have = p

     q = yâ‚€ â» ï¼âŸ¨ ap (_â») (equal-heads p) âŸ©
         xâ‚ â» ï¼âŸ¨ (equal-heads (equal-tails p))â»Â¹ âŸ©
         zâ‚€   âˆ

     d' : yâ‚€ âˆ· yâ‚€ â» âˆ· uâ‚€ ++ vâ‚€ â–· uâ‚€ ++ vâ‚€
     d' = [] , (uâ‚€ ++ vâ‚€) , yâ‚€ , refl , refl

     d : yâ‚€ âˆ· zâ‚€ âˆ· uâ‚€ ++ vâ‚€ â–· uâ‚€ ++ vâ‚€
     d = transport (Î» - â†’ yâ‚€ âˆ· - âˆ· uâ‚€ ++ vâ‚€ â–· uâ‚€ ++ vâ‚€) q d'

     e' : uâ‚€ ++ [ xâ‚€ ] ++ [ xâ‚€ â» ] ++ vâ‚€ â–· uâ‚€ ++ vâ‚€
     e' = uâ‚€ , vâ‚€ , xâ‚€ , refl , refl

     e : vâ‚ â–· uâ‚€ ++ vâ‚€
     e = transport (_â–· uâ‚€ ++ vâ‚€) (equal-tails (equal-tails p)) e'

     Î³ : Î£ t ê‰ FA , (yâ‚€ âˆ· zâ‚€ âˆ· uâ‚€ ++ vâ‚€ â–· t) Ã— (vâ‚ â–· t)
     Î³ = (uâ‚€ ++ vâ‚€) , d , e

   f (yâ‚€ âˆ· uâ‚€) (yâ‚ âˆ· uâ‚) p = Î³
    where
     have : yâ‚€ âˆ· uâ‚€ ++ [ xâ‚€ ] ++ [ xâ‚€ â» ] ++ vâ‚€
          ï¼ yâ‚ âˆ· uâ‚ ++ [ xâ‚ ] ++ [ xâ‚ â» ] ++ vâ‚
     have = p

     IH : (uâ‚€ ++ vâ‚€ ï¼ uâ‚ ++ vâ‚) + (Î£ t ê‰ FA , (uâ‚€ ++ vâ‚€ â–· t) Ã— (uâ‚ ++ vâ‚ â–· t))
     IH = f uâ‚€ uâ‚ (equal-tails p)

     Î“ : X â†’ X â†’ ğ“¤ Ì‡
     Î“ yâ‚€ yâ‚ = (yâ‚€ âˆ· uâ‚€ ++ vâ‚€ ï¼ yâ‚ âˆ· uâ‚ ++ vâ‚)
             + (Î£ t ê‰ FA , (yâ‚€ âˆ· uâ‚€ ++ vâ‚€ â–· t) Ã— (yâ‚ âˆ· uâ‚ ++ vâ‚ â–· t))

     Î´ : type-of IH â†’ âˆ€ {yâ‚€ yâ‚} â†’ yâ‚€ ï¼ yâ‚ â†’ Î“ yâ‚€ yâ‚
     Î´ (inl q)           {yâ‚€} refl = inl (ap (yâ‚€ âˆ·_) q)
     Î´ (inr (t , d , e)) {yâ‚€} refl = inr ((yâ‚€ âˆ· t) , âˆ·-â–· yâ‚€ d , âˆ·-â–· yâ‚€ e)

     Î³ : Î“ yâ‚€ yâ‚
     Î³ = Î´ IH (equal-heads p)

 Church-Rosser : (s tâ‚€ tâ‚ : FA)
               â†’ s â–· tâ‚€
               â†’ s â–· tâ‚
               â†’ (tâ‚€ ï¼ tâ‚) + (Î£ t ê‰ FA , (tâ‚€ â–· t) Ã— (tâ‚ â–· t))
 Church-Rosser s tâ‚€ tâ‚ (uâ‚€ , vâ‚€ , xâ‚€ , pâ‚€ , qâ‚€) (uâ‚ , vâ‚ , xâ‚ , pâ‚ , qâ‚) = Î³ Î´
  where
   have-pâ‚€ : s ï¼ uâ‚€ ++ [ xâ‚€ ] ++ [ xâ‚€ â» ] ++ vâ‚€
   have-pâ‚€ = pâ‚€

   have-pâ‚ : s ï¼ uâ‚ ++ [ xâ‚ ] ++ [ xâ‚ â» ] ++ vâ‚
   have-pâ‚ = pâ‚

   have-qâ‚€ : tâ‚€ ï¼ uâ‚€ ++ vâ‚€
   have-qâ‚€ = qâ‚€

   have-qâ‚ : tâ‚ ï¼ uâ‚ ++ vâ‚
   have-qâ‚ = qâ‚

   Î´ : (uâ‚€ ++ vâ‚€ ï¼ uâ‚ ++ vâ‚) + (Î£ t ê‰ FA , (uâ‚€ ++ vâ‚€ â–· t) Ã— (uâ‚ ++ vâ‚ â–· t))
   Î´ = church-rosser uâ‚€ vâ‚€ uâ‚ vâ‚ xâ‚€ xâ‚
        (uâ‚€ ++ [ xâ‚€ ] ++ [ xâ‚€ â» ] ++ vâ‚€ ï¼âŸ¨ pâ‚€ â»Â¹ âŸ©
         s                              ï¼âŸ¨ pâ‚ âŸ©
         uâ‚ ++ [ xâ‚ ] ++ [ xâ‚ â» ] ++ vâ‚ âˆ)

   Î³ : type-of Î´ â†’ (tâ‚€ ï¼ tâ‚) + (Î£ t ê‰ FA , (tâ‚€ â–· t) Ã— (tâ‚ â–· t))
   Î³ (inl q)             = inl (tâ‚€       ï¼âŸ¨ qâ‚€ âŸ©
                                uâ‚€ ++ vâ‚€ ï¼âŸ¨ q âŸ©
                                uâ‚ ++ vâ‚ ï¼âŸ¨ qâ‚ â»Â¹ âŸ©
                                tâ‚       âˆ)
   Î³ (inr (t , pâ‚€ , pâ‚)) = inr (t , Iâ‚€ , Iâ‚)
    where
     Iâ‚€ : tâ‚€ â–· t
     Iâ‚€ = transport (_â–· t) (qâ‚€ â»Â¹) pâ‚€

     Iâ‚ : tâ‚ â–· t
     Iâ‚ = transport (_â–· t) (qâ‚ â»Â¹) pâ‚

\end{code}

It is noteworthy and remarkable that the above doesn't need decidable
equality on A. We repeat that this construction is due to Mines,
Richman and Ruitenburg.

The following import defines

  _â—â–·_       the symmetric closure of _â–·_,
  _âˆ¿_        the symmetric, reflexive, transitive closure of _â–·_,
  _â–·*_       the reflexive, transitive closure of _â–·_,
  _â–·[ n ]_   the n-fold iteration of _â–·_.
  _â—â–·[ n ]_  the n-fold iteration of _â—â–·_.

and its submodule Church-Rosser-consequences develops some useful
consequences of the Church-Rosser property in a general setting.

\begin{code}

 open import Relations.SRTclosure public
 open import Relations.ChurchRosser {ğ“¤} {ğ“¤} _â–·_ public

\end{code}

The insertion of generators is trivially left cancellable before
quotienting:

\begin{code}

 Î·-lc : {a b : A} â†’ Î· a ï¼ Î· b â†’ a ï¼ b
 Î·-lc refl = refl

\end{code}

The following less trivial result, which relies on the Church-Rosser
property, will give that the insertion of generators is injective
after quotienting:

\begin{code}

 Î·-irreducible : {a : A} {s : FA} â†’ Â¬ (Î· a â–· s)
 Î·-irreducible ((x âˆ· []) , v , y , () , refl)
 Î·-irreducible ((x âˆ· y âˆ· u) , v , z , () , q)

 Î·-irreducibleâ‹† : {a : A} {s : FA} â†’ Î· a â–·â‹† s â†’ Î· a ï¼ s
 Î·-irreducibleâ‹† {a} {s} (n , r) = f n r
  where
   f : (n : â„•) â†’ Î· a â–·[ n ] s â†’ Î· a ï¼ s
   f zero     refl = refl
   f (succ n) (t , r , i) = ğŸ˜-elim (Î·-irreducible r)

 Î·-identifies-âˆ¿-related-points : {a b : A} â†’ Î· a âˆ¿ Î· b â†’ a ï¼ b
 Î·-identifies-âˆ¿-related-points {a} {b} e = Î·-lc p
  where
   Ïƒ : Î£ s ê‰ FA , (Î· a â–·â‹† s) Ã— (Î· b â–·â‹† s)
   Ïƒ = from-âˆ¿ Church-Rosser (Î· a) (Î· b) e
   s = prâ‚ Ïƒ

   p = Î· a ï¼âŸ¨  Î·-irreducibleâ‹† (prâ‚ (prâ‚‚ Ïƒ)) âŸ©
       s   ï¼âŸ¨ (Î·-irreducibleâ‹† (prâ‚‚ (prâ‚‚ Ïƒ)))â»Â¹ âŸ©
       Î· b âˆ

\end{code}

We need to work with the propositional truncation of _âˆ¿_ to construct
the free group, but most of the work will be done before truncation.

The following is for reasoning with chains of equivalences _âˆ¿_:

\begin{code}

 _âˆ¿âŸ¨_âŸ©_ : (s : FA) {t u : FA} â†’ s âˆ¿ t â†’ t âˆ¿ u â†’ s âˆ¿ u
 _ âˆ¿âŸ¨ p âŸ© q = srt-transitive _â–·_ _ _ _ p q

 _âˆ¿âˆ : (s : FA) â†’ s âˆ¿ s
 _âˆ¿âˆ _ = srt-reflexive _â–·_ _

 infixr 0 _âˆ¿âŸ¨_âŸ©_
 infix  1 _âˆ¿âˆ

 ï¼-gives-âˆ¿ : {s s' : FA} â†’ s ï¼ s' â†’ s âˆ¿ s'
 ï¼-gives-âˆ¿ {s} refl = srt-reflexive _â–·_ s

\end{code}

As discussed above, the group operation before quotienting is simply
concatenation, with the empty list as the neutral element.

Concatenation is a left congruence. We establish this in several
steps:

\begin{code}

 ++-â–·-left : (s s' t : FA) â†’ s â–· s' â†’ s ++ t â–· s' ++ t
 ++-â–·-left s s' t (u , v , x , p , q) = u , (v ++ t) , x , p' , q'
  where
   p' = s ++ t                            ï¼âŸ¨ ap (_++ t) p âŸ©
        (u ++ [ x ] ++ [ x â» ] ++ v) ++ t ï¼âŸ¨ ++-assoc u _ t âŸ©
        u ++ [ x ] ++ [ x â» ] ++ v ++ t   âˆ

   q' = s' ++ t       ï¼âŸ¨ ap (_++ t) q âŸ©
        (u ++ v) ++ t ï¼âŸ¨ ++-assoc u v t âŸ©
        u ++ v ++ t   âˆ

 ++-â—â–·-left : (s s' t : FA) â†’ s â—â–· s' â†’ s ++ t â—â–· s' ++ t
 ++-â—â–·-left s s' t (inl a) = inl (++-â–·-left s s' t a)
 ++-â—â–·-left s s' t (inr a) = inr (++-â–·-left s' s t a)

 ++-iteration-left : (s s' t : FA) (n : â„•)
                   â†’ s â—â–·[ n ] s'
                   â†’ s ++ t â—â–·[ n ] s' ++ t
 ++-iteration-left s s  t zero     refl        = refl
 ++-iteration-left s s' t (succ n) (u , b , c) = (u ++ t) ,
                                                 ++-â—â–·-left s u t b ,
                                                 ++-iteration-left u s' t n c

 ++-cong-left : (s s' t : FA) â†’ s âˆ¿ s' â†’ s ++ t âˆ¿ s' ++ t
 ++-cong-left s s' t (n , a) = n , ++-iteration-left s s' t n a

\end{code}

It is also a right congruence:

\begin{code}

 âˆ·-â—â–· : (x : X) {s t : FA} â†’ s â—â–· t â†’ x âˆ· s â—â–· x âˆ· t
 âˆ·-â—â–· x (inl e) = inl (âˆ·-â–· x e)
 âˆ·-â—â–· x (inr e) = inr (âˆ·-â–· x e)

 âˆ·-iteration : (x : X) {s t : FA} (n : â„•)
             â†’ s â—â–·[ n ] t
             â†’ x âˆ· s â—â–·[ n ] x âˆ· t
 âˆ·-iteration x zero refl = refl
 âˆ·-iteration x (succ n) (u , b , c) = (x âˆ· u) , âˆ·-â—â–· x b , âˆ·-iteration x n c

 âˆ·-cong : (x : X) {s t : FA} â†’ s âˆ¿ t â†’ x âˆ· s âˆ¿ x âˆ· t
 âˆ·-cong x (n , a) = n , âˆ·-iteration x n a

 ++-cong-right : (s {t t'} : FA) â†’ t âˆ¿ t' â†’ s ++ t âˆ¿ s ++ t'
 ++-cong-right []      e = e
 ++-cong-right (x âˆ· s) e = âˆ·-cong x (++-cong-right s e)

\end{code}

And therefore it is a two-sided congruence:

\begin{code}

 ++-cong-âˆ¿ : {s s' t t' : FA} â†’ s âˆ¿ s' â†’ t âˆ¿ t' â†’ s ++ t âˆ¿ s' ++ t'
 ++-cong-âˆ¿ {s} {s'} {t} {t'} d e = s ++ t   âˆ¿âŸ¨ ++-cong-left s s' t d âŸ©
                                   s' ++ t  âˆ¿âŸ¨ ++-cong-right s' e âŸ©
                                   s' ++ t' âˆ¿âˆ
\end{code}

We now construct the group inverse before quotienting. We reverse the
given list and formally invert all its elements:

\begin{code}

 finv : FA â†’ FA
 finv [] = []
 finv (x âˆ· s) = finv s ++ [ x â» ]

\end{code}

It is a congruence, which is proved in several steps:

\begin{code}

 finv-++ : (s t : FA) â†’ finv (s ++ t) ï¼ finv t ++ finv s
 finv-++ []      t = []-right-neutral (finv t)
 finv-++ (x âˆ· s) t = finv (s ++ t) ++ [ x â» ]      ï¼âŸ¨ IH âŸ©
                     (finv t ++ finv s) ++ [ x â» ] ï¼âŸ¨ a âŸ©
                     finv t ++ (finv s ++ [ x â» ]) âˆ
  where
   IH = ap (_++ [ x â» ]) (finv-++ s t)
   a  = ++-assoc (finv t) (finv s) [ x â» ]

 finv-â–· : {s t : FA} â†’ s â–· t â†’ finv s â–· finv t
 finv-â–· {s} {t} (u , v , y , p , q) = finv v , finv u , y , p' , q'
  where
   p' = finv s                                      ï¼âŸ¨ I âŸ©
        finv (u ++ [ y ] ++ [ y â» ] ++ v)           ï¼âŸ¨ II âŸ©
        finv ([ y ] ++ [ y â» ] ++ v) ++ finv u      ï¼âŸ¨ III âŸ©
        finv (([ y ] ++ [ y â» ]) ++ v) ++ finv u    ï¼âŸ¨ IV âŸ©
        (finv v ++ [ (y â»)â» ] ++ [ y â» ]) ++ finv u ï¼âŸ¨ V âŸ©
        (finv v ++ [ y ] ++ [ y â» ]) ++ finv u      ï¼âŸ¨ VI âŸ©
        finv v ++ [ y ] ++ [ y â» ] ++ finv u        âˆ
    where
     I   = ap finv p
     II  = finv-++ u ([ y ] ++ [ y â» ] ++ v)
     III = ap (Î» - â†’ finv - ++ finv u) ((++-assoc [ y ] [ y â» ] v)â»Â¹)
     IV  = ap (_++ finv u) (finv-++ ([ y ] ++ [ y â» ]) v)
     V   = ap (Î» - â†’ (finv v ++ [ - ] ++ [ y â» ]) ++ finv u) (inv-invol y)
     VI  = ++-assoc (finv v) ([ y ] ++ [ y â» ]) (finv u)

   q' = finv t          ï¼âŸ¨ ap finv q âŸ©
        finv (u ++ v)   ï¼âŸ¨ finv-++ u v âŸ©
        finv v ++ finv u âˆ

 finv-â—â–· : {s t : FA} â†’ s â—â–· t â†’ finv s â—â–· finv t
 finv-â—â–· (inl e) = inl (finv-â–· e)
 finv-â—â–· (inr e) = inr (finv-â–· e)

 finv-iteration : {s t : FA} (n : â„•)
                â†’ s â—â–·[ n ] t
                â†’ finv s â—â–·[ n ] finv t
 finv-iteration zero refl = refl
 finv-iteration (succ n) (u , b , c) = finv u , finv-â—â–· b , finv-iteration n c

 finv-cong-âˆ¿ : {s t : FA} â†’ s âˆ¿ t â†’ finv s âˆ¿ finv t
 finv-cong-âˆ¿ (n , a) = n , finv-iteration n a

\end{code}

The inverse really is an inverse:

\begin{code}

 finv-lemma-right : (x : X) â†’ [ x ] ++ [ x â» ] âˆ¿ []
 finv-lemma-right x = srt-extension _â–·_ _ [] ([] , [] , x , refl , refl)

 finv-lemma-left : (x : X) â†’ [ x â» ] ++ [ x ] âˆ¿ []
 finv-lemma-left x = srt-extension _â–·_ _ _
                      ([] ,
                       [] ,
                       (x â») ,
                       ap (Î» - â†’ [ x â» ] ++ [ - ]) ((inv-invol x)â»Â¹) , refl)

 finv-right-âˆ¿ : (s : FA) â†’ s ++ finv s âˆ¿ []
 finv-right-âˆ¿ []      = srt-reflexive _â–·_ []
 finv-right-âˆ¿ (x âˆ· s) = Î³
  where
   IH : s ++ finv s âˆ¿ []
   IH = finv-right-âˆ¿ s

   Î³ = [ x ] ++ s ++ finv s ++ [ x â» ]   âˆ¿âŸ¨ I âŸ©
       [ x ] ++ (s ++ finv s) ++ [ x â» ] âˆ¿âŸ¨ II âŸ©
       [ x ] ++ [ x â» ]                  âˆ¿âŸ¨ III âŸ©
       []                                âˆ¿âˆ
    where
     I   = ï¼-gives-âˆ¿  (ap (x âˆ·_) (++-assoc s (finv s) [ x â» ])â»Â¹)
     II  = ++-cong-right [ x ] (++-cong-left _ _ _ IH)
     III = finv-lemma-right x

 finv-left-âˆ¿ : (s : FA) â†’ finv s ++ s âˆ¿ []
 finv-left-âˆ¿ []      = srt-reflexive _â–·_ []
 finv-left-âˆ¿ (x âˆ· s) = Î³
  where
   Î³ = (finv s ++ [ x â» ]) ++ (x âˆ· s)    âˆ¿âŸ¨ I âŸ©
       finv s ++ ([ x â» ] ++ [ x ] ++ s) âˆ¿âŸ¨ II âŸ©
       finv s ++ ([ x â» ] ++ [ x ]) ++ s âˆ¿âŸ¨ III âŸ©
       finv s ++ s                       âˆ¿âŸ¨ IV âŸ©
       []                                âˆ¿âˆ
    where
     I   = ï¼-gives-âˆ¿ (++-assoc (finv s) [ x â» ] (x âˆ· s))
     II  = ï¼-gives-âˆ¿ (ap (finv s ++_) ((++-assoc [ x â» ] [ x ] s)â»Â¹))
     III = ++-cong-right (finv s) (++-cong-left _ _ _ (finv-lemma-left x))
     IV  = finv-left-âˆ¿ s

\end{code}

The propositional, symmetric, reflexive, transitive closure of _â–·_:

\begin{code}

 module free-group-construction-stepâ‚
         (pt : propositional-truncations-exist)
        where

  open PropositionalTruncation pt public

  _âˆ¾_ : FA â†’ FA â†’ ğ“¤ Ì‡
  x âˆ¾ y = âˆ¥ x âˆ¿ y âˆ¥

  infix 1 _âˆ¾_

  Î·-identifies-âˆ¾-related-points : {a b : A} â†’ is-set A â†’ Î· a âˆ¾ Î· b â†’ a ï¼ b
  Î·-identifies-âˆ¾-related-points i = âˆ¥âˆ¥-rec i Î·-identifies-âˆ¿-related-points

  ++-cong : {s s' t t' : FA} â†’ s âˆ¾ s' â†’ t âˆ¾ t' â†’ s ++ t âˆ¾ s' ++ t'
  ++-cong = âˆ¥âˆ¥-functorâ‚‚ ++-cong-âˆ¿

  finv-cong : {s t : FA} â†’ s âˆ¾ t â†’ finv s âˆ¾ finv t
  finv-cong = âˆ¥âˆ¥-functor finv-cong-âˆ¿

  finv-right : (s : FA) â†’ s ++ finv s âˆ¾ []
  finv-right s = âˆ£ finv-right-âˆ¿ s âˆ£

  finv-left : (s : FA) â†’ finv s ++ s âˆ¾ []
  finv-left s = âˆ£ finv-left-âˆ¿ s âˆ£

\end{code}

To perform the quotient, we assume functional and propositional
extensionality.

\begin{code}

  module free-group-construction-stepâ‚‚
          (fe : Fun-Ext)
          (â„“ : Universe â†’ Universe)
          (sq : general-set-quotients-exist â„“)
          (Î·/-relates-identified-points : are-effective sq)
        where

   ğ“¤Ì… : Universe
   ğ“¤Ì… = ğ“¤ âŠ” â„“ ğ“¤

\end{code}

We work with quotients constructed in the module Quotient.Large using
functional extensionality and propositional extensionality, and no
higher-inductive types other than propositional truncation:

\begin{code}

   open general-set-quotients-exist sq
   open psrt pt _â–·_ public

\end{code}

We have that _âˆ¾_ is an equivalence relation:

\begin{code}

   âˆ¾-is-equiv-rel : is-equiv-rel _âˆ¾_
   âˆ¾-is-equiv-rel = psrt-is-equiv-rel

   -âˆ¾- : EqRel FA
   -âˆ¾- = _âˆ¾_ , âˆ¾-is-equiv-rel

\end{code}

The acronym "psrt" stands for propositional, reflexive, symmetric and
transitive closure of a relation, in this case _â–·_.

Our quotients constructed via propositional truncation increase
universe levels:

\begin{code}

   FA/âˆ¾ : ğ“¤Ì…  Ì‡
   FA/âˆ¾ = FA / -âˆ¾-

   Î·/âˆ¾ : FA â†’ FA/âˆ¾
   Î·/âˆ¾ = Î·/ -âˆ¾-

\end{code}

The above function Î·/âˆ¾ is the universal map into the quotient.

The insertion of generators of the free group is obtained by composing
the universal map into the quotient with our original map Î· : A â†’ FA
that inserts the generators into the freely generated "pre-group" of
lists.

\begin{code}

   Î·á´³Ê³áµ– : A â†’ FA/âˆ¾
   Î·á´³Ê³áµ– a = Î·/âˆ¾ (Î· a)

\end{code}

It is noteworthy, and what we wanted to know, constructively, that the
inclusion of generators in the free group is an injection, or a
left-cancellable map:

\begin{code}

   Î·/âˆ¾-relates-identified-points : {s t : FA} â†’ Î·/âˆ¾ s ï¼ Î·/âˆ¾ t â†’ s âˆ¾ t
   Î·/âˆ¾-relates-identified-points = Î·/-relates-identified-points -âˆ¾-

   Î·á´³Ê³áµ–-lc : is-set A â†’ {a b : A} â†’ Î·á´³Ê³áµ– a ï¼ Î·á´³Ê³áµ– b â†’ a ï¼ b
   Î·á´³Ê³áµ–-lc i p = Î·-identifies-âˆ¾-related-points i
                  (Î·/âˆ¾-relates-identified-points p)

   Î·á´³Ê³áµ–-is-embedding : is-set A â†’ is-embedding Î·á´³Ê³áµ–
   Î·á´³Ê³áµ–-is-embedding i = lc-maps-into-sets-are-embeddings Î·á´³Ê³áµ–
                          (Î·á´³Ê³áµ–-lc i)
                          (/-is-set -âˆ¾-)

   Î·/âˆ¾-identifies-related-points : {s t : FA} â†’ s âˆ¾ t â†’ Î·/âˆ¾ s ï¼ Î·/âˆ¾ t
   Î·/âˆ¾-identifies-related-points = Î·/-identifies-related-points -âˆ¾-

\end{code}

We now need to make FA/âˆ¾ into a group. We will use "/" in names to
indicate constructions on the quotient type FA/âˆ¾.

\begin{code}

   e/ : FA/âˆ¾
   e/ = Î·/âˆ¾ []

   inv/ : FA/âˆ¾ â†’ FA/âˆ¾
   inv/ = extensionâ‚/ -âˆ¾- finv finv-cong

   _Â·_ : FA/âˆ¾ â†’ FA/âˆ¾ â†’ FA/âˆ¾
   _Â·_ = extensionâ‚‚/ -âˆ¾- _++_ ++-cong

\end{code}

The following two naturality conditions are crucial:

\begin{code}

   inv/-natural : (s : FA) â†’ inv/ (Î·/âˆ¾ s) ï¼ Î·/âˆ¾ (finv s)
   inv/-natural = naturality/ -âˆ¾- finv finv-cong

   Â·-natural : (s t : FA) â†’ Î·/âˆ¾ s Â· Î·/âˆ¾ t ï¼ Î·/âˆ¾ (s ++ t)
   Â·-natural = naturalityâ‚‚/ -âˆ¾- _++_ ++-cong

\end{code}

Next, to prove the groups laws, we use quotient induction "/-induction".

One can think of elements of FA/âˆ¾ as equivalence classes, and of Î·/âˆ¾ s
as the equivalence class of s. Then quotient induction says that in
order to prove a property of equivalence classes, it is enough to
prove it for all equivalence classes of given elements (this is proved
in the module Quotient.Type).

The following proofs rely on the above naturality conditions:

\begin{code}

   ln/ : left-neutral e/ _Â·_
   ln/ = /-induction -âˆ¾- (Î» _ â†’ /-is-set -âˆ¾-) Î³
    where
     Î³ : (s : FA) â†’ Î·/âˆ¾ [] Â· Î·/âˆ¾ s ï¼ Î·/âˆ¾ s
     Î³ = Â·-natural []

   rn/ : right-neutral e/ _Â·_
   rn/ = /-induction -âˆ¾- (Î» _ â†’ /-is-set -âˆ¾-) Î³
    where
     Î³ : (s : FA) â†’ Î·/âˆ¾ s Â· Î·/âˆ¾ [] ï¼ Î·/âˆ¾ s
     Î³ s = Î·/âˆ¾ s Â· Î·/âˆ¾ [] ï¼âŸ¨ Â·-natural s [] âŸ©
           Î·/âˆ¾ (s ++ [])  ï¼âŸ¨ ap Î·/âˆ¾ ([]-right-neutral s â»Â¹) âŸ©
           Î·/âˆ¾ s          âˆ

   invl/ : (x : FA/âˆ¾) â†’ inv/ x Â· x ï¼ e/
   invl/ = /-induction -âˆ¾- (Î» _ â†’ /-is-set -âˆ¾-) Î³
    where
     Î³ : (s : FA) â†’ inv/ (Î·/âˆ¾ s) Â· Î·/âˆ¾ s ï¼ e/
     Î³ s = inv/ (Î·/âˆ¾ s) Â· Î·/âˆ¾ s  ï¼âŸ¨ ap (_Â· Î·/âˆ¾ s) (inv/-natural s) âŸ©
           Î·/âˆ¾ (finv s) Â· Î·/âˆ¾ s  ï¼âŸ¨ Â·-natural (finv s) s âŸ©
           Î·/âˆ¾ (finv s ++ s)     ï¼âŸ¨ Î·/âˆ¾-identifies-related-points (finv-left s) âŸ©
           Î·/âˆ¾ []                ï¼âŸ¨ refl âŸ©
           e/                    âˆ

   invr/ : (x : FA/âˆ¾) â†’ x Â· inv/ x ï¼ e/
   invr/ = /-induction -âˆ¾- (Î» _ â†’ /-is-set -âˆ¾-) Î³
    where
     Î³ : (s : FA) â†’ Î·/âˆ¾ s Â· inv/ (Î·/âˆ¾ s) ï¼ e/
     Î³ s = Î·/âˆ¾ s Â· inv/ (Î·/âˆ¾ s)  ï¼âŸ¨ ap (Î·/âˆ¾ s Â·_) (inv/-natural s) âŸ©
           Î·/âˆ¾ s Â· Î·/âˆ¾ (finv s)  ï¼âŸ¨ Â·-natural s (finv s) âŸ©
           Î·/âˆ¾ (s ++ finv s)     ï¼âŸ¨ Î·/âˆ¾-identifies-related-points (finv-right s) âŸ©
           Î·/âˆ¾ []                ï¼âŸ¨ refl âŸ©
           e/                    âˆ

   assoc/ : associative _Â·_
   assoc/ = /-induction -âˆ¾-
             (Î» x â†’ Î â‚‚-is-prop fe (Î» y z â†’ /-is-set -âˆ¾-))
             (Î» s â†’ /-induction -âˆ¾-
                      (Î» y â†’ Î -is-prop fe (Î» z â†’ /-is-set -âˆ¾-))
                      (Î» t â†’ /-induction -âˆ¾-
                               (Î» z â†’ /-is-set -âˆ¾-)
                               (Î³ s t)))
          where
           Î³ : (s t u : FA) â†’ (Î·/âˆ¾ s Â· Î·/âˆ¾ t) Â· Î·/âˆ¾ u ï¼ Î·/âˆ¾ s Â· (Î·/âˆ¾ t Â· Î·/âˆ¾ u)
           Î³ s t u = (Î·/âˆ¾ s Â· Î·/âˆ¾ t) Â· Î·/âˆ¾ u ï¼âŸ¨ ap (_Â· Î·/âˆ¾ u) (Â·-natural s t) âŸ©
                 Î·/âˆ¾ (s ++ t) Â· Î·/âˆ¾ u    ï¼âŸ¨ Â·-natural (s ++ t) u âŸ©
                 Î·/âˆ¾ ((s ++ t) ++ u)     ï¼âŸ¨ ap Î·/âˆ¾ (++-assoc s t u) âŸ©
                 Î·/âˆ¾ (s ++ (t ++ u))     ï¼âŸ¨ (Â·-natural s (t ++ u))â»Â¹ âŸ©
                 Î·/âˆ¾ s Â· Î·/âˆ¾ (t ++ u)    ï¼âŸ¨ ap (Î·/âˆ¾ s Â·_) ((Â·-natural t u)â»Â¹) âŸ©
                 Î·/âˆ¾ s Â· (Î·/âˆ¾ t Â· Î·/âˆ¾ u) âˆ
\end{code}

So we have constructed a group with underlying set FA/âˆ¾ and a map
Î·á´³Ê³áµ– : A â†’ FA/âˆ¾. We now put everyhing together:

\begin{code}

   ğ“• : Group ğ“¤Ì…
   ğ“• = (FA/âˆ¾ , _Â·_ , /-is-set -âˆ¾- , assoc/ , e/ , ln/ , rn/ ,
        (Î» x â†’ inv/ x , invl/ x , invr/ x))
\end{code}

To prove that Î·á´³Ê³áµ– is the universal map of the set A into a group, we
assume another group G with a map f : A â†’ G:

\begin{code}

   module free-group-construction-stepâ‚ƒ
            {ğ“¥ : Universe}
            (G : ğ“¥ Ì‡ )
            (G-is-set : is-set G)
            (e : G)
            (invG : G â†’ G)
            (_*_ : G â†’ G â†’ G)
            (G-ln : left-neutral e _*_)
            (G-rn : right-neutral e _*_)
            (G-invl : (g : G) â†’ invG g * g ï¼ e)
            (G-invr : (g : G) â†’ g * invG g ï¼ e)
            (G-assoc : associative _*_)
            (f : A â†’ G)
         where

    ğ“– : Group ğ“¥
    ğ“– = (G , _*_ ,
         G-is-set , G-assoc , e , G-ln , G-rn ,
         (Î» x â†’ invG x , G-invl x , G-invr x))

\end{code}

Our objective is to construct fÌ… from f making the universality
triangle commute. As a first step in the construction of fÌ…, we
construct a map h by induction of lists:

\begin{code}

    h : FA â†’ G
    h [] = e
    h ((â‚€ , a) âˆ· s) = f a * h s
    h ((â‚ , a) âˆ· s) = invG (f a) * h s

\end{code}

We need the following property of h with respect to formal inverses:

\begin{code}

    hâ» : (x : X) â†’ h ([ x ] ++ [ x â» ]) ï¼ e

    hâ» (â‚€ , a) = f a * (invG (f a) * e) ï¼âŸ¨ ap (f a *_) (G-rn (invG (f a))) âŸ©
                 f a * invG (f a)       ï¼âŸ¨ G-invr (f a) âŸ©
                 e                      âˆ

    hâ» (â‚ , a) = invG (f a) * (f a * e) ï¼âŸ¨ ap (invG (f a) *_) (G-rn (f a)) âŸ©
                 invG (f a) * f a       ï¼âŸ¨ G-invl (f a) âŸ©
                 e                      âˆ
\end{code}

By construction, the function h is a list homomorphism. It is also a
monoid homomorphism (it would be a group homomorphism if FA were a
group, which it isn't):

\begin{code}

    h-is-hom : (s t : FA) â†’ h (s ++ t) ï¼ h s * h t

    h-is-hom [] t =
     h  t    ï¼âŸ¨ (G-ln (h t))â»Â¹ âŸ©
     e * h t âˆ

    h-is-hom ((â‚€ , a) âˆ· s) t =
     f a * h (s ++ t)    ï¼âŸ¨ ap (f a *_) (h-is-hom s t) âŸ©
     f a * (h s * h t)   ï¼âŸ¨ (G-assoc (f a) (h s) (h t))â»Â¹ âŸ©
     (f a * h s) * h t   ï¼âŸ¨ refl âŸ©
     h (â‚€ , a âˆ· s) * h t âˆ

    h-is-hom (â‚ , a âˆ· s) t =
     invG (f a) * h (s ++ t)  ï¼âŸ¨ ap (invG (f a) *_) (h-is-hom s t) âŸ©
     invG (f a) * (h s * h t) ï¼âŸ¨ (G-assoc (invG (f a)) (h s) (h t))â»Â¹ âŸ©
     (invG (f a) * h s) * h t ï¼âŸ¨ refl âŸ©
     h (â‚ , a âˆ· s) * h t      âˆ

\end{code}

We also need the following property of the map h in order to construct
our desired group homomorphism fÌ…:

\begin{code}

    h-identifies-â–·-related-points : {s t : FA} â†’ s â–· t â†’ h s ï¼ h t
    h-identifies-â–·-related-points {s} {t} (u , v , y , p , q) =
       h s ï¼âŸ¨ ap h p âŸ©
       h (u ++ [ y ] ++ [ y â» ] ++ v) ï¼âŸ¨ h-is-hom u ([ y ] ++ [ y â» ] ++ v) âŸ©
       h u * h (y âˆ· y â» âˆ· v)          ï¼âŸ¨ ap (h u *_) (h-is-hom (y âˆ· y â» âˆ· []) v) âŸ©
       h u * (h (y âˆ· y â» âˆ· []) * h v) ï¼âŸ¨ ap (Î» - â†’ h u * (- * h v)) (hâ» y) âŸ©
       h u * (e * h v)                ï¼âŸ¨ ap (h u *_) (G-ln (h v)) âŸ©
       h u * h v                      ï¼âŸ¨ (h-is-hom u v)â»Â¹ âŸ©
       h (u ++ v)                     ï¼âŸ¨ ap h (q â»Â¹) âŸ©
       h t                            âˆ

    h-identifies-â–·â‹†-related-points : {s t : FA} â†’ s â–·â‹† t â†’ h s ï¼ h t
    h-identifies-â–·â‹†-related-points {s} {t} (n , r) = Î³ n s t r
     where
      Î³ : (n : â„•) (s t : FA) â†’ s â–·[ n ] t â†’ h s ï¼ h t
      Î³ zero s s refl  = refl
      Î³ (succ n) s t (u , r , i) = h s ï¼âŸ¨ h-identifies-â–·-related-points r âŸ©
                                   h u ï¼âŸ¨ Î³ n u t i âŸ©
                                   h t âˆ

    h-identifies-âˆ¾-related-points : {s t : FA} â†’ s âˆ¾ t â†’ h s ï¼ h t
    h-identifies-âˆ¾-related-points {s} {t} e = Î³
     where
      Î´ : (Î£ u ê‰ FA , (s â–·â‹† u) Ã— (t â–·â‹† u)) â†’ h s ï¼ h t
      Î´ (u , Ïƒ , Ï„) = h s ï¼âŸ¨ (h-identifies-â–·â‹†-related-points Ïƒ) âŸ©
                      h u ï¼âŸ¨ (h-identifies-â–·â‹†-related-points Ï„)â»Â¹ âŸ©
                      h t âˆ
      Î³ : h s ï¼ h t
      Î³ = âˆ¥âˆ¥-rec G-is-set Î´ (âˆ¥âˆ¥-functor (from-âˆ¿ Church-Rosser s t) e)

\end{code}

We can then finally construct the unique homorphism fÌ… extending f
using the universal property of quotients, using the above map h:

\begin{code}

    fÌ… : FA/âˆ¾ â†’ G
    fÌ… = mediating-map/ -âˆ¾- G-is-set h h-identifies-âˆ¾-related-points

    fÌ…-/triangle : fÌ… âˆ˜ Î·/âˆ¾ âˆ¼ h
    fÌ…-/triangle = universality-triangle/ -âˆ¾- G-is-set h h-identifies-âˆ¾-related-points

\end{code}

And from this we get the triangle for the universal property of the
free group:

\begin{code}

    fÌ…-triangle : fÌ… âˆ˜ Î·á´³Ê³áµ– âˆ¼ f
    fÌ…-triangle a = fÌ… (Î·/âˆ¾ (Î· a)) ï¼âŸ¨ fÌ…-/triangle (Î· a) âŸ©
                    h (Î· a)      ï¼âŸ¨ refl âŸ©
                    f a * e      ï¼âŸ¨ G-rn (f a) âŸ©
                    f a          âˆ

\end{code}

Which is a group homomorphism (rather than merely a monoid
homomorphism like h):

\begin{code}

    fÌ…-is-hom : is-hom ğ“• ğ“– fÌ…
    fÌ…-is-hom {x} {y} = Î³ x y
     where
      Î´ : (s t : FA) â†’ fÌ… (Î·/âˆ¾ s Â· Î·/âˆ¾ t) ï¼ fÌ… (Î·/âˆ¾ s) * fÌ… (Î·/âˆ¾ t)
      Î´ s t = fÌ… (Î·/âˆ¾ s Â· Î·/âˆ¾ t)     ï¼âŸ¨ I âŸ©
              fÌ… (Î·/âˆ¾ (s ++ t))      ï¼âŸ¨ II âŸ©
              h (s ++ t)            ï¼âŸ¨ III âŸ©
              h s * h t             ï¼âŸ¨ IV âŸ©
              fÌ… (Î·/âˆ¾ s) * fÌ… (Î·/âˆ¾ t) âˆ
        where
         I   = ap fÌ… (Â·-natural s t)
         II  = fÌ…-/triangle (s ++ t)
         III = h-is-hom s t
         IV  = apâ‚‚ _*_ ((fÌ…-/triangle s)â»Â¹) ((fÌ…-/triangle t)â»Â¹)

      Î³ : (x y : FA / -âˆ¾-) â†’ fÌ… (x Â· y) ï¼ fÌ… x * fÌ… y
      Î³ = /-induction -âˆ¾-
           (Î» x â†’ Î -is-prop fe (Î» y â†’ G-is-set))
           (Î» s â†’ /-induction -âˆ¾-
                   (Î» a â†’ G-is-set)
                   (Î´ s))
\end{code}

Notice that for the following uniqueness property of fÌ… we don't need
to assume that fâ‚€ and fâ‚ are group homomorphisms:

\begin{code}

    fÌ…-uniqueness-âˆ¾ : (fâ‚€ fâ‚ : FA/âˆ¾ â†’ G) â†’ fâ‚€ âˆ˜ Î·/âˆ¾ âˆ¼ h â†’ fâ‚ âˆ˜ Î·/âˆ¾ âˆ¼ h â†’ fâ‚€ âˆ¼ fâ‚
    fÌ…-uniqueness-âˆ¾ fâ‚€ fâ‚ p q = at-most-one-mediating-map/ -âˆ¾-
                                G-is-set fâ‚€ fâ‚ (Î» s â†’ p s âˆ™ (q s)â»Â¹)

\end{code}

But for this one we do:

\begin{code}

    fÌ…-uniqueness' : (fâ‚€ fâ‚ : FA/âˆ¾ â†’ G)
                  â†’ is-hom ğ“• ğ“– fâ‚€
                  â†’ is-hom ğ“• ğ“– fâ‚
                  â†’ fâ‚€ âˆ˜ Î·á´³Ê³áµ– âˆ¼ f
                  â†’ fâ‚ âˆ˜ Î·á´³Ê³áµ– âˆ¼ f
                  â†’ fâ‚€ âˆ¼ fâ‚
    fÌ…-uniqueness' fâ‚€ fâ‚ iâ‚€ iâ‚ fâ‚€-triangle fâ‚-triangle = Î³
     where
      p : fâ‚€ âˆ˜ Î·á´³Ê³áµ– âˆ¼ fâ‚ âˆ˜ Î·á´³Ê³áµ–
      p x = fâ‚€-triangle x âˆ™ (fâ‚-triangle x)â»Â¹

      Î´ : (s : FA) â†’ fâ‚€ (Î·/âˆ¾ s) ï¼ fâ‚ (Î·/âˆ¾ s)
      Î´ [] = fâ‚€ (Î·/âˆ¾ []) ï¼âŸ¨ homs-preserve-unit ğ“• ğ“– fâ‚€ iâ‚€ âŸ©
             e           ï¼âŸ¨ (homs-preserve-unit ğ“• ğ“– fâ‚ iâ‚)â»Â¹ âŸ©
             fâ‚ (Î·/âˆ¾ []) âˆ
      Î´ ((â‚€ , a) âˆ· s) =
             fâ‚€ (Î·/âˆ¾ (Î· a ++ s))      ï¼âŸ¨ ap fâ‚€ ((Â·-natural (Î· a) s)â»Â¹) âŸ©
             fâ‚€ (Î·á´³Ê³áµ– a Â· Î·/âˆ¾ s)      ï¼âŸ¨ iâ‚€  âŸ©
             fâ‚€ (Î·á´³Ê³áµ– a) * fâ‚€ (Î·/âˆ¾ s) ï¼âŸ¨ apâ‚‚ _*_ (p a) (Î´ s) âŸ©
             fâ‚ (Î·á´³Ê³áµ– a) * fâ‚ (Î·/âˆ¾ s) ï¼âŸ¨ iâ‚ â»Â¹ âŸ©
             fâ‚ (Î·á´³Ê³áµ– a Â· Î·/âˆ¾ s)      ï¼âŸ¨ ap fâ‚ (Â·-natural (Î· a) s) âŸ©
             fâ‚ (Î·/âˆ¾ (Î· a ++ s))      âˆ
      Î´ ((â‚ , a) âˆ· s) =
             fâ‚€ (Î·/âˆ¾ (finv (Î· a) ++ s))         ï¼âŸ¨ I âŸ©
             fâ‚€ (Î·/âˆ¾ (finv (Î· a)) Â· Î·/âˆ¾ s)      ï¼âŸ¨ II âŸ©
             fâ‚€ (Î·/âˆ¾ (finv (Î· a))) * fâ‚€ (Î·/âˆ¾ s) ï¼âŸ¨ III âŸ©
             fâ‚€ (inv/ (Î·á´³Ê³áµ– a)) * fâ‚€ (Î·/âˆ¾ s)    ï¼âŸ¨ IV âŸ©
             invG (fâ‚€ (Î·á´³Ê³áµ– a)) * fâ‚€ (Î·/âˆ¾ s)    ï¼âŸ¨ IH âŸ©
             invG (fâ‚ (Î·á´³Ê³áµ– a)) * fâ‚ (Î·/âˆ¾ s)    ï¼âŸ¨ IV' âŸ©
             fâ‚ (inv/ (Î·á´³Ê³áµ– a)) * fâ‚ (Î·/âˆ¾ s)    ï¼âŸ¨ III' âŸ©
             fâ‚ (Î·/âˆ¾ (finv (Î· a))) * fâ‚ (Î·/âˆ¾ s) ï¼âŸ¨ II' âŸ©
             fâ‚ (Î·/âˆ¾ (finv (Î· a)) Â· Î·/âˆ¾ s)      ï¼âŸ¨ I' âŸ©
             fâ‚ (Î·/âˆ¾ (finv (Î· a) ++ s))         âˆ
            where
             I    = ap fâ‚€ ((Â·-natural (finv (Î· a)) s)â»Â¹)
             II   = iâ‚€
             III  = ap (Î» - â†’ fâ‚€ - * fâ‚€ (Î·/âˆ¾ s)) ((inv/-natural (Î· a))â»Â¹)
             IV   = ap (_* fâ‚€ (Î·/âˆ¾ s)) (homs-preserve-invs ğ“• ğ“– fâ‚€ iâ‚€ (Î·á´³Ê³áµ– a))
             IH   = apâ‚‚ (Î» - -' â†’ invG - * -') (p a) (Î´ s)
             IV'  = ap (_* fâ‚ (Î·/âˆ¾ s)) ((homs-preserve-invs ğ“• ğ“– fâ‚ iâ‚ (Î·á´³Ê³áµ– a))â»Â¹)
             III' = ap (Î» - â†’ fâ‚ - * fâ‚ (Î·/âˆ¾ s)) (inv/-natural (Î· a))
             II'  = iâ‚ â»Â¹
             I'   = ap fâ‚ (Â·-natural (finv (Î· a)) s)

      Î³ : fâ‚€ âˆ¼ fâ‚
      Î³ = /-induction -âˆ¾- (Î» x â†’ G-is-set) Î´

    fÌ…-uniqueness : âˆƒ! fÌ… ê‰ (âŸ¨ ğ“• âŸ© â†’ âŸ¨ ğ“– âŸ©)
                        , is-hom ğ“• ğ“– fÌ…
                        Ã— fÌ… âˆ˜ Î·á´³Ê³áµ– âˆ¼ f
    fÌ…-uniqueness = Î³
     where
      c : Î£ fÌ… ê‰ (âŸ¨ ğ“• âŸ© â†’ âŸ¨ ğ“– âŸ©) , is-hom ğ“• ğ“– fÌ… Ã— fÌ… âˆ˜ Î·á´³Ê³áµ– âˆ¼ f
      c = (fÌ… , fÌ…-is-hom , fÌ…-triangle)

      i : is-central _ c
      i (fâ‚€ , fâ‚€-is-hom , fâ‚€-triangle) = to-subtype-ï¼ a b
       where
        a : (fÌ… : âŸ¨ ğ“• âŸ© â†’ âŸ¨ ğ“– âŸ©) â†’ is-prop (is-hom ğ“• ğ“– fÌ… Ã— fÌ… âˆ˜ Î·á´³Ê³áµ– âˆ¼ f)
        a fÌ… = Ã—-is-prop
               (being-hom-is-prop fe ğ“• ğ“– fÌ…)
               (Î -is-prop fe (Î» a â†’ groups-are-sets ğ“–))

        b : fÌ… ï¼ fâ‚€
        b = dfunext fe
             (fÌ…-uniqueness' fÌ… fâ‚€ fÌ…-is-hom fâ‚€-is-hom fÌ…-triangle fâ‚€-triangle)

      Î³ : âˆƒ! fÌ… ê‰ (âŸ¨ ğ“• âŸ© â†’ âŸ¨ ğ“– âŸ©) , is-hom ğ“• ğ“– fÌ… Ã— fÌ… âˆ˜ Î·á´³Ê³áµ– âˆ¼ f
      Î³ = c , i

\end{code}

What we wanted to know is now proved.

We summarize the important parts in the following interface:

\begin{code}

module FreeGroupInterface
        (pt : propositional-truncations-exist)
        (fe : Fun-Ext)
        (â„“ : Universe â†’ Universe)
        (sq : general-set-quotients-exist â„“)
        (Î·/-relates-identified-points : are-effective sq)
        {ğ“¤ : Universe}
        (A : ğ“¤ Ì‡ )
       where

 open free-group-construction A
 open free-group-construction-stepâ‚ pt
 open free-group-construction-stepâ‚‚ fe â„“ sq Î·/-relates-identified-points

 free-group : Group ğ“¤Ì…
 free-group = ğ“•

 Î·-free-group : A â†’ âŸ¨ free-group âŸ©
 Î·-free-group = Î·á´³Ê³áµ–

 Î·-free-group-is-embedding : is-set A â†’ is-embedding Î·-free-group
 Î·-free-group-is-embedding = Î·á´³Ê³áµ–-is-embedding

 module _ ((G , _*_ , G-is-set , G-assoc , e , l , r , inversion) : Group ğ“¥)
          (f : A â†’ G)
        where

  open free-group-construction-stepâ‚ƒ
        G G-is-set e (Î» x â†’ prâ‚ (inversion x)) _*_ l r
        (Î» x â†’ prâ‚ (prâ‚‚ (inversion x))) (Î» x â†’ prâ‚‚ (prâ‚‚ (inversion x))) G-assoc f

  free-group-extension : âŸ¨ free-group âŸ© â†’ âŸ¨ ğ“– âŸ©
  free-group-extension = fÌ…

  free-group-is-hom : is-hom free-group ğ“– free-group-extension
  free-group-is-hom = fÌ…-is-hom

  free-group-triangle : free-group-extension âˆ˜ Î·-free-group âˆ¼ f
  free-group-triangle = fÌ…-triangle

  extension-to-free-group-uniqueness :

    âˆƒ! fÌ… ê‰ (âŸ¨ free-group âŸ© â†’ âŸ¨ ğ“– âŸ©)
         , is-hom free-group ğ“– fÌ…
         Ã— fÌ… âˆ˜ Î·-free-group âˆ¼ f

  extension-to-free-group-uniqueness = fÌ…-uniqueness

\end{code}

We now package the above into a single theorem with several
corollaries.

We can now prove our main theorem.

\begin{code}

general-free-groups-exist pt fe â„“ sq eff A =
 record
  { ğ“• = free-group A
  ; Î· = Î·-free-group A
  ; universality = extension-to-free-group-uniqueness A
  ; Î·-is-embedding = Î·-free-group-is-embedding A
  }
 where
  open FreeGroupInterface pt fe â„“ sq eff

\end{code}

We now proceed to the proof of the second main theorem.

The last three assumptions in the following module parameters are a
slight weakening of the local smallness condition on the type A.

\begin{code}

open import UF.Equiv hiding (_â‰…_)

module resize-free-group
        (fe : Fun-Ext)
        (pe : Prop-Ext)
        (pt : propositional-truncations-exist)
        {ğ“¤        : Universe}
        (A        : ğ“¤ âº Ì‡)
        (_ï¼â‚€_    : A â†’ A â†’ ğ“¤ Ì‡ )
        (reflâ‚€    : (a : A) â†’ a ï¼â‚€ a)
        (from-ï¼â‚€ : (a b : A) â†’ a ï¼â‚€ b â†’ a ï¼ b)
       where

 open FreeGroupInterface pt fe (_âº)
  (large-set-quotients pt fe pe)
  (large-effective-set-quotients pt fe pe)

 open free-group-construction A

 private
  ğ“¤âº  = ğ“¤ âº
  ğ“¤âºâº = ğ“¤âº âº

  fe' : FunExt
  fe' ğ“¤ ğ“¥ = fe {ğ“¤} {ğ“¥}

  pe' : PropExt
  pe' ğ“¤ = pe {ğ“¤}

\end{code}

Our free group is constructed as a quotient of a set of words FA by a
certain equivalence relation _âˆ¾_ : FA â†’ FA â†’ ğ“¤âº. To reduce the size of
the quotient, we reduce the size of (propositional) values of this
equivalence relation using the assumed relation _ï¼â‚€_ and functions
reflâ‚€ and from-ï¼â‚€.

At this point, in order to understand the following constructions, it
is necessary to first understand the constructions in the module
Group.Free, because here we resize down several of the
constructions performed in that file, exploiting the (weakened version
of the) local smalless of the type A.

\begin{code}

 _ï¼[X]_ : X â†’ X â†’ ğ“¤ Ì‡
 (m , a) ï¼[X] (n , b) = (m ï¼ n) Ã— (a ï¼â‚€ b)

 from-ï¼[X] : {x y : X} â†’ x ï¼[X] y â†’ x ï¼ y
 from-ï¼[X] {m , a} {n , b} (p , q) = to-Ã—-ï¼ p (from-ï¼â‚€ a b q)

 to-ï¼[X] : {x y : X} â†’ x ï¼ y â†’ x ï¼[X] y
 to-ï¼[X] {m , a} {m , a} refl = refl , reflâ‚€ a

 _ï¼[FA]_ : FA â†’ FA â†’ ğ“¤ Ì‡
 []      ï¼[FA] []      = ğŸ™
 []      ï¼[FA] (y âˆ· t) = ğŸ˜
 (x âˆ· s) ï¼[FA] []      = ğŸ˜
 (x âˆ· s) ï¼[FA] (y âˆ· t) = (x ï¼[X] y) Ã— (s ï¼[FA] t)

 from-ï¼[FA] : {s t : FA} â†’ s ï¼[FA] t â†’ s ï¼ t
 from-ï¼[FA] {[]}    {[]}    e       = refl
 from-ï¼[FA] {x âˆ· s} {y âˆ· t} (p , q) = apâ‚‚ _âˆ·_ (from-ï¼[X] p) (from-ï¼[FA] q)

 to-ï¼[FA] : {s t : FA} â†’ s ï¼ t â†’ s ï¼[FA] t
 to-ï¼[FA] {[]} {[]}       p = â‹†
 to-ï¼[FA] {x âˆ· s} {y âˆ· t} p = to-ï¼[X]  (equal-heads p) ,
                              to-ï¼[FA] (equal-tails p)

 _â——_ : FA â†’ FA â†’ ğ“¤ Ì‡
 []          â—— t = ğŸ˜
 (x âˆ· [])    â—— t = ğŸ˜
 (x âˆ· y âˆ· s) â—— t = (y ï¼[X] (x â»)) Ã— (s ï¼[FA] t)

 _â–¶_ : FA â†’ FA â†’ ğ“¤ Ì‡
 []      â–¶ t       = ğŸ˜
 (x âˆ· s) â–¶ []      = (x âˆ· s) â—— []
 (x âˆ· s) â–¶ (y âˆ· t) = ((x âˆ· s) â—— (y âˆ· t)) + (x ï¼[X] y Ã— (s â–¶ t))

 â–¶-lemma : (x y : X) (s : List X) â†’ y ï¼ x â» â†’ (x âˆ· y âˆ· s) â–¶ s
 â–¶-lemma x _ []      refl = to-ï¼[X] {x â»} refl , â‹†
 â–¶-lemma x _ (z âˆ· s) refl = inl (to-ï¼[X]  {x â»} refl ,
                                 to-ï¼[X]  {z}   refl ,
                                 to-ï¼[FA] {s}   refl)
\end{code}

The reduction relation _â–·_ is defined in the module Group.Free,
and its propositional, symmetric, reflexive, transitive closure gives
the relation _âˆ¾_ that we use in order to quotient the type FA to get
the group freely generated by A.

We now show that _â–¶_ defined above is logically equivalent to _â–·_.

\begin{code}

 â–¶-gives-â–· : {s t : FA} â†’ s â–¶ t â†’ s â–· t

 â–¶-gives-â–· {[]} {t} r = ğŸ˜-elim r

 â–¶-gives-â–· {x âˆ· y âˆ· s} {[]} (p , q) = [] , s , x ,
                                      ap (Î» - â†’ x âˆ· - âˆ· s) (from-ï¼[X] p) ,
                                      ((from-ï¼[FA] q)â»Â¹)

 â–¶-gives-â–· {x âˆ· y âˆ· s} {z âˆ· t} (inl (p , q)) = Î³ (from-ï¼[X] p) (from-ï¼[FA] q)
  where
   Î³ : y ï¼ x â» â†’ s ï¼ z âˆ· t â†’ x âˆ· y âˆ· s â–· z âˆ· t
   Î³ p q = [] , s , x , ap (Î» - â†’ x âˆ· (- âˆ· s)) p , (q â»Â¹)

 â–¶-gives-â–· {x âˆ· s} {y âˆ· t} (inr (p , r)) = Î³ (from-ï¼[X] p) IH
  where
   IH : s â–· t
   IH = â–¶-gives-â–· r

   Î³ : x ï¼ y â†’ s â–· t â†’ (x âˆ· s) â–· (y âˆ· t)
   Î³ refl = âˆ·-â–· x

 â–·-gives-â–¶ : {s t : FA} â†’ s â–· t â†’ s â–¶ t

 â–·-gives-â–¶ (u , v , x , refl , refl) = f u v x
  where
   f : (u v : FA) (x : X) â†’ (u ++ [ x ] ++ [ x â» ] ++ v) â–¶ (u ++ v)
   f []      []      x = to-ï¼[X] {x â»} refl , â‹†
   f []      (y âˆ· v) x = inl (to-ï¼[X] {x â»} refl , to-ï¼[X] {y} refl , to-ï¼[FA] {v} refl)
   f (y âˆ· u) v       x = inr (to-ï¼[X] {y} refl , f u v x)

\end{code}

The usual way to define the transitive closure of a relation (cf. the
file SRTclosure) applied to the relation _â–¶_ would increase
universe levels back to those of the relation _âˆ¾_.

In order to overcome this obstacle, we consider a type of redexes.

\begin{code}

 redex : FA â†’ ğ“¤ Ì‡
 redex []          = ğŸ˜
 redex (x âˆ· [])    = ğŸ˜
 redex (x âˆ· y âˆ· s) = (y ï¼[X] (x â»)) + redex (y âˆ· s)

 reduct : (s : FA) â†’ redex s â†’ FA
 reduct (x âˆ· y âˆ· s) (inl p) = s
 reduct (x âˆ· y âˆ· s) (inr r) = x âˆ· reduct (y âˆ· s) r

\end{code}

The idea behind the above definitions is that we want that the
relation s â–¶ t holds if and only the word t is the reduct of s at some
redex r, which is what we prove next:

\begin{code}

 lemma-reductâ†’ : (s : FA) (r : redex s) â†’ s â–¶ reduct s r
 lemma-reductâ†’ (x âˆ· y âˆ· s) (inl p) = â–¶-lemma x y s (from-ï¼[X] p)
 lemma-reductâ†’ (x âˆ· y âˆ· s) (inr r) = inr (to-ï¼[X] {x} refl ,
                                         lemma-reductâ†’ (y âˆ· s) r)

 lemma-reductâ† : (s t : FA) â†’ s â–¶ t â†’ Î£ r ê‰ redex s , reduct s r ï¼ t
 lemma-reductâ† (x âˆ· [])    (z âˆ· t) (inl ())
 lemma-reductâ† (x âˆ· [])    (z âˆ· t) (inr ())
 lemma-reductâ† (x âˆ· y âˆ· s) []      (p , q)       = inl p , from-ï¼[FA] q
 lemma-reductâ† (x âˆ· y âˆ· s) (z âˆ· t) (inl (p , q)) = inl p , from-ï¼[FA] q
 lemma-reductâ† (x âˆ· y âˆ· s) (z âˆ· t) (inr (p , r)) = inr (prâ‚ IH) ,
                                                   apâ‚‚ _âˆ·_ (from-ï¼[X] p) (prâ‚‚ IH)
  where
   IH : Î£ r ê‰ redex (y âˆ· s) , reduct (y âˆ· s) r ï¼ t
   IH = lemma-reductâ† (y âˆ· s) t r

\end{code}

Next we define a type of chains of redexes of length n and a
corresponding notion of reduct for such chains:

\begin{code}

 redex-chain : â„• â†’ FA â†’ ğ“¤ Ì‡
 redex-chain 0        s = ğŸ™
 redex-chain (succ n) s = Î£ r ê‰ redex s , redex-chain n (reduct s r)

 chain-reduct : (s : FA) (n : â„•) â†’ redex-chain n s â†’ FA
 chain-reduct s 0        Ï       = s
 chain-reduct s (succ n) (r , Ï) = chain-reduct (reduct s r) n Ï

 chain-lemmaâ†’ : (s : FA) (n : â„•) (Ï : redex-chain n s) â†’ s â–·[ n ] chain-reduct s n Ï
 chain-lemmaâ†’ s 0        Ï       = refl
 chain-lemmaâ†’ s (succ n) (r , Ï) = reduct s r ,
                                   â–¶-gives-â–· (lemma-reductâ†’ s r) ,
                                   chain-lemmaâ†’ (reduct s r) n Ï

 chain-lemmaâ† : (s t : FA) (n : â„•)
              â†’ s â–·[ n ] t
              â†’ Î£ Ï ê‰ redex-chain n s , chain-reduct s n Ï ï¼ t
 chain-lemmaâ† s t 0        r           = â‹† , r
 chain-lemmaâ† s t (succ n) (u , b , c) = Î³ IH l
  where
   IH : Î£ Ï ê‰ redex-chain n u , chain-reduct u n Ï ï¼ t
   IH = chain-lemmaâ† u t n c

   l : Î£ r ê‰ redex s , reduct s r ï¼ u
   l = lemma-reductâ† s u (â–·-gives-â–¶ b)

   Î³ : type-of IH
     â†’ type-of l
     â†’ Î£ Ï' ê‰ redex-chain (succ n) s , chain-reduct s (succ n) Ï' ï¼ t
   Î³ (Ï , refl) (r , refl) = (r , Ï) , refl

\end{code}

And with this we obtain a relation _â‰_ whose propositional truncation
will be logically equivalent to the equivalence relation _âˆ¾_ used to
quotient FA to get the group freely generated by A. The relation _âˆ¾_
itself is the propositional truncation of a suitable relation _âˆ¿_,
which we now use for that purpose.

\begin{code}

 _â‰_ : FA â†’ FA â†’ ğ“¤ Ì‡
 s â‰ t = Î£ m ê‰ â„• ,
         Î£ n ê‰ â„• ,
         Î£ Ï ê‰ redex-chain m s ,
         Î£ Ïƒ ê‰ redex-chain n t , chain-reduct s m Ï  ï¼[FA] chain-reduct t n Ïƒ

 â‰-gives-âˆ¿ : (s t : FA) â†’ s â‰ t â†’ s âˆ¿ t
 â‰-gives-âˆ¿ s t (m , n , Ï , Ïƒ , p) = Î³
  where
   a : s â–·â‹† chain-reduct s m Ï
   a = m , chain-lemmaâ†’ s m Ï

   b : t â–·â‹† chain-reduct t n Ïƒ
   b = n , chain-lemmaâ†’ t n Ïƒ

   c : Î£ u ê‰ FA , (s â–·â‹† u) Ã— (t â–·â‹† u)
   c = chain-reduct t n Ïƒ  , transport (s â–·â‹†_) (from-ï¼[FA] p) a , b

   Î³ : s âˆ¿ t
   Î³ = to-âˆ¿ s t c

 âˆ¿-gives-â‰ : (s t : FA) â†’ s âˆ¿ t â†’ s â‰ t
 âˆ¿-gives-â‰ s t e = Î³ a
  where
   a : Î£ u ê‰ FA , (s â–·â‹† u) Ã— (t â–·â‹† u)
   a = from-âˆ¿ Church-Rosser s t e

   Î³ : type-of a â†’ s â‰ t
   Î³ (u , (m , Ï) , (n , Ïƒ)) = Î´ b c
    where
     b : Î£ Ï ê‰ redex-chain m s , chain-reduct s m Ï ï¼ u
     b = chain-lemmaâ† s u m Ï

     c : Î£ Ïƒ ê‰ redex-chain n t , chain-reduct t n Ïƒ ï¼ u
     c = chain-lemmaâ† t u n Ïƒ

     Î´ : type-of b â†’ type-of c â†’ s â‰ t
     Î´ (Ï , p) (Ïƒ , q) = m , n , Ï , Ïƒ , to-ï¼[FA] (p âˆ™ q â»Â¹)

 open free-group-construction-stepâ‚ pt

 _âˆ¥â‰âˆ¥_ : FA â†’ FA â†’ ğ“¤ Ì‡
 s âˆ¥â‰âˆ¥ t = âˆ¥ s â‰ t âˆ¥

 âˆ¾-is-logically-equivalent-to-âˆ¥â‰âˆ¥ : (s t : FA) â†’ s âˆ¾ t â‡” s âˆ¥â‰âˆ¥ t
 âˆ¾-is-logically-equivalent-to-âˆ¥â‰âˆ¥ s t = âˆ¥âˆ¥-functor (âˆ¿-gives-â‰ s t) ,
                                       âˆ¥âˆ¥-functor (â‰-gives-âˆ¿ s t)
\end{code}

And so we also get a type equivalence, because logically equivalent
propositions are equivalent types:

\begin{code}

 âˆ¿-is-equivalent-to-âˆ¥â‰âˆ¥ : (s t : FA) â†’ (s âˆ¾ t) â‰ƒ (s âˆ¥â‰âˆ¥ t)
 âˆ¿-is-equivalent-to-âˆ¥â‰âˆ¥ s t =
  logically-equivalent-props-are-equivalent
   âˆ¥âˆ¥-is-prop
   âˆ¥âˆ¥-is-prop
   (lr-implication (âˆ¾-is-logically-equivalent-to-âˆ¥â‰âˆ¥ s t))
   (rl-implication (âˆ¾-is-logically-equivalent-to-âˆ¥â‰âˆ¥ s t))

\end{code}

Being logically equivalent to an equivalence relation, the relation
âˆ¥â‰âˆ¥ is itself an equivalence relation (this is proved in the module
SRT).

\begin{code}

 open free-group-construction-stepâ‚‚ fe (_âº)
  (large-set-quotients pt fe pe)
  (large-effective-set-quotients pt fe pe)

 -âˆ¥â‰âˆ¥- : EqRel {ğ“¤âº} {ğ“¤} FA
 -âˆ¥â‰âˆ¥- = _âˆ¥â‰âˆ¥_ , is-equiv-rel-transport _âˆ¾_ _âˆ¥â‰âˆ¥_ (Î» s t â†’ âˆ¥âˆ¥-is-prop)
                 âˆ¾-is-logically-equivalent-to-âˆ¥â‰âˆ¥ âˆ¾-is-equiv-rel
\end{code}

By a general construction in the module UF.LargeQuotient, we conclude
that FA/âˆ¾ â‰ƒ FA/âˆ¥â‰âˆ¥. What is crucial for our purposes is that FA/âˆ¥â‰âˆ¥
lives in the lower universe ğ“¤âº, as opposed to the original quotient
FA/âˆ¾, which lives in the higher universe ğ“¤âºâº.

\begin{code}

 open general-set-quotients-exist (large-set-quotients pt fe pe)

 FA/âˆ¥â‰âˆ¥ : ğ“¤âº Ì‡
 FA/âˆ¥â‰âˆ¥ = FA / -âˆ¥â‰âˆ¥-

 FA/âˆ¾-to-FA/âˆ¥â‰âˆ¥ : FA/âˆ¾ â‰ƒ FA/âˆ¥â‰âˆ¥
 FA/âˆ¾-to-FA/âˆ¥â‰âˆ¥ = quotients-equivalent FA -âˆ¾- -âˆ¥â‰âˆ¥-
                  (Î» {s} {t} â†’ âˆ¾-is-logically-equivalent-to-âˆ¥â‰âˆ¥ s t)

 native-universe-of-free-group : universe-of âŸ¨ free-group A âŸ© ï¼ ğ“¤ âºâº
 native-universe-of-free-group = refl

 resized-free-group-carrier : âŸ¨ free-group A âŸ© is ğ“¤âº small
 resized-free-group-carrier = Î³
  where
   Î³ : Î£ F ê‰ ğ“¤âº Ì‡ , F â‰ƒ âŸ¨ free-group A âŸ©
   Î³ = FA/âˆ¥â‰âˆ¥ , â‰ƒ-sym FA/âˆ¾-to-FA/âˆ¥â‰âˆ¥

\end{code}

With this we get the proof of the first lemma needed for the main
theorem in this module. This relies on transporting group structures
along equivalences, which is implemented in the module Group.Type
(unfortunately, one cannot apply univalence for that purpose, because
the types live in different universes and hence one can't form their
identity type, and so this transport has to be done manually).

\begin{code}

 small-free-group : Î£ ğ“•' ê‰ Group ğ“¤âº , ğ“•' â‰… ğ“•
 small-free-group = resized-group ğ“• resized-free-group-carrier

 ğ“•â» : Group ğ“¤âº
 ğ“•â» = prâ‚ small-free-group

 ğ•œ : ğ“•â» â‰… ğ“•
 ğ•œ = prâ‚‚ small-free-group

 k : âŸ¨ ğ“•â» âŸ© â‰ƒ âŸ¨ ğ“• âŸ©
 k = â‰…-to-â‰ƒ ğ“•â» ğ“• ğ•œ

 k-is-hom : is-hom ğ“•â»  ğ“• âŒœ k âŒ
 k-is-hom = â‰…-to-â‰ƒ-is-hom ğ“•â» ğ“• ğ•œ

 Î·â» : A â†’ âŸ¨ ğ“•â» âŸ©
 Î·â» = âŒœ k âŒâ»Â¹ âˆ˜ Î·á´³Ê³áµ–

 Î·â»-is-embedding : is-set A â†’ is-embedding Î·â»
 Î·â»-is-embedding i = âˆ˜-is-embedding
                      (Î·-free-group-is-embedding A i)
                      (equivs-are-embeddings' (â‰ƒ-sym k))

 universalityâ» : {ğ“¦ : Universe} (ğ“– : Group ğ“¦) (f : A â†’ âŸ¨ ğ“– âŸ©)
               â†’ âˆƒ! fÌ… ê‰ (âŸ¨ ğ“•â» âŸ© â†’ âŸ¨ ğ“– âŸ©)
                      , is-hom ğ“•â» ğ“– fÌ…
                      Ã— fÌ… âˆ˜ Î·â» âˆ¼ f
 universalityâ» ğ“– f =
  equiv-to-singleton I (extension-to-free-group-uniqueness A ğ“– f)
  where
   I : (Î£ g ê‰ (âŸ¨ ğ“•â» âŸ© â†’ âŸ¨ ğ“– âŸ©) , is-hom ğ“•â» ğ“– g  Ã—  g âˆ˜ Î·â» âˆ¼ f)
     â‰ƒ (Î£ h ê‰ (âŸ¨ ğ“• âŸ©  â†’ âŸ¨ ğ“– âŸ©) , is-hom ğ“•  ğ“– h  Ã—  h âˆ˜ Î·á´³Ê³áµ– âˆ¼ f)
   I = qinveq Ï• (Ïˆ , ÏˆÏ• , Ï•Ïˆ)
    where
     Ï• : (Î£ g ê‰ (âŸ¨ ğ“•â» âŸ© â†’ âŸ¨ ğ“– âŸ©) , is-hom ğ“•â» ğ“– g Ã— g âˆ˜ Î·â» âˆ¼ f)
       â†’ (Î£ h ê‰ (âŸ¨ ğ“• âŸ© â†’ âŸ¨ ğ“– âŸ©) , is-hom ğ“• ğ“– h Ã— h âˆ˜ Î·á´³Ê³áµ– âˆ¼ f)
     Ï• (g , i , e) = g âˆ˜ âŒœ k âŒâ»Â¹ ,
                     âˆ˜-is-hom ğ“• ğ“•â» ğ“– âŒœ k âŒâ»Â¹ g
                       (inverses-are-homs' ğ“•â» ğ“• k k-is-hom)
                       i ,
                     e

     Ïˆ : codomain Ï• â†’ domain Ï•
     Ïˆ (h , j , d) =  h âˆ˜ âŒœ k âŒ ,
                      âˆ˜-is-hom ğ“•â» ğ“• ğ“– âŒœ k âŒ h k-is-hom j ,
                      d'
      where
       d' : (a : A) â†’ h (âŒœ k âŒ (Î·â» a)) ï¼ f a
       d' a = h (âŒœ k âŒ (Î·â» a))             ï¼âŸ¨ refl âŸ©
              h (âŒœ k âŒ (âŒœ k âŒâ»Â¹ (Î·á´³Ê³áµ– a))) ï¼âŸ¨ III âŸ©
              h (Î·á´³Ê³áµ– a)                   ï¼âŸ¨ d a âŸ©
              f a                          âˆ
        where
         III = ap h (inverses-are-sections' k (Î·á´³Ê³áµ– a))

     Ï•Ïˆ : Ï• âˆ˜ Ïˆ âˆ¼ id
     Ï•Ïˆ (h , j , d) = to-subtype-ï¼
                       (Î» f â†’ Ã—-is-prop
                               (being-hom-is-prop fe ğ“• ğ“– f)
                               (Î -is-prop fe (Î» _ â†’ groups-are-sets ğ“–)))
                       (dfunext fe (Î» x â†’ ap h (inverses-are-sections' k x)))

     ÏˆÏ• : Ïˆ âˆ˜ Ï• âˆ¼ id
     ÏˆÏ• (g , i , e) = to-subtype-ï¼
                       (Î» f â†’ Ã—-is-prop
                               (being-hom-is-prop fe ğ“•â» ğ“– f)
                               (Î -is-prop fe (Î» _ â†’ groups-are-sets ğ“–)))
                       (dfunext fe (Î» y â†’ ap g (inverses-are-retractions' k y)))

\end{code}

NB. If we assume cumulativity in our type theory, the above transport
can be done with univalence directly. TODO. Write down the proof here
in English (and perhaps also in Agda using --cumulativity).

We can now prove our second main theorem.

\begin{code}

free-groups-of-large-locally-small-types {ğ“¤} pt fe pe A A-ls =
 record
  { ğ“• = ğ“•â»
  ; Î· = Î·â»
  ; universality = universalityâ»
  ; Î·-is-embedding = Î·â»-is-embedding
  }
 where
  open resize-free-group fe pe pt
        A
        IdâŸ¦ A-ls âŸ§
        (Î» _ â†’ âŸ¦ A-ls âŸ§-refl)
        (Î» _ _ p â†’ ï¼âŸ¦ A-ls âŸ§-gives-ï¼ p)

\end{code}
