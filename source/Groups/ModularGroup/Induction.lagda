Lane Biocini
21 January 2026

Induction principles for PSL2Z forming a hierarchy:

  1. Structural (PSL2Z-ind): Direct pattern matching on S-edge/R-edge
  2. Generator-based (PSL2Z-gen-ind): Induction by "start at E, apply s or r"
  3. Extensionality (PSL2Z-Î·): Functions agreeing on generators are equal

The generator-based induction captures that PSL(2,â„¤) is generated by
{s, r}, while extensionality captures freeness: the generators determine
all behavior. Together these express the universal property internally.

\begin{code}

{-# OPTIONS --safe --without-K --exact-split #-}

module Groups.ModularGroup.Induction where

open import MLTT.Spartan
open import UF.Base
open import Groups.ModularGroup.Type
open import Groups.ModularGroup.Base
open import Groups.ModularGroup.Properties

S-edge-ind : {P : S-edge â†’ ğ“¤ Ì‡ }
           â†’ {Q : R-edge â†’ ğ“¤ Ì‡ }
           â†’ P eâ‚€
           â†’ P eâ‚
           â†’ ((re : R-edge) â†’ Q re â†’ P (cross re))
           â†’ ((d : R-sgn) (se : S-edge) â†’ P se â†’ Q (step d se))
           â†’ (se : S-edge) â†’ P se

R-edge-ind : {P : S-edge â†’ ğ“¤ Ì‡ }
           â†’ {Q : R-edge â†’ ğ“¤ Ì‡ }
           â†’ P eâ‚€
           â†’ P eâ‚
           â†’ ((re : R-edge) â†’ Q re â†’ P (cross re))
           â†’ ((d : R-sgn) (se : S-edge) â†’ P se â†’ Q (step d se))
           â†’ (re : R-edge) â†’ Q re

S-edge-ind pâ‚€ pâ‚ c t eâ‚€         = pâ‚€
S-edge-ind pâ‚€ pâ‚ c t eâ‚         = pâ‚
S-edge-ind pâ‚€ pâ‚ c t (cross re) = c re (R-edge-ind pâ‚€ pâ‚ c t re)
R-edge-ind pâ‚€ pâ‚ c t (step d se) = t d se (S-edge-ind pâ‚€ pâ‚ c t se)

PSL2Z-ind : {P : PSL2Z â†’ ğ“¤ Ì‡ }
          â†’ P E
          â†’ P S
          â†’ ((re : R-edge) â†’ P (Î¸ re) â†’ P (sâˆ™ re))
          â†’ (âˆ€ d se â†’ P (Î· se) â†’ P (Ï d se))
          â†’ (x : PSL2Z) â†’ P x
PSL2Z-ind {ğ“¤} {P} pâ‚€ pâ‚ c t (Î· se) =
  S-edge-ind {ğ“¤} {Î» se â†’ P (Î· se)} {Î» re â†’ P (Î¸ re)} pâ‚€ pâ‚ c t se
PSL2Z-ind {ğ“¤} {P} pâ‚€ pâ‚ c t (Î¸ re) =
  R-edge-ind {ğ“¤} {Î» se â†’ P (Î· se)} {Î» re â†’ P (Î¸ re)} pâ‚€ pâ‚ c t re

PSL2Z-rec : {X : ğ“¤ Ì‡ }
          â†’ X
          â†’ X
          â†’ ((re : R-edge) â†’ X â†’ X)
          â†’ ((d : R-sgn) (se : S-edge) â†’ X â†’ X)
          â†’ PSL2Z â†’ X
PSL2Z-rec {ğ“¤} {X} xâ‚€ xâ‚ c t = PSL2Z-ind {ğ“¤} {Î» _ â†’ X} xâ‚€ xâ‚ c t

PSL2Z-iter : {X : ğ“¤ Ì‡ }
           â†’ X â†’ X â†’ (X â†’ X) â†’ (X â†’ X) â†’ (X â†’ X) â†’ PSL2Z â†’ X
PSL2Z-iter e s c f-cw f-ccw =
 PSL2Z-rec e s (Î» _ â†’ c) (Î» { cw _ â†’ f-cw ; ccw _ â†’ f-ccw })

\end{code}

Having exhausted the primitive induction, recursion, and iteration
rules, using transport we can define an induction principle based on
the generators according to the universal property of Modular group
homomorphisms. This induction principle establishes a more explicit
rendition of that universal property with respect to other types
presenting generators with compatible path spaces to those of our
PSL2Z type.

\begin{code}

PSL2Z-gen-ind : {P : PSL2Z â†’ ğ“¤ Ì‡ }
              â†’ P E
              â†’ ((x : PSL2Z) â†’ P x â†’ P (s x))
              â†’ ((x : PSL2Z) â†’ P x â†’ P (r x))
              â†’ (x : PSL2Z) â†’ P x
PSL2Z-gen-ind {ğ“¤} {P} pâ‚€ ps pr = PSL2Z-ind pâ‚€ (ps E pâ‚€) c t
 where
  t : (d : R-sgn) (se : S-edge) â†’ P (Î· se) â†’ P (Î¸ step d se)
  t cw  se p = transport P (r-Î· se) (pr (Î· se) p)
  t ccw se p = pr (râˆ™ se) (transport P (r-Î· se) (pr (Î· se) p))

  c : (re : R-edge) â†’ P (Î¸ re) â†’ P (sâˆ™ re)
  c re p = ps (Î¸ re) p

PSL2Z-gen-iter : {X : ğ“¤ Ì‡ } â†’ X â†’ (X â†’ X) â†’ (X â†’ X) â†’ PSL2Z â†’ X
PSL2Z-gen-iter xâ‚€ fs fr = PSL2Z-gen-ind xâ‚€ (Î» _ â†’ fs) (Î» _ â†’ fr)

\end{code}

The extensionality principle: two functions f, g : PSL2Z â†’ X that agree
on E and commute with the generator actions (f âˆ˜ s = fs âˆ˜ f, etc.) must
be pointwise equal. This is the internal statement that PSL(2,â„¤) is
freely generated by s and r.

\begin{code}

PSL2Z-Î· : {X : ğ“¤ Ì‡ } (fs fr : X â†’ X)
        â†’ (f g : PSL2Z â†’ X)
        â†’ f E ï¼ g E
        â†’ ((x : PSL2Z) â†’ f (s x) ï¼ fs (f x))
        â†’ ((x : PSL2Z) â†’ g (s x) ï¼ fs (g x))
        â†’ ((x : PSL2Z) â†’ f (r x) ï¼ fr (f x))
        â†’ ((x : PSL2Z) â†’ g (r x) ï¼ fr (g x))
        â†’ (x : PSL2Z) â†’ f x ï¼ g x
PSL2Z-Î· fs fr f g base f-s g-s f-r g-r = PSL2Z-gen-ind base ind-s ind-r
 where
  ind-s : (x : PSL2Z) â†’ f x ï¼ g x â†’ f (s x) ï¼ g (s x)
  ind-s x p = f (s x)  ï¼âŸ¨ f-s x âŸ©
              fs (f x) ï¼âŸ¨ ap fs p âŸ©
              fs (g x) ï¼âŸ¨ g-s x â»Â¹ âŸ©
              g (s x)  âˆ

  ind-r : (x : PSL2Z) â†’ f x ï¼ g x â†’ f (r x) ï¼ g (r x)
  ind-r x p = f (r x)  ï¼âŸ¨ f-r x âŸ©
              fr (f x) ï¼âŸ¨ ap fr p âŸ©
              fr (g x) ï¼âŸ¨ g-r x â»Â¹ âŸ©
              g (r x)  âˆ

PSL2Z-gen-iter-E : {X : ğ“¤ Ì‡ } (xâ‚€ : X) (fs fr : X â†’ X)
                 â†’ PSL2Z-gen-iter xâ‚€ fs fr E ï¼ xâ‚€
PSL2Z-gen-iter-E xâ‚€ fs fr = refl

private
  iter : PSL2Z â†’ PSL2Z
  iter = PSL2Z-gen-iter E s rÂ²

PSL2Z-gen-iter-s : (x : PSL2Z) â†’ iter (s x) ï¼ s (iter x)
PSL2Z-gen-iter-s = PSL2Z-ind base-E base-S ind-s ind-r
 where
  base-E : iter (s E) ï¼ s (iter E)
  base-E = refl

  base-S : iter (s S) ï¼ s (iter S)
  base-S = refl

  ind-s : (re : R-edge) â†’ iter (s (Î¸ re)) ï¼ s (iter (Î¸ re))
        â†’ iter (s (sâˆ™ re)) ï¼ s (iter (sâˆ™ re))
  ind-s re p = iter (s (sâˆ™ re))   ï¼âŸ¨ refl âŸ©
               iter (Î¸ re)        ï¼âŸ¨ sÂ² (iter (Î¸ re)) â»Â¹ âŸ©
               s (s (iter (Î¸ re))) ï¼âŸ¨ refl âŸ©
               s (iter (sâˆ™ re))   âˆ

  ind-r : (d : R-sgn) (se : S-edge) â†’ iter (s (Î· se)) ï¼ s (iter (Î· se))
        â†’ iter (s (Î¸ step d se)) ï¼ s (iter (Î¸ step d se))
  ind-r d se p = refl

PSL2Z-gen-iter-r : (x : PSL2Z) â†’ iter (r x) ï¼ rÂ² (iter x)
PSL2Z-gen-iter-r = PSL2Z-ind base-E base-S ind-s ind-r
 where
  base-E : iter (r E) ï¼ rÂ² (iter E)
  base-E = refl

  base-S : iter (r S) ï¼ rÂ² (iter S)
  base-S = refl

  ind-s : (re : R-edge) â†’ iter (r (Î¸ re)) ï¼ rÂ² (iter (Î¸ re))
        â†’ iter (r (sâˆ™ re)) ï¼ rÂ² (iter (sâˆ™ re))
  ind-s re p = refl

  ind-r : (d : R-sgn) (se : S-edge) â†’ iter (r (Î· se)) ï¼ rÂ² (iter (Î· se))
        â†’ iter (r (Î¸ step d se)) ï¼ rÂ² (iter (Î¸ step d se))
  ind-r cw  eâ‚€         p = refl
  ind-r cw  eâ‚         p = refl
  ind-r cw  (cross re) p = refl
  ind-r ccw eâ‚€         p = refl
  ind-r ccw eâ‚         p = refl
  ind-r ccw (cross re) p =
    let y = s (iter (Î¸ re))
    in (rÂ³ (r (r (r y))) âˆ™ rÂ³ y) â»Â¹

\end{code}

Initiality for the twist algebra: any endomorphism f : PSL2Z â†’ PSL2Z
satisfying f(E) = E, f âˆ˜ s = s âˆ˜ f, and f âˆ˜ r = rÂ² âˆ˜ f equals the
canonical twist iteration. This prefigures the universal property.

\begin{code}

PSL2Z-initiality : (f : PSL2Z â†’ PSL2Z)
                 â†’ f E ï¼ E
                 â†’ ((x : PSL2Z) â†’ f (s x) ï¼ s (f x))
                 â†’ ((x : PSL2Z) â†’ f (r x) ï¼ rÂ² (f x))
                 â†’ (x : PSL2Z) â†’ f x ï¼ iter x
PSL2Z-initiality f f-E f-s f-r =
 PSL2Z-Î· s rÂ² f iter f-E f-s PSL2Z-gen-iter-s f-r PSL2Z-gen-iter-r

\end{code}
