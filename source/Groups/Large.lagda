sMartin Escardo
15 February 2021.

In collaboration with Marc Bezem, Thierry Coquand and Peter Dybjer.

This module has the technical lemmas necessary to prove the
following:

  For any universe ğ“¤, there is a group in the successor universe ğ“¤âº
  which is not isomorphic to any group in ğ“¤.

Of course, in the other direction, any group in ğ“¤ has an isomorphic
copy in ğ“¤âº, so the above says that there are strictly more groups in
ğ“¤âº than in ğ“¤.

In the module BuraliForti we use the group freely generated by
the (large but locally small) set of ordinals for that purpose.

We work in a spartan Martin-LÃ¶f type theory, with the assumption that
propositional truncations exist and that the univalence axiom
holds. No other features of HoTT/UF are needed.

In particular, quotients, which we use to construct free groups, are
constructed using propositional truncation and function extensionality
and propositional extensionality in the module UF.LargeQuotient. This
construction of quotients increases the universe level by one (but its
universal property eliminates into any universe), so that the group
freely generated by a type A in a universe ğ“¤ lives in the next
universe ğ“¤âº (but again its universal property eliminates into any
universe).

In this file with work with a given locally small type A : ğ“¤âº for an
arbitrary universe ğ“¤ and we show that the free group constructed in
the module Group.Free, which lives in the universe ğ“¤âºâº, has a
copy in the same universe ğ“¤âº where A lives, provided A is locally
small (meaning that its identity types, which live in ğ“¤âº, have
equivalent copies in ğ“¤). Moreover, we show that if the group freely
generated by A has a copy in the universe ğ“¤, then A itself must have a
copy in ğ“¤.  We then apply this in the module BuraliForti by
taking A to be the type of ordinals in the universe ğ“¤, which doesn't
have a copy in ğ“¤, from which we conclude that the free group also
doesn't have a copy in ğ“¤.

For that purpose, we need to know, in particular, that the inclusion
of generators is injective, which is proved in the module
Group.Free. But this is is not enough: for example, the unique
map P â†’ ğŸ™ is an embedding if P is a proposition, and the terminal
type ğŸ™ is of course small, but P doesn't need to be small - cf. work
with Tom de Jong on size matters https://arxiv.org/abs/2102.08812,
from which we borrow other techniques in the development below.

\begin{code}

{-# OPTIONS --safe --without-K #-}

open import MLTT.Spartan
open import UF.FunExt
open import UF.PropTrunc
open import UF.Subsingletons

module Groups.Large
        (fe : Fun-Ext)
        (pe : Prop-Ext)
        (pt : propositional-truncations-exist)
       where

open import Groups.Free
open import Groups.Type
open import MLTT.List
open import Quotient.Large pt fe pe
open import Quotient.Type
open import Relations.SRTclosure
open import UF.Base
open import UF.Embeddings
open import UF.Equiv hiding (_â‰…_)
open import UF.EquivalenceExamples
open import UF.Sets
open import UF.Size
open import UF.SmallnessProperties

open FreeGroupInterface pt fe (_âº) large-set-quotients large-effective-set-quotients

private

 fe' : FunExt
 fe' ğ“¤ ğ“¥ = fe {ğ“¤} {ğ“¥}

 pe' : PropExt
 pe' ğ“¤ = pe {ğ“¤}

\end{code}

The last three assumptions in the following module parameters are a
slight weakening of the local smallness condition on the type A.

\begin{code}

module resize-free-group'
         {ğ“¤        : Universe}
         (A        : ğ“¤ âº Ì‡)
         (_ï¼â‚€_    : A â†’ A â†’ ğ“¤ Ì‡ )
         (reflâ‚€    : (a : A) â†’ a ï¼â‚€ a)
         (from-ï¼â‚€ : (a b : A) â†’ a ï¼â‚€ b â†’ a ï¼ b)
       where

 open free-group-construction A

 private
  ğ“¤âº  = ğ“¤ âº
  ğ“¤âºâº = ğ“¤âº âº

\end{code}

Next we want to show that the underlying set of the above free group
doesn't have a copy in ğ“¤ (we say that this set is large).

It may happen that for an embedding f : X â†’ Y, the type X is large but
the type Y is small. This is the case, for instance, if X is a
proposition, Y is the unit type, and f is the unique map.

We say that a type has size ğ“¥ if it is equivalent to some type in the
universe ğ“¥, and that a map has size ğ“¥ if its fibers all have size ğ“¥.
See the module UF.Size. This notion of size for maps is introduced and
developed in the paper https://dx.doi.org/10.4230/LIPIcs.FSCD.2021.8
by Tom de Jong and Martin Escardo.

The native size of the universal map Î·á´³Ê³áµ– : A â†’ FA/âˆ¾ into the free
group is rather large - it jumps up two universe levels:

\begin{code}

 open resize-free-group fe pe pt A _ï¼â‚€_ reflâ‚€ from-ï¼â‚€ public
 open general-set-quotients-exist large-set-quotients
 open free-group-construction-stepâ‚ pt
 open free-group-construction-stepâ‚‚ fe (_âº)
  large-set-quotients
  large-effective-set-quotients

 NB-Î·á´³Ê³áµ–-native-size : Î·á´³Ê³áµ– is ğ“¤âºâº small-map
 NB-Î·á´³Ê³áµ–-native-size = native-size-of-map Î·á´³Ê³áµ–

\end{code}

Using the above development, we can make it smaller.

In the following, the function Î·/âˆ¾ : FA â†’ FA/âˆ¾ is the universal map
into the quotient (constructed in the module Groups.FreeGroup), and,
by definition, the universal map Î·á´³Ê³áµ– : A â†’ FA/âˆ¾ into the free group
is the composite Î·/âˆ¾ âˆ˜ Î· where Î· : A â†’ FA is the insertion of
generators before quotienting and Î·/âˆ¾ is the universal map into the
quotient.

\begin{code}

 module _ (A-is-set : is-set A) where

  smallness-of-Î·á´³Ê³áµ–-fibers-is-prop : {ğ“¦ : Universe} (y : FA/âˆ¾)
                                   â†’ is-prop (fiber Î·á´³Ê³áµ– y is ğ“¦ small)
  smallness-of-Î·á´³Ê³áµ–-fibers-is-prop y = prop-being-small-is-prop pe' fe'
                                        (fiber Î·á´³Ê³áµ– y)
                                        (Î·á´³Ê³áµ–-is-embedding A-is-set y)

\end{code}

The following remark is proved by quotient induction, which says that
in order to prove a property of all elements of the quotient, it
suffices to prove it for elements of the form Î·/âˆ¾ s with s : FA.

\begin{code}

  NB-Î·á´³Ê³áµ–-is-medium : Î·á´³Ê³áµ– is ğ“¤âº small-map
  NB-Î·á´³Ê³áµ–-is-medium = /-induction -âˆ¾-
                       smallness-of-Î·á´³Ê³áµ–-fibers-is-prop
                       induction-step
   where
    III : (a : A) (s : FA) â†’ (Î·/âˆ¾ (Î· a) ï¼ Î·/âˆ¾ s) â‰ƒ (Î· a âˆ¥â‰âˆ¥ s)
    III a s = (Î·/âˆ¾ (Î· a) ï¼ Î·/âˆ¾ s) â‰ƒâŸ¨ I âŸ©
              (Î· a âˆ¾ s)            â‰ƒâŸ¨ II âŸ©
              (Î· a âˆ¥â‰âˆ¥ s)          â– 
     where
      I = logically-equivalent-props-are-equivalent
           (/-is-set -âˆ¾-)
           âˆ¥âˆ¥-is-prop
           Î·/âˆ¾-relates-identified-points
           Î·/âˆ¾-identifies-related-points
      II = âˆ¿-is-equivalent-to-âˆ¥â‰âˆ¥ (Î· a) s

    IV : (s : FA) â†’ fiber Î·á´³Ê³áµ– (Î·/âˆ¾ s) â‰ƒ (Î£ a ê‰ A , Î· a âˆ¥â‰âˆ¥ s)
    IV s = (Î£ a ê‰ A , Î·/âˆ¾ (Î· a) ï¼ Î·/âˆ¾ s) â‰ƒâŸ¨ Î£-cong (Î» a â†’ III a s) âŸ©
           (Î£ a ê‰ A , Î· a âˆ¥â‰âˆ¥ s)          â– 

    notice : (s : FA) â†’ universe-of (fiber Î·á´³Ê³áµ– (Î·/âˆ¾ s)) ï¼ ğ“¤âºâº
    notice s = refl

    induction-step : (s : FA) â†’ fiber Î·á´³Ê³áµ– (Î·/âˆ¾ s) is ğ“¤âº small
    induction-step s = (Î£ a ê‰ A , Î· a âˆ¥â‰âˆ¥ s) , â‰ƒ-sym (IV s)

\end{code}

But the above resizing of the map Î·á´³Ê³áµ– is not small enough for our
purposes. Recall that Î·á´³Ê³áµ– a = Î·/âˆ¾ (Î· a). We first discuss the fibers
of Î·, then those of Î·/âˆ¾, and finally those of Î·á´³Ê³áµ–.

The fiber type Î£ a ê‰ A , Î· a ï¼ s lives in the universe ğ“¤âº. In the next
step we construct a copy of this fiber type in the first universe ğ“¤â‚€.

The following construction also shows that the map Î· : A â†’ FA has
decidable fibers, which is used implicitly in our definitions by
pattern matching.

\begin{code}

  NB-native-universe-fiber-Î· : (s : FA) â†’ universe-of (fiber Î· s) ï¼ ğ“¤âº
  NB-native-universe-fiber-Î· s = refl

  Î·-is-decidable : each-fiber-of Î· is-decidable
  Î·-is-decidable = âˆ˜-decidable-embeddings
                    []-is-embedding
                    pairâ‚€-is-decidable
                    []-is-decidable

  Î·-is-embedding : is-embedding Î·
  Î·-is-embedding = âˆ˜-is-embedding pairâ‚€-is-embedding []-is-embedding

  Î·-has-any-size : (ğ“¦ : Universe) â†’ Î· is ğ“¦ small-map
  Î·-has-any-size ğ“¦ = decidable-embeddings-have-any-size ğ“¦
                       Î·-is-embedding
                       Î·-is-decidable
\end{code}

Using this, next we want to reduce the size of the type
Î£ a ê‰ A , Î· a âˆ¾ s, which we informally refer to
as "the âˆ¾-fiber of s over Î·". First, this type is a proposition:

\begin{code}

  the-âˆ¾-fibers-of-Î·-are-props : (s : FA) â†’ is-prop (Î£ a ê‰ A , Î· a âˆ¾ s)
  the-âˆ¾-fibers-of-Î·-are-props s (a , e) (a' , e') = Î³
   where
    Î± : Î· a âˆ¾ Î· a'
    Î± = psrt-transitive (Î· a) s (Î· a') e (psrt-symmetric (Î· a') s e')

    Î² : a ï¼ a'
    Î² = Î·-identifies-âˆ¾-related-points A-is-set Î±

    Î³ : (a , e) ï¼ (a' , e')
    Î³ = to-subtype-ï¼ (Î» x â†’ âˆ¥âˆ¥-is-prop) Î²

  generator : FA â†’ ğ“¤ âº Ì‡
  generator s = Î£ n ê‰ â„• , Î£ Ï ê‰ redex-chain n s , fiber Î· (chain-reduct s n Ï)

  is-generator : FA â†’ ğ“¤ âº Ì‡
  is-generator s = âˆ¥ generator s âˆ¥

  being-generator-is-small : (s : FA) â†’ is-generator s is ğ“¤ small
  being-generator-is-small s =
   âˆ¥âˆ¥-is-small pt
    (Î£-is-small
      (native-size â„•)
      (Î» n â†’ Î£-is-small
              (native-size (redex-chain n s))
              (Î» Ï â†’ Î·-has-any-size ğ“¤ (chain-reduct s n Ï))))

  âˆ¾-fiber-Î·-lemmaâ†’ : (s : FA) â†’ (Î£ a ê‰ A , Î· a âˆ¾ s) â†’ is-generator s
  âˆ¾-fiber-Î·-lemmaâ†’ s (a , e) = âˆ¥âˆ¥-functor Î³ e
   where
    Î³ : Î· a âˆ¿ s â†’ generator s
    Î³ e = Î´ (d c)
     where
      c : Î£ u ê‰ FA , (Î· a â–·â‹† u) Ã— (s â–·â‹† u)
      c = from-âˆ¿ Church-Rosser (Î· a) s e

      d : type-of c â†’ Î£ n ê‰ â„• , Î£ Ï ê‰ redex-chain n s , chain-reduct s n Ï ï¼ Î· a
      d (u , r , râ‚) = Î´ râ‚‚
       where
        p : Î· a ï¼ u
        p = Î·-irreducibleâ‹† r

        râ‚‚ : s  â–·â‹† Î· a
        râ‚‚ = transport (s â–·â‹†_) (p â»Â¹) râ‚

        Î´ : s  â–·â‹† Î· a â†’ Î£ n ê‰ â„• , Î£ Ï ê‰ redex-chain n s , chain-reduct s n Ï ï¼ Î· a
        Î´ (n , râ‚ƒ) = (n , chain-lemmaâ† s (Î· a) n râ‚ƒ)

      Î´ : type-of (d c) â†’ generator s
      Î´ (n , Ï , p) = n , Ï , a , (p â»Â¹)

  âˆ¾-fiber-Î·-lemmaâ† : (s : FA) â†’ is-generator s â†’ (Î£ a ê‰ A , Î· a âˆ¾ s)
  âˆ¾-fiber-Î·-lemmaâ† s = âˆ¥âˆ¥-rec (the-âˆ¾-fibers-of-Î·-are-props s) Î³
   where
    Î³ : generator s â†’ (Î£ a ê‰ A , Î· a âˆ¾ s)
    Î³ (n , Ï , i) = Î´ i
     where
      r : s â–·[ n ] chain-reduct s n Ï
      r = chain-lemmaâ†’ s n Ï

      e : chain-reduct s n Ï âˆ¾ s
      e = âˆ£ to-âˆ¿ (chain-reduct s n Ï) s (chain-reduct s n Ï , (0 , refl) , (n , r)) âˆ£

      Î´ : fiber Î· (chain-reduct s n Ï) â†’ Î£ a ê‰ A , Î· a âˆ¾ s
      Î´ (a , p) = a , transport (_âˆ¾ s) (p â»Â¹) e

\end{code}

And this is the desired size reduction:

\begin{code}

  âˆ¾-fiber-Î·-lemma : (s : FA) â†’ (Î£ a ê‰ A , Î· a âˆ¾ s) â‰ƒ is-generator s
  âˆ¾-fiber-Î·-lemma s = logically-equivalent-props-are-equivalent
                       (the-âˆ¾-fibers-of-Î·-are-props s)
                       âˆ¥âˆ¥-is-prop
                       (âˆ¾-fiber-Î·-lemmaâ†’ s)
                       (âˆ¾-fiber-Î·-lemmaâ† s)
\end{code}

With this we can further reduce the size of the universal map Î·á´³Ê³áµ–:

\begin{code}

  fiber-Î·/âˆ¾-lemma : (a : A) (s : FA) â†’ (Î·/âˆ¾ (Î· a) ï¼ Î·/âˆ¾ s) â‰ƒ (Î· a âˆ¾ s)
  fiber-Î·/âˆ¾-lemma a s = logically-equivalent-props-are-equivalent
                         (/-is-set -âˆ¾-)
                         âˆ¥âˆ¥-is-prop
                         Î·/âˆ¾-relates-identified-points
                         Î·/âˆ¾-identifies-related-points

  fiber-Î·Î·á´³Ê³áµ–-lemma : (s : FA) â†’ fiber Î·á´³Ê³áµ– (Î·/âˆ¾ s) â‰ƒ is-generator s
  fiber-Î·Î·á´³Ê³áµ–-lemma s =
   (Î£ a ê‰ A , Î·/âˆ¾ (Î· a) ï¼ Î·/âˆ¾ s) â‰ƒâŸ¨ Î£-cong (Î» a â†’ fiber-Î·/âˆ¾-lemma a s) âŸ©
   (Î£ a ê‰ A , Î· a âˆ¾ s)            â‰ƒâŸ¨ âˆ¾-fiber-Î·-lemma s âŸ©
   is-generator s                 â– 

  the-Î·á´³Ê³áµ–-fibers-of-equivalence-classes-are-small : (s : FA)
                                                   â†’ fiber Î·á´³Ê³áµ– (Î·/âˆ¾ s) is ğ“¤ small
  the-Î·á´³Ê³áµ–-fibers-of-equivalence-classes-are-small s =
   smallness-closed-under-â‰ƒ'
    (being-generator-is-small s)
    (fiber-Î·Î·á´³Ê³áµ–-lemma s)

  Î·á´³Ê³áµ–-is-small : Î·á´³Ê³áµ– is ğ“¤ small-map
  Î·á´³Ê³áµ–-is-small = /-induction -âˆ¾-
                   smallness-of-Î·á´³Ê³áµ–-fibers-is-prop
                   the-Î·á´³Ê³áµ–-fibers-of-equivalence-classes-are-small
\end{code}

And with this we get our desired result as a corollary:

\begin{code}

  free-group-small-gives-generating-set-small : âŸ¨ free-group A âŸ© is ğ“¤ small
                                              â†’ A is ğ“¤ small
  free-group-small-gives-generating-set-small h =
   size-contravariance Î·á´³Ê³áµ– Î·á´³Ê³áµ–-is-small h

\end{code}

It follows that if there is a large, locally small set, then there is
a large group:

\begin{code}

large-group-with-no-small-copy : (Î£ A ê‰ ğ“¤ âº Ì‡  , is-set A
                                              Ã— is-large A
                                              Ã— is-locally-small A)
                               â†’ Î£ F ê‰ Group (ğ“¤ âº) , ((G : Group ğ“¤) â†’ Â¬ (G â‰… F))

large-group-with-no-small-copy {ğ“¤} (A , A-is-set , A-is-large , A-ls) = Î´
 where
  open resize-free-group'
        A
        IdâŸ¦ A-ls âŸ§
        (Î» _ â†’ âŸ¦ A-ls âŸ§-refl)
        (Î» _ _ p â†’ ï¼âŸ¦ A-ls âŸ§-gives-ï¼ p)

  Î³ : (Î£ F ê‰ Group (ğ“¤ âº) , F â‰… free-group A)
    â†’ (Î£ F ê‰ Group (ğ“¤ âº) , ((G : Group ğ“¤) â†’ Â¬ (G â‰… F)))
  Î³ (F , f , f-is-equiv , f-is-hom) = F , Î²
   where
    Î² : (G : Group ğ“¤) â†’ G â‰… F â†’ ğŸ˜
    Î² G (g , g-is-equiv , g-is-hom) = Î±
     where
      h : âŸ¨ free-group A âŸ© is ğ“¤ small
      h = âŸ¨ G âŸ© , f âˆ˜ g , âˆ˜-is-equiv g-is-equiv f-is-equiv

      Î± : ğŸ˜
      Î± = A-is-large (free-group-small-gives-generating-set-small A-is-set h)

  Î´ : codomain Î³
  Î´ = Î³ small-free-group

\end{code}

In the module BuraliForti we instantiate A to the set of ordinals,
which is large and locally small, to construct a large group with no
small copy.

Remarks.

What can we choose for the large, locally small set?

 * Our choice is the type of ordinals.

 * One may wonder whether there are simpler choices such as

    (i)   The function type ğ“¤ â†’ ğŸš.
    (ii)  The function type ğ“¤ â†’ Î© ğ“¤.
    (iii) The set truncation of ğ“¤.

   The candidate (i) doesn't work in the absence of classical logic,
   because there is a non-constant function ğ“¤ â†’ ğŸš if and only if de
   Morgan Law holds (which is equivalent to excluded middle for
   negative propositions). https://doi.org/10.1016/j.apal.2016.04.010

   The candidates (ii) and (iii) may work, but so far we haven't succeeded.

 * Another question is whether there is a large, discrete set, as this
   would considerably simplify the construction of the free group. One
   of us conjectures that there isn't, in general, such a set.
