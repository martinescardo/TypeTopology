Martin Escardo and Paulo Oliva, April 2024

The free discrete graphic monoid is given by the monoid of lists
without repetitions.

\begin{code}

{-# OPTIONS --safe --without-K #-}

open import MLTT.Spartan
open import UF.FunExt
open import UF.DiscreteAndSeparated

module DiscreteGraphicMonoids.Free
        (fe : Fun-Ext)
       where

open import MLTT.List
            renaming (_âˆ·_ to _â€¢_ ;          -- typed as \bub
                      _++_ to _â—¦_ ;         -- typed as \buw
                      ++-assoc to â—¦-assoc)
open import Naturals.Order
open import Notation.Order
open import UF.Base
open import DiscreteGraphicMonoids.Type
open import DiscreteGraphicMonoids.ListsWithoutRepetitions fe
open import DiscreteGraphicMonoids.LWRDGM fe

\end{code}

Listâ» X is the graphic monoid freely generated by X, with
Î·â» : X â†’ Listâ» X as the universal map, or insertion of generators.

That is,

 1. Listâ» X is a graphic monoid.

 2. There is a map Î·â» : X â†’ Listâ» X, such that for any graphic monoid
    (M,*) and any function f : X â†’ M, there is a unique monoid
    homomorphism f' : Listâ» â†’ M.

       Î·â»
    X ---> Listâ» X
     \       .
      \      .
       \     .
     f  \    . fâ»
         \   .
          \  .
           \ .
            v
            M


The following is an auxiliary module to prove that.

\begin{code}

module free-discrete-graphic-monoid-development
        {ğ“¤ ğ“¥ : Universe}
        (M : ğ“¥ Ì‡ )
        {{M-is-discrete' : is-discrete' M}}
        (e : M)
        (_â—_ : M â†’ M â†’ M)
        (left-unit : (x : M) â†’ e â— x ï¼ x)
        (right-unit : (x : M) â†’ x â— e ï¼ x)
        (â—-assoc : (x y z : M) â†’ x â— (y â— z) ï¼ (x â— y) â— z)
        (graphic : (x y : M) â†’ (x â— y) â— x ï¼ x â— y)
        (X : ğ“¤ Ì‡ )
        {{X-is-discrete' : is-discrete' X}}
        (f : X â†’ M)
       where

 M-is-discrete : is-discrete M
 M-is-discrete = discrete'-gives-discrete M-is-discrete'

 â—-idemp : (x : M) â†’ x â— x ï¼ x
 â—-idemp x =
  x â— x       ï¼âŸ¨ ap (_â— x) ((right-unit x)â»Â¹) âŸ©
  (x â— e) â— x ï¼âŸ¨ graphic x e âŸ©
  x â— e       ï¼âŸ¨ right-unit x âŸ©
  x           âˆ

 f' : List X â†’ M
 f' []       = e
 f' (x â€¢ xs) = f x â— f' xs

 f'-preserves-mul : (xs ys : List X) â†’ f' (xs â—¦ ys) ï¼ f' xs â— f' ys
 f'-preserves-mul [] ys =
  f' ([] â—¦ ys)  ï¼âŸ¨ refl âŸ©
  f' ys         ï¼âŸ¨ (left-unit (f' ys))â»Â¹ âŸ©
  e â— f' ys     ï¼âŸ¨ refl âŸ©
  f' [] â— f' ys âˆ
 f'-preserves-mul (x â€¢ xs) ys =
  f' (x â€¢ xs â—¦ ys)      ï¼âŸ¨ refl âŸ©
  f x â— f' (xs â—¦ ys)    ï¼âŸ¨ ap (f x â—_) (f'-preserves-mul xs ys) âŸ©
  f x â— (f' xs â— f' ys) ï¼âŸ¨ â—-assoc (f x) (f' xs) (f' ys) âŸ©
  (f x â— f' xs) â— f' ys ï¼âŸ¨ refl âŸ©
  f' (x â€¢ xs) â— f' ys   âˆ

 fâ» : Listâ» X â†’ M
 fâ» = f' âˆ˜ underlying-list

 fâ»-triangle : fâ» âˆ˜ Î·â» âˆ¼ f
 fâ»-triangle x = (fâ» âˆ˜ Î·â») x ï¼âŸ¨ refl âŸ©
                 f x â— e     ï¼âŸ¨ right-unit (f x) âŸ©
                 f x         âˆ

 underlying-list-preserves-unit : underlying-list {ğ“¤} {X} []â» ï¼ []
 underlying-list-preserves-unit = refl

\end{code}

The function underlying-list : Listâ» X â†’ List X doesn't preserve
multiplication, as this would mean that Ï (xs â—¦ ys) ï¼ xs â—¦ ys for any
two lists with Ï xs ï¼ xs and Ï ys = ys. However, it's composition fâ»
with f' does. We need to use the graphic law, and this is not true in
general.

\begin{code}

 Ï• : List M â†’ M
 Ï• []       = e
 Ï• (u â€¢ us) = u â— Ï• us

 Ï•-is-hom : (us vs : List M)
          â†’ Ï• (us â—¦ vs) ï¼ Ï• us â— Ï• vs
 Ï•-is-hom [] vs =
  Ï• ([] â—¦ vs)   ï¼âŸ¨ refl âŸ©
  Ï• vs          ï¼âŸ¨ (left-unit (Ï• vs))â»Â¹ âŸ©
  (e â— Ï• vs)    ï¼âŸ¨ refl âŸ©
  (Ï• [] â— Ï• vs) âˆ
 Ï•-is-hom (x â€¢ us) vs =
  Ï• (x â€¢ us â—¦ vs)   ï¼âŸ¨ refl âŸ©
  x â— Ï• (us â—¦ vs)   ï¼âŸ¨ ap (x â—_) (Ï•-is-hom us vs) âŸ©
  x â— (Ï• us â— Ï• vs) ï¼âŸ¨ â—-assoc x (Ï• us) (Ï• vs) âŸ©
  (x â— Ï• us) â— Ï• vs ï¼âŸ¨ refl âŸ©
  Ï• (x â€¢ us) â— Ï• vs âˆ

 fold-map-lemma : (xs : List X) â†’ f' xs ï¼ Ï• (map f xs)
 fold-map-lemma [] = refl
 fold-map-lemma (x â€¢ xs) = ap (f x â—_) (fold-map-lemma xs)

 Ï•-Î´-lemma : (u v : M) (ws : List M)
           â†’ u â— (v â— Ï• (Î´ u ws)) ï¼ u â— (v â— Ï• ws)
 Ï•-Î´-lemma u v []       = refl
 Ï•-Î´-lemma u v (w â€¢ ws) = h (M-is-discrete u w)
  where
   h : is-decidable (u ï¼ w)
     â†’ u â— (v â— Ï• (Î´ u (w â€¢ ws))) ï¼ u â— (v â— Ï• (w â€¢ ws))
   h (inl refl) =
    u â— (v â— Ï• (Î´ u (u â€¢ ws))) ï¼âŸ¨ ap (Î» - â†’ u â— (v â— Ï• -)) (Î´-same u ws) âŸ©
    u â— (v â— Ï• (Î´ u ws))       ï¼âŸ¨ Ï•-Î´-lemma u v ws âŸ©
    u â— (v â— Ï• ws)             ï¼âŸ¨ â—-assoc u v (Ï• ws) âŸ©
    (u â— v) â— Ï• ws             ï¼âŸ¨ ap (_â— Ï• ws) ((graphic u v)â»Â¹) âŸ©
    ((u â— v) â— u) â— Ï• ws       ï¼âŸ¨ (â—-assoc (u â— v) u (Ï• ws))â»Â¹ âŸ©
    (u â— v) â— (u â— Ï• ws)       ï¼âŸ¨ (â—-assoc u v (u â— Ï• ws))â»Â¹ âŸ©
    u â— (v â— (u â— Ï• ws))       ï¼âŸ¨ refl âŸ©
    u â— (v â— Ï• (u â€¢ ws))       âˆ
   h (inr Î½) =
    u â— (v â— Ï• (Î´ u (w â€¢ ws))) ï¼âŸ¨ ap (Î» - â†’ u â— (v â— Ï• -)) (Î´-â‰  u w ws Î½) âŸ©
    u â— (v â— Ï• (w â€¢ Î´ u ws))   ï¼âŸ¨ refl âŸ©
    u â— (v â— (w â— Ï• (Î´ u ws))) ï¼âŸ¨ ap (u â—_) (â—-assoc v w (Ï• (Î´ u ws))) âŸ©
    u â— ((v â— w) â— Ï• (Î´ u ws)) ï¼âŸ¨ Ï•-Î´-lemma u (v â— w) ws âŸ©
    u â— ((v â— w) â— Ï• ws)       ï¼âŸ¨ ap (u â—_) ((â—-assoc v w (Ï• ws))â»Â¹) âŸ©
    u â— (v â— (w â— Ï• ws))       ï¼âŸ¨ refl âŸ©
    u â— (v â— Ï• (w â€¢ ws))       âˆ

 Ï•-Î´-lemma' : (u : M) (ws : List M)
            â†’ u â— Ï• (Î´ u ws) ï¼ u â— Ï• ws
 Ï•-Î´-lemma' u ws =
  u â— Ï• (Î´ u ws)       ï¼âŸ¨ ap (u â—_) ((left-unit (Ï• (Î´ u ws)))â»Â¹) âŸ©
  u â— (e â— Ï• (Î´ u ws)) ï¼âŸ¨ Ï•-Î´-lemma u e ws âŸ©
  u â— (e â— Ï• ws)       ï¼âŸ¨ ap (u â—_) (left-unit (Ï• ws)) âŸ©
  u â— Ï• ws             âˆ

 fold-Ï-lemma : (us vs : List M)
              â†’ Ï us ï¼ Ï vs â†’ Ï• us ï¼ Ï• vs
 fold-Ï-lemma = course-of-values-induction-on-length _ h
  where
   h : (us : List M)
     â†’ ((us' : List M)
             â†’ length us' < length us
             â†’ (vs : List M) â†’ Ï us' ï¼ Ï vs â†’ Ï• us' ï¼ Ï• vs)
     â†’ (vs : List M) â†’ Ï us ï¼ Ï vs â†’ Ï• us ï¼ Ï• vs
   h [] IH [] e = refl
   h (u â€¢ us) IH (v â€¢ vs) e =
    Ï• (u â€¢ us)     ï¼âŸ¨ refl âŸ©
    u â— Ï• us       ï¼âŸ¨ (Ï•-Î´-lemma' u us)â»Â¹ âŸ©
    u â— Ï• (Î´ u us) ï¼âŸ¨ ap (u â—_) (IH (Î´ u us) (Î´-length u us) (Î´ v vs) I) âŸ©
    u â— Ï• (Î´ v vs) ï¼âŸ¨ ap (_â— Ï• (Î´ v vs)) (equal-heads e) âŸ©
    v â— Ï• (Î´ v vs) ï¼âŸ¨ Ï•-Î´-lemma' v vs âŸ©
    v â— Ï• vs       ï¼âŸ¨ refl âŸ©
    Ï• (v â€¢ vs)     âˆ
     where
      have-e : u â€¢ Î´ u (Ï us) ï¼ v â€¢ Î´ v (Ï vs)
      have-e = e
      I =  Ï (Î´ u us) ï¼âŸ¨ (Î´-Ï-swap u us)â»Â¹ âŸ©
           Î´ u (Ï us) ï¼âŸ¨ equal-tails e âŸ©
           Î´ v (Ï vs) ï¼âŸ¨ Î´-Ï-swap v vs âŸ©
           Ï (Î´ v vs) âˆ

 fold-Ï : (us : List M) â†’ Ï• us ï¼ Ï• (Ï us)
 fold-Ï us = fold-Ï-lemma us (Ï us) ((Ï-idemp us)â»Â¹)

 Ï-lemma : (xs : List X)
          â†’ f' (Ï xs) ï¼ f' xs
 Ï-lemma xs =
  f' (Ï xs)            ï¼âŸ¨ fold-map-lemma (Ï xs) âŸ©
  Ï• (map f (Ï xs))     ï¼âŸ¨ fold-Ï (map f (Ï xs)) âŸ©
  Ï• (Ï (map f (Ï xs))) ï¼âŸ¨ ap (Ï•) (Ï-map f xs) âŸ©
  Ï• (Ï (map f xs))     ï¼âŸ¨ (fold-Ï (map f xs))â»Â¹ âŸ©
  Ï• (map f xs)         ï¼âŸ¨ (fold-map-lemma xs)â»Â¹ âŸ©
  f' xs                âˆ

 Ï-lemma' : (xs ys : List X)
          â†’ Ï xs ï¼ Ï ys
          â†’ f' xs ï¼ f' ys
 Ï-lemma' xs ys e =
  f' xs     ï¼âŸ¨ (Ï-lemma xs)â»Â¹ âŸ©
  f' (Ï xs) ï¼âŸ¨ ap f' e âŸ©
  f' (Ï ys) ï¼âŸ¨ Ï-lemma ys âŸ©
  f' ys     âˆ

 fâ»-preserves-mul : (ğ”ğ“¼ ğ”‚ğ“¼ : Listâ» X)
                  â†’ fâ» (ğ”ğ“¼ Â· ğ”‚ğ“¼) ï¼ fâ» ğ”ğ“¼ â— fâ» ğ”‚ğ“¼
 fâ»-preserves-mul ğ”ğ“¼@(xs , a) ğ”‚ğ“¼@(ys , b) =
  fâ» (ğ”ğ“¼ Â· ğ”‚ğ“¼)      ï¼âŸ¨ refl âŸ©
  f' (Ï (xs â—¦ ys)) ï¼âŸ¨ Ï-lemma (xs â—¦ ys) âŸ©
  f' (xs â—¦ ys)     ï¼âŸ¨ f'-preserves-mul xs ys âŸ©
  f' xs â— f' ys    ï¼âŸ¨ refl âŸ©
  fâ» ğ”ğ“¼ â— fâ» ğ”‚ğ“¼      âˆ

 fâ»-uniqueness : (h : Listâ» X â†’ M)
               â†’ h []â» ï¼ e
               â†’ ((xs ys : Listâ» X) â†’ h (xs Â· ys) ï¼ h xs â— h ys)
               â†’ h âˆ˜ Î·â» âˆ¼ f
               â†’ h âˆ¼ fâ»
 fâ»-uniqueness h unit-h comp-h triangle-h (xs , a) = I xs a
  where
   I : (xs : List X) (a : Ï xs ï¼ xs)
     â†’ h (xs , a) ï¼ fâ» (xs , a)
   I [] a =
    h ([] , a) ï¼âŸ¨ ap h (to-Listâ»-ï¼ refl) âŸ©
    h []â»      ï¼âŸ¨ unit-h âŸ©
    e          ï¼âŸ¨ refl âŸ©
    fâ» ([] , a) âˆ

   I (x â€¢ xs) a =
    h ((x â€¢ xs) , a) ï¼âŸ¨ ap h II âŸ©
    h (Î·â» x Â· ğ”ğ“¼)    ï¼âŸ¨ comp-h (Î·â» x) ğ”ğ“¼ âŸ©
    h (Î·â» x) â— h ğ”ğ“¼  ï¼âŸ¨ apâ‚‚ _â—_ (triangle-h x) (I xs b) âŸ©
    f x â— fâ» ğ”ğ“¼       ï¼âŸ¨ refl âŸ©
    f x â— f' xs      ï¼âŸ¨ refl âŸ©
    fâ» ((x â€¢ xs) , a) âˆ
     where
      have-a : Ï (x â€¢ xs) ï¼ x â€¢ xs
      have-a = a

      b : Ï xs ï¼ xs
      b = Ï-tail x xs a

      have-a' : x â€¢ Î´ x (Ï xs) ï¼ x â€¢ xs
      have-a' = a

      ğ”ğ“¼ : Listâ» X
      ğ”ğ“¼ = xs , b

      II : ((x â€¢ xs) , a) ï¼ Î·â» x Â· ğ”ğ“¼
      II = to-Listâ»-ï¼
            (x â€¢ xs                      ï¼âŸ¨ ap (x â€¢_) (equal-tails a)â»Â¹ âŸ©
             x â€¢ Î´ x (Ï xs)              ï¼âŸ¨ refl âŸ©
             underlying-list (Î·â» x) âŠ™ xs âˆ)

\end{code}

We now package the above as follows, to conclude that, as claimed,
lists without repetitions over a discrete type form the free discrete
graphic monoid.

\begin{code}

module _
        (ğ“œ : DGM ğ“¥)
        {X : ğ“¤ Ì‡ }
        {{X-is-discrete' : is-discrete' X}}
       where

 open free-discrete-graphic-monoid-development
       âŸ¨ ğ“œ âŸ©
       {{discrete-gives-discrete' (discreteness ğ“œ)}}
       (unit ğ“œ)
       (multiplication ğ“œ)
       (left-neutrality ğ“œ)
       (right-neutrality ğ“œ)
       (associativity ğ“œ)
       (graphicality ğ“œ)
       X
       {{X-is-discrete'}}

 extension : (X â†’ âŸ¨ ğ“œ âŸ©) â†’ Listâ» X â†’ âŸ¨ ğ“œ âŸ©
 extension = fâ»

 extension-is-hom : (f : X â†’ âŸ¨ ğ“œ âŸ©)
                  â†’ is-hom (Listâ»-DGM X) ğ“œ (extension f)
 extension-is-hom f = refl , fâ»-preserves-mul f

 triangle : (f : X â†’ âŸ¨ ğ“œ âŸ©)
          â†’ extension f âˆ˜ Î·â» âˆ¼ f
 triangle = fâ»-triangle

 uniqueness : (f : X â†’ âŸ¨ ğ“œ âŸ©)
              (h : Listâ» X â†’ âŸ¨ ğ“œ âŸ©)
            â†’ is-hom (Listâ»-DGM X) ğ“œ h
            â†’ h âˆ˜ Î·â» âˆ¼ f
            â†’ h âˆ¼ extension f
 uniqueness f h (f-unit , f-comp) = fâ»-uniqueness f h f-unit f-comp

\end{code}
