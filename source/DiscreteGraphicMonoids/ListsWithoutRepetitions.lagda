
Martin Escardo and Paulo Oliva, April 2024

The type of lists without repetitions, and various facts about it.

\begin{code}

{-# OPTIONS --safe --without-K #-}

open import UF.FunExt

module DiscreteGraphicMonoids.ListsWithoutRepetitions
        (fe : Fun-Ext)
       where

open import MLTT.List
            renaming (_‚à∑_ to _‚Ä¢_ ;          -- typed as \bub
                      _++_ to _‚ó¶_ ;         -- typed as \buw
                      ++-assoc to ‚ó¶-assoc)
open import MLTT.Spartan
open import Naturals.Order
open import Notation.CanonicalMap
open import Notation.Order
open import NotionsOfDecidability.Decidable
open import UF.Base
open import UF.DiscreteAndSeparated
open import UF.Embeddings
open import UF.Subsingletons

module _
         {X : ùì§ Ãá }
         {{d' : is-discrete' X}}
       where

 private
  d : is-discrete X
  d = discrete'-gives-discrete d'

\end{code}

We first define a conditional `cons` operation, and then we use it to
define the function Œ¥ that deletes all occurences of an element from a
list.

\begin{code}

 abstract
  ccons : ({x} y : X) ‚Üí is-decidable (x Ôºù y) ‚Üí List X ‚Üí List X
  ccons y (inl e) ys = ys
  ccons y (inr u) ys = y ‚Ä¢ ys

 Œ¥ : X ‚Üí List X ‚Üí List X
 Œ¥ x []       = []
 Œ¥ x (y ‚Ä¢ ys) = ccons y (d x y) (Œ¥ x ys)

\end{code}

The following function Œ¥' is used only during development to prevent Œ¥
from reducing in more complicated expressions, and, so far, doesn't
occur in production code.

\begin{code}

 abstract
  Œ¥' : X ‚Üí List X ‚Üí List X
  Œ¥' = Œ¥

\end{code}

The following two facts are the specification of Œ¥, together with the
equation Œ¥ x [] = []. We never use the definition of `ccons` other
than in the proof of these two facts.

\begin{code}

 module _ (x y : X) (zs : List X) where

  abstract
   Œ¥-Ôºù : x Ôºù y ‚Üí Œ¥ x (y ‚Ä¢ zs) Ôºù Œ¥ x zs
   Œ¥-Ôºù e =
    Œ¥ x (y ‚Ä¢ zs)             Ôºù‚ü® refl ‚ü©
    ccons y (d x y) (Œ¥ x zs) Ôºù‚ü® ap (Œª - ‚Üí ccons y - (Œ¥ x zs)) I ‚ü©
    ccons y (inl e) (Œ¥ x zs) Ôºù‚ü® refl ‚ü©
    Œ¥ x zs                   ‚àé
     where
      I : d x y Ôºù inl e
      I = discrete-inl d x y e

   Œ¥-‚â† : x ‚â† y ‚Üí Œ¥ x (y ‚Ä¢ zs) Ôºù y ‚Ä¢ Œ¥ x zs
   Œ¥-‚â† u =
    Œ¥ x (y ‚Ä¢ zs)             Ôºù‚ü® refl ‚ü©
    ccons y (d x y) (Œ¥ x zs) Ôºù‚ü® ap (Œª - ‚Üí ccons y - (Œ¥ x zs)) I ‚ü©
    ccons y (inr u) (Œ¥ x zs) Ôºù‚ü® refl ‚ü©
    y ‚Ä¢ Œ¥ x zs               ‚àé
     where
      I : d x y Ôºù inr u
      I = discrete-inr fe d x y u

\end{code}

A particular case of `Œ¥-Ôºù` occurs more often in practice.

\begin{code}

 Œ¥-same : (x : X) (ys : List X) ‚Üí Œ¥ x (x ‚Ä¢ ys) Ôºù Œ¥ x ys
 Œ¥-same x ys = Œ¥-Ôºù x x ys refl

\end{code}

Everything about Œ¥ should be proved only from this specification, and
this is why we put it in an abstract block.

\begin{code}

 Œ¥-swap : (x y : X) (zs : List X)
        ‚Üí Œ¥ x (Œ¥ y zs) Ôºù Œ¥ y (Œ¥ x zs)
 Œ¥-swap x y []       = refl
 Œ¥-swap x y (z ‚Ä¢ zs) = h (d x z) (d y z)
  where
   IH : Œ¥ x (Œ¥ y zs) Ôºù Œ¥ y (Œ¥ x zs)
   IH = Œ¥-swap x y zs

   h : is-decidable (x Ôºù z)
     ‚Üí is-decidable (y Ôºù z)
     ‚Üí Œ¥ x (Œ¥ y (z ‚Ä¢ zs)) Ôºù Œ¥ y (Œ¥ x (z ‚Ä¢ zs))
   h (inl refl) (inl refl) = refl
   h (inl refl) (inr v) =
    Œ¥ x (Œ¥ y (x ‚Ä¢ zs)) Ôºù‚ü® ap (Œ¥ x) (Œ¥-‚â† y x zs v) ‚ü©
    Œ¥ x (x ‚Ä¢ Œ¥ y zs)   Ôºù‚ü® Œ¥-same x (Œ¥ y zs) ‚ü©
    Œ¥ x (Œ¥ y zs)       Ôºù‚ü® IH ‚ü©
    Œ¥ y (Œ¥ x zs)       Ôºù‚ü® ap (Œ¥ y) ((Œ¥-same x zs)‚Åª¬π) ‚ü©
    Œ¥ y (Œ¥ x (x ‚Ä¢ zs)) ‚àé
   h (inr u) (inl refl) =
    Œ¥ x (Œ¥ y (y ‚Ä¢ zs)) Ôºù‚ü® ap (Œ¥ x) (Œ¥-same y zs) ‚ü©
    Œ¥ x (Œ¥ y zs)       Ôºù‚ü® IH ‚ü©
    Œ¥ y (Œ¥ x zs)       Ôºù‚ü® (Œ¥-same y (Œ¥ x zs))‚Åª¬π ‚ü©
    Œ¥ y (y ‚Ä¢ Œ¥ x zs)   Ôºù‚ü® ap (Œ¥ y) (Œ¥-‚â† x y zs u)‚Åª¬π ‚ü©
    Œ¥ y (Œ¥ x (y ‚Ä¢ zs)) ‚àé
   h (inr u) (inr v) =
    Œ¥ x (Œ¥ y (z ‚Ä¢ zs)) Ôºù‚ü® ap (Œ¥ x) (Œ¥-‚â† y z zs v) ‚ü©
    Œ¥ x (z ‚Ä¢ Œ¥ y zs)   Ôºù‚ü® Œ¥-‚â† x z (Œ¥ y zs) u ‚ü©
    z ‚Ä¢ Œ¥ x (Œ¥ y zs)   Ôºù‚ü® ap (z ‚Ä¢_) IH ‚ü©
    z ‚Ä¢ Œ¥ y (Œ¥ x zs)   Ôºù‚ü® (Œ¥-‚â† y z (Œ¥ x zs) v)‚Åª¬π ‚ü©
    Œ¥ y (z ‚Ä¢ Œ¥ x zs)   Ôºù‚ü® (ap (Œ¥ y) (Œ¥-‚â† x z zs u))‚Åª¬π ‚ü©
    Œ¥ y (Œ¥ x (z ‚Ä¢ zs)) ‚àé

 Œ¥-idemp : (x : X) (ys : List X)
         ‚Üí Œ¥ x (Œ¥ x ys) Ôºù Œ¥ x ys
 Œ¥-idemp x []       = refl
 Œ¥-idemp x (y ‚Ä¢ ys) = h (d x y)
  where
   IH : Œ¥ x (Œ¥ x ys) Ôºù Œ¥ x ys
   IH = Œ¥-idemp x ys

   h : is-decidable (x Ôºù y) ‚Üí Œ¥ x (Œ¥ x (y ‚Ä¢ ys)) Ôºù Œ¥ x (y ‚Ä¢ ys)
   h (inl refl) =
    Œ¥ x (Œ¥ x (x ‚Ä¢ ys)) Ôºù‚ü® ap (Œ¥ x) (Œ¥-same x ys) ‚ü©
    Œ¥ x (Œ¥ x ys)       Ôºù‚ü® IH ‚ü©
    Œ¥ x ys             Ôºù‚ü® (Œ¥-same x ys)‚Åª¬π ‚ü©
    Œ¥ x (x ‚Ä¢ ys)       ‚àé
   h (inr u) =
    Œ¥ x (Œ¥ x (y ‚Ä¢ ys)) Ôºù‚ü® ap (Œ¥ x) (Œ¥-‚â† x y ys u) ‚ü©
    Œ¥ x (y ‚Ä¢ Œ¥ x ys)   Ôºù‚ü® Œ¥-‚â† x y (Œ¥ x ys) u ‚ü©
    y ‚Ä¢ Œ¥ x (Œ¥ x ys)   Ôºù‚ü® ap (y ‚Ä¢_) IH ‚ü©
    y ‚Ä¢ Œ¥ x ys         Ôºù‚ü® (Œ¥-‚â† x y ys u)‚Åª¬π ‚ü©
    Œ¥ x (y ‚Ä¢ ys)       ‚àé

\end{code}

The following function œÅ deletes repetitions from a list, so that a
list xs has no repetitions if and only if œÅ xs Ôºù xs (and we will take
this as our definition of no repetitions). The elements are deleted
"from left to right", so that any occurrence kept is the left-most
one.

\begin{code}

 œÅ : List X ‚Üí List X
 œÅ []       = []
 œÅ (x ‚Ä¢ xs) = x ‚Ä¢ Œ¥ x (œÅ xs)

 œÅ-is-non-empty : (xs : List X) ‚Üí is-non-empty xs ‚Üí is-non-empty (œÅ xs)
 œÅ-is-non-empty (x ‚Ä¢ xs) cons-is-non-empty = cons-is-non-empty

\end{code}

The following function œÅ' is used only during development, and, so
far, doesn't occur in production code.

\begin{code}

 œÅ' : List X ‚Üí List X
 œÅ' []       = []
 œÅ' (x ‚Ä¢ xs) = x ‚Ä¢ Œ¥' x (œÅ' xs)

 Œ¥-œÅ-cancel : (x : X) (ys : List X)
            ‚Üí Œ¥ x (œÅ (x ‚Ä¢ ys)) Ôºù Œ¥ x (œÅ ys)
 Œ¥-œÅ-cancel x ys =
  Œ¥ x (œÅ (x ‚Ä¢ ys))     Ôºù‚ü® refl ‚ü©
  Œ¥ x (x ‚Ä¢ Œ¥ x (œÅ ys)) Ôºù‚ü® Œ¥-same x (Œ¥ x (œÅ ys)) ‚ü©
  Œ¥ x (Œ¥ x (œÅ ys))     Ôºù‚ü® Œ¥-idemp x (œÅ ys) ‚ü©
  Œ¥ x (œÅ ys)           ‚àé

 Œ¥-œÅ-swap : (x : X) (ys : List X)
          ‚Üí Œ¥ x (œÅ ys) Ôºù œÅ (Œ¥ x ys)
 Œ¥-œÅ-swap x []       = refl
 Œ¥-œÅ-swap x (y ‚Ä¢ ys) = h (d x y)
  where
   IH : Œ¥ x (œÅ ys) Ôºù œÅ (Œ¥ x ys)
   IH = Œ¥-œÅ-swap x ys

   h : is-decidable (x Ôºù y) ‚Üí Œ¥ x (œÅ (y ‚Ä¢ ys)) Ôºù œÅ (Œ¥ x (y ‚Ä¢ ys))
   h (inl refl) =
    Œ¥ x (œÅ (x ‚Ä¢ ys))     Ôºù‚ü® Œ¥-œÅ-cancel x ys ‚ü©
    Œ¥ x (œÅ ys)           Ôºù‚ü® IH ‚ü©
    œÅ (Œ¥ x ys)           Ôºù‚ü® (ap œÅ (Œ¥-same x ys))‚Åª¬π ‚ü©
    œÅ (Œ¥ x (x ‚Ä¢ ys))     ‚àé
   h (inr u) =
    Œ¥ x (œÅ (y ‚Ä¢ ys))     Ôºù‚ü® refl ‚ü©
    Œ¥ x (y ‚Ä¢ Œ¥ y (œÅ ys)) Ôºù‚ü® Œ¥-‚â† x y (Œ¥ y (œÅ ys)) u ‚ü©
    y ‚Ä¢ Œ¥ x (Œ¥ y (œÅ ys)) Ôºù‚ü® ap (y ‚Ä¢_) (Œ¥-swap x y (œÅ ys)) ‚ü©
    y ‚Ä¢ Œ¥ y (Œ¥ x (œÅ ys)) Ôºù‚ü® ap (Œª - ‚Üí y ‚Ä¢ Œ¥ y -) IH ‚ü©
    y ‚Ä¢ Œ¥ y (œÅ (Œ¥ x ys)) Ôºù‚ü® refl ‚ü©
    œÅ (y ‚Ä¢ Œ¥ x ys)       Ôºù‚ü® ap œÅ ((Œ¥-‚â† x y ys u)‚Åª¬π) ‚ü©
    œÅ (Œ¥ x (y ‚Ä¢ ys))     ‚àé

\end{code}

It follows that an inner repeated deletion within œÅ may be ignored, in
the sense that

 Œ¥ z (œÅ (Œ¥ z xs)) Ôºù Œ¥ z (œÅ xs).

More generally, we have the following.

\begin{code}

 Œ¥-inner : (z : X) (xs ys : List X)
         ‚Üí Œ¥ z (œÅ (Œ¥ z xs ‚ó¶ ys)) Ôºù Œ¥ z (œÅ (xs ‚ó¶ ys))
 Œ¥-inner z []       ys = refl
 Œ¥-inner z (x ‚Ä¢ xs) ys = h (d z x)
  where
   IH : Œ¥ z (œÅ (Œ¥ z xs ‚ó¶ ys)) Ôºù Œ¥ z (œÅ (xs ‚ó¶ ys))
   IH = Œ¥-inner z xs ys

   IH' : (z : X) (ys : List X) ‚Üí Œ¥ z (œÅ (Œ¥ z xs ‚ó¶ ys)) Ôºù Œ¥ z (œÅ (xs ‚ó¶ ys))
   IH' z ys = Œ¥-inner z xs ys

   h : is-decidable (z Ôºù x)
     ‚Üí Œ¥ z (œÅ (Œ¥ z (x ‚Ä¢ xs) ‚ó¶ ys)) Ôºù Œ¥ z (œÅ (x ‚Ä¢ xs ‚ó¶ ys))
   h (inl refl) =
    Œ¥ z (œÅ (Œ¥ z (z ‚Ä¢ xs) ‚ó¶ ys)) Ôºù‚ü® I ‚ü©
    Œ¥ z (œÅ (Œ¥ z xs ‚ó¶ ys))       Ôºù‚ü® IH ‚ü©
    Œ¥ z (œÅ (xs ‚ó¶ ys))           Ôºù‚ü® II ‚ü©
    Œ¥ z (Œ¥ z (œÅ (xs ‚ó¶ ys)))     Ôºù‚ü® III ‚ü©
    Œ¥ z (z ‚Ä¢ Œ¥ z (œÅ (xs ‚ó¶ ys))) Ôºù‚ü® refl ‚ü©
    Œ¥ z (œÅ (z ‚Ä¢ xs ‚ó¶ ys))       ‚àé
     where
      I   = ap (Œª - ‚Üí Œ¥ x (œÅ (- ‚ó¶ ys))) (Œ¥-same x xs)
      II  = (Œ¥-idemp z (œÅ (xs ‚ó¶ ys)))‚Åª¬π
      III = (Œ¥-same z (Œ¥ z (œÅ (xs ‚ó¶ ys))))‚Åª¬π
   h (inr u) =
    Œ¥ z (œÅ (Œ¥ z (x ‚Ä¢ xs) ‚ó¶ ys))     Ôºù‚ü® I ‚ü©
    Œ¥ z (œÅ (x ‚Ä¢ Œ¥ z xs ‚ó¶ ys))       Ôºù‚ü® refl ‚ü©
    Œ¥ z (x ‚Ä¢ Œ¥ x (œÅ (Œ¥ z xs ‚ó¶ ys))) Ôºù‚ü® II ‚ü©
    x ‚Ä¢ Œ¥ z (Œ¥ x (œÅ (Œ¥ z xs ‚ó¶ ys))) Ôºù‚ü® III ‚ü©
    x ‚Ä¢ Œ¥ x (Œ¥ z (œÅ (Œ¥ z xs ‚ó¶ ys))) Ôºù‚ü® IV ‚ü©
    x ‚Ä¢ Œ¥ x (Œ¥ z (œÅ (xs ‚ó¶ ys)))     Ôºù‚ü® V ‚ü©
    x ‚Ä¢ Œ¥ z (Œ¥ x (œÅ (xs ‚ó¶ ys)))     Ôºù‚ü® VI ‚ü©
    Œ¥ z (x ‚Ä¢ Œ¥ x (œÅ (xs ‚ó¶ ys)))     Ôºù‚ü® refl ‚ü©
    Œ¥ z (œÅ (x ‚Ä¢ xs ‚ó¶ ys))           ‚àé
     where
      I   = ap (Œª - ‚Üí Œ¥ z (œÅ (- ‚ó¶ ys))) (Œ¥-‚â† z x xs u)
      II  = Œ¥-‚â† z x (Œ¥ x (œÅ (Œ¥ z xs ‚ó¶ ys))) u
      III = ap (x ‚Ä¢_) (Œ¥-swap z x (œÅ (Œ¥ z xs ‚ó¶ ys)))
      IV  = ap (Œª - ‚Üí x ‚Ä¢ Œ¥ x -) IH
      V   = ap (x ‚Ä¢_) (Œ¥-swap x z (œÅ (xs ‚ó¶ ys)))
      VI  = (Œ¥-‚â† z x (Œ¥ x (œÅ (xs ‚ó¶ ys))) u)‚Åª¬π

 œÅ-left : (xs ys : List X) ‚Üí œÅ (œÅ xs ‚ó¶ ys) Ôºù œÅ (xs ‚ó¶ ys)
 œÅ-left []       ys = refl
 œÅ-left (x ‚Ä¢ xs) ys =
  œÅ (œÅ (x ‚Ä¢ xs) ‚ó¶ ys)           Ôºù‚ü® refl ‚ü©
  x ‚Ä¢ Œ¥ x (œÅ (Œ¥ x (œÅ xs) ‚ó¶ ys)) Ôºù‚ü® I ‚ü©
  x ‚Ä¢ Œ¥ x (œÅ (œÅ xs ‚ó¶ ys))       Ôºù‚ü® II ‚ü©
  x ‚Ä¢ Œ¥ x (œÅ (xs ‚ó¶ ys))         Ôºù‚ü® refl ‚ü©
  œÅ (x ‚Ä¢ xs ‚ó¶ ys)               ‚àé
   where
    IH : œÅ (œÅ xs ‚ó¶ ys) Ôºù œÅ (xs ‚ó¶ ys)
    IH = œÅ-left xs ys

    I  = ap (x ‚Ä¢_) (Œ¥-inner x (œÅ xs) ys)
    II = ap (Œª - ‚Üí x ‚Ä¢ Œ¥ x -) IH

 œÅ-idemp : (xs : List X) ‚Üí œÅ (œÅ xs) Ôºù œÅ xs
 œÅ-idemp xs =
  œÅ (œÅ xs)      Ôºù‚ü® ap œÅ ([]-right-neutral (œÅ xs)) ‚ü©
  œÅ (œÅ xs ‚ó¶ []) Ôºù‚ü® œÅ-left xs [] ‚ü©
  œÅ (xs ‚ó¶ [])   Ôºù‚ü® ap œÅ (([]-right-neutral xs)‚Åª¬π) ‚ü©
  œÅ xs          ‚àé

 œÅ-right : (xs ys : List X) ‚Üí œÅ (xs ‚ó¶ œÅ ys) Ôºù œÅ (xs ‚ó¶ ys)
 œÅ-right [] ys = œÅ-idemp ys
 œÅ-right (x ‚Ä¢ xs) ys =
  œÅ (x ‚Ä¢ xs ‚ó¶ œÅ ys)       Ôºù‚ü® refl ‚ü©
  x ‚Ä¢ Œ¥ x (œÅ (xs ‚ó¶ œÅ ys)) Ôºù‚ü® ap (Œª - ‚Üí x ‚Ä¢ Œ¥ x -) IH ‚ü©
  x ‚Ä¢ Œ¥ x (œÅ (xs ‚ó¶ ys))   Ôºù‚ü® refl ‚ü©
  œÅ (x ‚Ä¢ xs ‚ó¶ ys) ‚àé
  where
   IH : œÅ (xs ‚ó¶ œÅ ys) Ôºù œÅ (xs ‚ó¶ ys)
   IH = œÅ-right xs ys

 œÅ-both : (xs ys : List X) ‚Üí œÅ (œÅ xs ‚ó¶ œÅ ys) Ôºù œÅ (xs ‚ó¶ ys)
 œÅ-both xs ys =
  œÅ (œÅ xs ‚ó¶ œÅ ys) Ôºù‚ü® œÅ-left xs (œÅ ys) ‚ü©
  œÅ (xs ‚ó¶ œÅ ys)   Ôºù‚ü® œÅ-right xs ys ‚ü©
  œÅ (xs ‚ó¶ ys)     ‚àé

 œÅ-tail : (x : X) (xs : List X)
        ‚Üí œÅ (x ‚Ä¢ xs) Ôºù x ‚Ä¢ xs
        ‚Üí œÅ xs Ôºù xs
 œÅ-tail x xs a =
  œÅ xs           Ôºù‚ü® ap œÅ ((equal-tails a)‚Åª¬π) ‚ü©
  œÅ (Œ¥ x (œÅ xs)) Ôºù‚ü® (Œ¥-œÅ-swap x (œÅ xs))‚Åª¬π ‚ü©
  Œ¥ x (œÅ (œÅ xs)) Ôºù‚ü® ap (Œ¥ x) (œÅ-idemp xs) ‚ü©
  Œ¥ x (œÅ xs)     Ôºù‚ü® equal-tails a ‚ü©
  xs             ‚àé
   where
    notice : x ‚Ä¢ Œ¥ x (œÅ xs) Ôºù x ‚Ä¢ xs
    notice = a

 has-no-reps : (xs : List X) ‚Üí ùì§ Ãá
 has-no-reps xs = œÅ xs Ôºù xs

\end{code}

The following two technical lemmas, which are probably not very well
named, and are used to show that the that monad of non-empty lists
without repetitions is affine, in another module.WS

\begin{code}

 Œ¥-deletion-lemma : (y : X) (xs : List X)
                  ‚Üí ¬¨ (Œ£ zs Íûâ List X , (Œ¥ y xs Ôºù y ‚Ä¢ zs))
 Œ¥-deletion-lemma y (x ‚Ä¢ xs) (zs , p) = h (d y x)
  where
   h : ¬¨ is-decidable (y Ôºù x)
   h (inl refl) = Œ¥-deletion-lemma y xs
                   (zs , (Œ¥ y xs       Ôºù‚ü® (Œ¥-same y xs)‚Åª¬π ‚ü©
                          Œ¥ y (y ‚Ä¢ xs) Ôºù‚ü® p ‚ü©
                          y ‚Ä¢ zs       ‚àé))

   h (inr u) = u (equal-heads (y ‚Ä¢ zs       Ôºù‚ü® p ‚Åª¬π ‚ü©
                               Œ¥ y (x ‚Ä¢ xs) Ôºù‚ü® Œ¥-‚â† y x xs u ‚ü©
                               x ‚Ä¢ Œ¥ y xs   ‚àé))

 repetition-lemma : (x : X) (xs : List X)
                  ‚Üí ¬¨ has-no-reps (x ‚Ä¢ x ‚Ä¢ xs)
 repetition-lemma x xs p = Œ¥-deletion-lemma x (x ‚Ä¢ xs) (xs , III)
  where
   have-p : œÅ (x ‚Ä¢ x ‚Ä¢ xs) Ôºù x ‚Ä¢ x ‚Ä¢ xs
   have-p = p

   remark : x ‚Ä¢ Œ¥ x (x ‚Ä¢ Œ¥ x (œÅ xs)) Ôºù x ‚Ä¢ x ‚Ä¢ xs
   remark = p

   I : œÅ (x ‚Ä¢ xs) Ôºù x ‚Ä¢ xs
   I = œÅ-tail x (x ‚Ä¢ xs) p

   II : Œ¥ x (œÅ (x ‚Ä¢ xs)) Ôºù x ‚Ä¢ xs
   II = equal-tails p

   III : Œ¥ x (x ‚Ä¢ xs) Ôºù x ‚Ä¢ xs
   III = transport (Œª - ‚Üí Œ¥ x - Ôºù x ‚Ä¢ xs) I II

\end{code}

We temporarily exit the above anonymous module to make the argument X
explicit.

\begin{code}

List‚Åª : (X : ùì§ Ãá ) {{_ : is-discrete' X}} ‚Üí ùì§ Ãá
List‚Åª X = Œ£ xs Íûâ List X , has-no-reps xs

\end{code}

And now we work again in an anonymous module with X implicit.

\begin{code}

module _ {X : ùì§ Ãá }
         {{d' : is-discrete' X}}
       where

 private
  d : is-discrete X
  d = discrete'-gives-discrete d'

 Œ∑‚Åª : X ‚Üí List‚Åª X
 Œ∑‚Åª x = (x ‚Ä¢ []) , refl

 underlying-list : List‚Åª X ‚Üí List X
 underlying-list = pr‚ÇÅ

 instance
  canonical-map-List‚Åª-to-List : Canonical-Map (List‚Åª X) (List X)
  Œπ {{canonical-map-List‚Åª-to-List}} = underlying-list

 underlying-list-has-no-reps : (ùîÅùìà : List‚Åª X) ‚Üí has-no-reps (Œπ ùîÅùìà)
 underlying-list-has-no-reps = pr‚ÇÇ

\end{code}

The symbol ‚äô can be typed a "\o." or "\odot".

\begin{code}

 _‚äô_ : List X ‚Üí List X ‚Üí List X
 xs ‚äô ys = œÅ (xs ‚ó¶ ys)

 ‚äô-assoc : (a b c : List X) ‚Üí a ‚äô (b ‚äô c) Ôºù (a ‚äô b) ‚äô c
 ‚äô-assoc a b c =
  a ‚äô (b ‚äô c)       Ôºù‚ü® refl ‚ü©
  œÅ (a ‚ó¶ œÅ (b ‚ó¶ c)) Ôºù‚ü® œÅ-right a (b ‚ó¶ c) ‚ü©
  œÅ (a ‚ó¶ (b ‚ó¶ c))   Ôºù‚ü® ap œÅ ((‚ó¶-assoc a b c)‚Åª¬π) ‚ü©
  œÅ ((a ‚ó¶ b) ‚ó¶ c)   Ôºù‚ü® (œÅ-left (a ‚ó¶ b) c)‚Åª¬π ‚ü©
  œÅ (œÅ (a ‚ó¶ b) ‚ó¶ c) Ôºù‚ü® refl ‚ü©
  (a ‚äô b) ‚äô c       ‚àé

 _¬∑_ : List‚Åª X ‚Üí List‚Åª X ‚Üí List‚Åª X
 (xs , a) ¬∑ (ys , b) =
   xs ‚äô ys ,
   (œÅ (xs ‚äô ys)         Ôºù‚ü® ap‚ÇÇ (Œª -‚ÇÅ -‚ÇÇ ‚Üí œÅ (-‚ÇÅ ‚äô -‚ÇÇ)) (a ‚Åª¬π) (b ‚Åª¬π) ‚ü©
    œÅ (œÅ xs ‚äô œÅ ys)     Ôºù‚ü® refl ‚ü©
    œÅ (œÅ (œÅ xs ‚ó¶ œÅ ys)) Ôºù‚ü® œÅ-idemp (œÅ xs ‚ó¶ œÅ ys) ‚ü©
    œÅ (œÅ xs ‚ó¶ œÅ ys)     Ôºù‚ü® œÅ-both xs ys ‚ü©
    œÅ (xs ‚ó¶ ys)         Ôºù‚ü® refl ‚ü©
    (xs ‚äô ys)           ‚àé)

 []‚Åª : List‚Åª X
 []‚Åª = [] , refl

 List-is-discrete : is-discrete (List X)
 List-is-discrete [] [] = inl refl
 List-is-discrete [] (x ‚Ä¢ ys) = inr ([]-is-not-cons x ys)
 List-is-discrete (x ‚Ä¢ xs) [] = inr (‚â†-sym ([]-is-not-cons x xs))
 List-is-discrete (x ‚Ä¢ xs) (y ‚Ä¢ ys) with d x y
 ... | inl refl =
     Cases (List-is-discrete xs ys)
      (Œª e ‚Üí inl (ap (x ‚Ä¢_) e))
      (Œª ŒΩ ‚Üí inr (Œª e ‚Üí ŒΩ (equal-tails e)))
 ... | inr ŒΩ = inr (Œª e ‚Üí ŒΩ (equal-heads e))

 having-no-reps-is-prop : (xs : List X) ‚Üí is-prop (has-no-reps xs)
 having-no-reps-is-prop xs = discrete-types-are-sets List-is-discrete

 underlying-list-is-embedding : is-embedding underlying-list
 underlying-list-is-embedding = pr‚ÇÅ-is-embedding having-no-reps-is-prop

 to-List‚Åª-Ôºù : {ùîÅùìº ùîÇùìº : List‚Åª X} ‚Üí Œπ ùîÅùìº Ôºù Œπ ùîÇùìº ‚Üí ùîÅùìº Ôºù ùîÇùìº
 to-List‚Åª-Ôºù = to-subtype-Ôºù having-no-reps-is-prop

 ¬∑-lemma : (x : X) (xs : List X) (a : has-no-reps (x ‚Ä¢ xs))
         ‚Üí ((x ‚Ä¢ xs) , a) Ôºù[ List‚Åª X ] (Œ∑‚Åª x ¬∑ (xs , œÅ-tail x xs a))
 ¬∑-lemma x xs a =
  to-List‚Åª-Ôºù(x ‚Ä¢ xs         Ôºù‚ü® ap (x ‚Ä¢_) (equal-tails a)‚Åª¬π ‚ü©
              x ‚Ä¢ Œ¥ x (œÅ xs) Ôºù‚ü® refl ‚ü©
              Œπ (Œ∑‚Åª x) ‚äô xs  ‚àé)
   where
    have-a : œÅ (x ‚Ä¢ xs) Ôºù x ‚Ä¢ xs
    have-a = a

    remark : x ‚Ä¢ Œ¥ x (œÅ xs) Ôºù x ‚Ä¢ xs
    remark = a

    b : œÅ xs Ôºù xs
    b = œÅ-tail x xs a

    ùîÅùìº : List‚Åª X
    ùîÅùìº = xs , b

 List‚Åª-is-discrete : is-discrete (List‚Åª X)
 List‚Åª-is-discrete (xs , _) (ys , _) with List-is-discrete xs ys
 ... | inl e = inl (to-List‚Åª-Ôºù e)
 ... | inr u = inr (Œª (e : (xs , _) Ôºù (ys , _)) ‚Üí u (ap Œπ e))

 instance
  List‚Åª-is-discrete' : is-discrete' (List‚Åª X)
  List‚Åª-is-discrete' = discrete-gives-discrete' List‚Åª-is-discrete

 []‚Åª-left-neutral : (ùîÅùìº : List‚Åª X) ‚Üí []‚Åª ¬∑ ùîÅùìº Ôºù ùîÅùìº
 []‚Åª-left-neutral ùîÅùìº =
  to-List‚Åª-Ôºù
   (Œπ ([]‚Åª ¬∑ ùîÅùìº) Ôºù‚ü® refl ‚ü©
    œÅ (Œπ ùîÅùìº)     Ôºù‚ü® underlying-list-has-no-reps ùîÅùìº ‚ü©
    Œπ ùîÅùìº         ‚àé)

 []‚Åª-right-neutral : (ùîÅùìº : List‚Åª X) ‚Üí ùîÅùìº ¬∑ []‚Åª Ôºù ùîÅùìº
 []‚Åª-right-neutral ùîÅùìº =
  to-List‚Åª-Ôºù
   (Œπ (ùîÅùìº ¬∑ []‚Åª)  Ôºù‚ü® refl ‚ü©
    œÅ (Œπ ùîÅùìº ‚ó¶ []) Ôºù‚ü® ap œÅ (([]-right-neutral (Œπ ùîÅùìº))‚Åª¬π) ‚ü©
    œÅ (Œπ ùîÅùìº)      Ôºù‚ü® underlying-list-has-no-reps ùîÅùìº ‚ü©
    Œπ ùîÅùìº          ‚àé)

 ¬∑-assoc : (ùîÅùìº ùîÇùìº ùîÉùìº : List‚Åª X) ‚Üí ùîÅùìº ¬∑ (ùîÇùìº ¬∑ ùîÉùìº) Ôºù (ùîÅùìº ¬∑ ùîÇùìº) ¬∑ ùîÉùìº
 ¬∑-assoc (xs , _) (ys , _) (zs , _) =
  to-subtype-Ôºù having-no-reps-is-prop (‚äô-assoc xs ys zs)

 Œ¥-‚ó¶ : (z : X) (xs ys : List X)
     ‚Üí Œ¥ z (xs ‚ó¶ ys) Ôºù Œ¥ z xs ‚ó¶ Œ¥ z ys
 Œ¥-‚ó¶ z [] ys = refl
 Œ¥-‚ó¶ z (x ‚Ä¢ xs) ys = h (d z x)
  where
   h : is-decidable (z Ôºù x) ‚Üí Œ¥ z (x ‚Ä¢ xs ‚ó¶ ys) Ôºù Œ¥ z (x ‚Ä¢ xs) ‚ó¶ Œ¥ z ys
   h (inl refl) =
    Œ¥ z (z ‚Ä¢ xs ‚ó¶ ys)     Ôºù‚ü® Œ¥-same z (xs ‚ó¶ ys) ‚ü©
    Œ¥ z (xs ‚ó¶ ys)         Ôºù‚ü® Œ¥-‚ó¶ z xs ys ‚ü©
    Œ¥ z xs ‚ó¶ Œ¥ z ys       Ôºù‚ü® ap (_‚ó¶ Œ¥ z ys) ((Œ¥-same z xs)‚Åª¬π) ‚ü©
    Œ¥ z (z ‚Ä¢ xs) ‚ó¶ Œ¥ z ys ‚àé
   h (inr u) =
    Œ¥ z (x ‚Ä¢ xs ‚ó¶ ys)     Ôºù‚ü® Œ¥-‚â† z x (xs ‚ó¶ ys) u ‚ü©
    x ‚Ä¢ Œ¥ z (xs ‚ó¶ ys)     Ôºù‚ü® ap (x ‚Ä¢_) (Œ¥-‚ó¶ z xs ys) ‚ü©
    x ‚Ä¢ (Œ¥ z xs ‚ó¶ Œ¥ z ys) Ôºù‚ü® refl ‚ü©
    x ‚Ä¢ Œ¥ z xs ‚ó¶ Œ¥ z ys   Ôºù‚ü® ap (_‚ó¶ Œ¥ z ys) ((Œ¥-‚â† z x xs u)‚Åª¬π) ‚ü©
    Œ¥ z (x ‚Ä¢ xs) ‚ó¶ Œ¥ z ys ‚àé

 Œî : List X ‚Üí List X ‚Üí List X
 Œî [] xs       = xs
 Œî (y ‚Ä¢ ys) xs = Œ¥ y (Œî ys xs )

 Œ¥-Œî-left : (z : X) (xs ys : List X)
          ‚Üí Œ¥ z (Œî ys xs) Ôºù Œî ys (Œ¥ z xs)
 Œ¥-Œî-left z xs [] = refl
 Œ¥-Œî-left z xs (x ‚Ä¢ ys) =
  Œ¥ z (Œî (x ‚Ä¢ ys) xs) Ôºù‚ü® refl ‚ü©
  Œ¥ z (Œ¥ x (Œî ys xs)) Ôºù‚ü® Œ¥-swap z x (Œî ys xs) ‚ü©
  Œ¥ x (Œ¥ z (Œî ys xs)) Ôºù‚ü® ap (Œ¥ x) (Œ¥-Œî-left z xs ys) ‚ü©
  Œ¥ x (Œî ys (Œ¥ z xs)) Ôºù‚ü® refl ‚ü©
  Œî (x ‚Ä¢ ys) (Œ¥ z xs) ‚àé

 []-Œî : (ys : List X) ‚Üí Œî ys [] Ôºù []
 []-Œî []       = refl
 []-Œî (y ‚Ä¢ ys) = ap (Œ¥ y) ([]-Œî ys)

 œÅ-‚ó¶ : (xs ys : List X)
     ‚Üí œÅ (xs ‚ó¶ ys) Ôºù œÅ xs ‚ó¶ Œî xs (œÅ ys)
 œÅ-‚ó¶ [] ys = refl
 œÅ-‚ó¶ (x ‚Ä¢ xs) ys =
  œÅ (x ‚Ä¢ xs ‚ó¶ ys)                      Ôºù‚ü® refl ‚ü©
  x ‚Ä¢ Œ¥ x (œÅ (xs ‚ó¶ ys))                Ôºù‚ü® ap (Œª - ‚Üí x ‚Ä¢ Œ¥ x -) (œÅ-‚ó¶ xs ys) ‚ü©
  x ‚Ä¢ Œ¥ x (œÅ xs ‚ó¶ Œî xs (œÅ ys ))        Ôºù‚ü® ap (x ‚Ä¢_ ) (Œ¥-‚ó¶ x (œÅ xs) (Œî xs (œÅ ys))) ‚ü©
  x ‚Ä¢ (Œ¥ x (œÅ xs) ‚ó¶ Œ¥ x (Œî xs (œÅ ys))) Ôºù‚ü® refl ‚ü©
  œÅ (x ‚Ä¢ xs) ‚ó¶ (Œî (x ‚Ä¢ xs) (œÅ ys))     ‚àé

 œÅ-all : (xs ys : List X) ‚Üí Œî (xs ‚ó¶ ys) (œÅ xs) Ôºù []
 œÅ-all [] ys = []-Œî ys
 œÅ-all (x ‚Ä¢ xs) ys =
  Œî (x ‚Ä¢ xs ‚ó¶ ys) (œÅ (x ‚Ä¢ xs))       Ôºù‚ü® refl ‚ü©
  Œ¥ x (Œî (xs ‚ó¶ ys) (x ‚Ä¢ Œ¥ x (œÅ xs))) Ôºù‚ü® I ‚ü©
  Œî (xs ‚ó¶ ys) (Œ¥ x (x ‚Ä¢ Œ¥ x (œÅ xs))) Ôºù‚ü® II ‚ü©
  Œî (xs ‚ó¶ ys) (Œ¥ x (Œ¥ x (œÅ xs)))     Ôºù‚ü® III ‚ü©
  Œî (xs ‚ó¶ ys) (Œ¥ x (œÅ xs))           Ôºù‚ü® IV ‚ü©
  Œ¥ x (Œî (xs ‚ó¶ ys) (œÅ xs))           Ôºù‚ü® V ‚ü©
  Œ¥ x []                             Ôºù‚ü® refl ‚ü©
  []                                 ‚àé
   where
    I   = Œ¥-Œî-left x (x ‚Ä¢ Œ¥ x (œÅ xs)) (xs ‚ó¶ ys)
    II  = ap (Œî (xs ‚ó¶ ys)) (Œ¥-same x (Œ¥ x (œÅ xs)))
    III = ap (Œî (xs ‚ó¶ ys)) (Œ¥-idemp x (œÅ xs))
    IV  = (Œ¥-Œî-left x (œÅ xs) (xs ‚ó¶ ys))‚Åª¬π
    V   = ap (Œ¥ x) (œÅ-all xs ys)

 Œ¥-length : (z : X) (xs : List X)
          ‚Üí length (Œ¥ z xs) ‚â§ length xs
 Œ¥-length z []       = zero-least 0
 Œ¥-length z (x ‚Ä¢ xs) = h (d z x)
  where
   IH : length (Œ¥ z xs) ‚â§ length xs
   IH = Œ¥-length z xs

   h : is-decidable (z Ôºù x) ‚Üí length (Œ¥ z (x ‚Ä¢ xs)) ‚â§ succ (length xs)
   h (inl refl) = transport‚Åª¬π (_‚â§ succ (length xs)) I II
    where
     I : length (Œ¥ z (x ‚Ä¢ xs)) Ôºù length (Œ¥ z xs)
     I = ap length (Œ¥-same z xs)

     II : length (Œ¥ z xs) ‚â§ succ (length xs)
     II = ‚â§-trans (length (Œ¥ z xs)) (length xs) (succ (length xs))
           IH
           (‚â§-succ (length xs))
   h (inr u) = transport‚Åª¬π (_‚â§ succ (length xs)) I II
    where
     I : length (Œ¥ z (x ‚Ä¢ xs)) Ôºù length (x ‚Ä¢ Œ¥ z xs)
     I = ap length (Œ¥-‚â† z x xs u)

     II : length (x ‚Ä¢ Œ¥ z xs) ‚â§ succ (length xs)
     II = succ-monotone (length (Œ¥ z xs)) (length xs) IH

module _ {X : ùì§ Ãá }
         {Y : ùì• Ãá }
         {{X-is-discrete' : is-discrete' X}}
         {{Y-is-discrete' : is-discrete' Y}}
         (f : X ‚Üí Y)
       where

 Œ¥-map : (z : X) (xs : List X)
       ‚Üí Œ¥ (f z) (map f (Œ¥ z xs)) Ôºù Œ¥ (f z) (map f xs)
 Œ¥-map z [] = refl
 Œ¥-map z (x ‚Ä¢ xs) = h (discrete'-gives-discrete X-is-discrete' z x)
  where
   h : is-decidable (z Ôºù x)
     ‚Üí Œ¥ (f z) (map f (Œ¥ z (x ‚Ä¢ xs))) Ôºù Œ¥ (f z) (map f (x ‚Ä¢ xs))
   h (inl refl) =
    Œ¥ (f z) (map f (Œ¥ z (z ‚Ä¢ xs))) Ôºù‚ü® I ‚ü©
    Œ¥ (f z) (map f (Œ¥ z xs))       Ôºù‚ü® IH ‚ü©
    Œ¥ (f z) (map f xs)             Ôºù‚ü® II ‚ü©
    Œ¥ (f z) (f z ‚Ä¢ map f xs)       Ôºù‚ü® refl ‚ü©
    Œ¥ (f z) (map f (z ‚Ä¢ xs))       ‚àé
     where
      I  = ap (Œª - ‚Üí Œ¥ (f z) (map f -)) (Œ¥-same z xs)
      IH = Œ¥-map z xs
      II = (Œ¥-same (f z) (map f xs))‚Åª¬π
   h (inr u) =
    Œ¥ (f z) (map f (Œ¥ z (x ‚Ä¢ xs))) Ôºù‚ü® I ‚ü©
    Œ¥ (f z) (map f (x ‚Ä¢ Œ¥ z xs))   Ôºù‚ü® refl ‚ü©
    Œ¥ (f z) (f x ‚Ä¢ map f (Œ¥ z xs)) Ôºù‚ü® II ‚ü©
    Œ¥ (f z) (f x ‚Ä¢ map f xs)       Ôºù‚ü® refl ‚ü©
    Œ¥ (f z) (map f (x ‚Ä¢ xs))       ‚àé
     where
      I = ap (Œª - ‚Üí Œ¥ (f z) (map f -)) (Œ¥-‚â† z x xs u)
      II = g (discrete'-gives-discrete Y-is-discrete' (f z) (f x))
       where
        g : is-decidable (f z Ôºù f x)
          ‚Üí Œ¥ (f z) (f x ‚Ä¢ map f (Œ¥ z xs)) Ôºù Œ¥ (f z) (f x ‚Ä¢ map f xs)
        g (inl e) =
         Œ¥ (f z) (f x ‚Ä¢ map f (Œ¥ z xs)) Ôºù‚ü® III ‚ü©
         Œ¥ (f z) (map f (Œ¥ z xs))       Ôºù‚ü® IV ‚ü©
         Œ¥ (f z) (map f xs)             Ôºù‚ü® V ‚ü©
         Œ¥ (f z) (f x ‚Ä¢ map f xs)       ‚àé
          where
           III = Œ¥-Ôºù (f z) (f x) (map f (Œ¥ z xs)) e
           IV  = Œ¥-map z xs
           V   = (Œ¥-Ôºù (f z) (f x) (map f xs) e)‚Åª¬π
        g (inr u) =
         Œ¥ (f z) (f x ‚Ä¢ map f (Œ¥ z xs)) Ôºù‚ü® III ‚ü©
         f x ‚Ä¢ Œ¥ (f z) (map f (Œ¥ z xs)) Ôºù‚ü® IV ‚ü©
         f x ‚Ä¢ Œ¥ (f z) (map f xs)       Ôºù‚ü® V ‚ü©
         Œ¥ (f z) (f x ‚Ä¢ map f xs)       ‚àé
          where
           III = Œ¥-‚â† (f z) (f x) (map f (Œ¥ z xs)) u
           IV  = ap (f x ‚Ä¢_) (Œ¥-map z xs)
           V   = (Œ¥-‚â† (f z) (f x) (map f xs) u)‚Åª¬π

 œÅ-map-lemma : (xs ys : List X)
             ‚Üí œÅ xs Ôºù œÅ ys
             ‚Üí œÅ (map f xs) Ôºù œÅ (map f ys)
 œÅ-map-lemma = course-of-values-induction-on-length _ h
  where
   h : (xs : List X)
     ‚Üí ((ys : List X)
            ‚Üí length ys < length xs
            ‚Üí (ys' : List X)
            ‚Üí œÅ ys Ôºù œÅ ys'
            ‚Üí œÅ (map f ys) Ôºù œÅ (map f ys'))
     ‚Üí (ys : List X) ‚Üí œÅ xs Ôºù œÅ ys ‚Üí œÅ (map f xs) Ôºù œÅ (map f ys)
   h [] IH [] refl = refl
   h (x ‚Ä¢ xs) IH (y ‚Ä¢ ys) e = II
    where
     I = œÅ (Œ¥ x xs) Ôºù‚ü® (Œ¥-œÅ-swap x xs)‚Åª¬π ‚ü©
         Œ¥ x (œÅ xs) Ôºù‚ü® equal-tails e ‚ü©
         Œ¥ y (œÅ ys) Ôºù‚ü® ap (Œª - ‚Üí Œ¥ - (œÅ ys)) (equal-heads (e ‚Åª¬π)) ‚ü©
         Œ¥ x (œÅ ys) Ôºù‚ü® Œ¥-œÅ-swap x ys ‚ü©
         œÅ (Œ¥ x ys) ‚àé

     II = œÅ (map f (x ‚Ä¢ xs))                 Ôºù‚ü® refl ‚ü©
          f x ‚Ä¢ Œ¥ (f x) (œÅ (map f xs))       Ôºù‚ü® III ‚ü©
          f x ‚Ä¢ œÅ (Œ¥ (f x) (map f xs))       Ôºù‚ü® IV ‚ü©
          f x ‚Ä¢ œÅ (Œ¥ (f x) (map f (Œ¥ x xs))) Ôºù‚ü® V ‚ü©
          f x ‚Ä¢ Œ¥ (f x) (œÅ (map f (Œ¥ x xs))) Ôºù‚ü® VI ‚ü©
          f x ‚Ä¢ Œ¥ (f x) (œÅ (map f (Œ¥ x ys))) Ôºù‚ü® VII ‚ü©
          f x ‚Ä¢ œÅ (Œ¥ (f x) (map f (Œ¥ x ys))) Ôºù‚ü® VIII ‚ü©
          f x ‚Ä¢ œÅ (Œ¥ (f x) (map f ys))       Ôºù‚ü® IX ‚ü©
          f x ‚Ä¢ Œ¥ (f x) (œÅ (map f ys))       Ôºù‚ü® XI ‚ü©
          f y ‚Ä¢ Œ¥ (f y) (œÅ (map f ys))       Ôºù‚ü® refl ‚ü©
          œÅ (map f (y ‚Ä¢ ys))                 ‚àé
       where
        III  = ap (f x ‚Ä¢_) (Œ¥-œÅ-swap (f x) (map f xs))
        IV   = ap (Œª - ‚Üí f x ‚Ä¢ œÅ -) ((Œ¥-map x xs)‚Åª¬π)
        V    = ap (f x ‚Ä¢_) ((Œ¥-œÅ-swap (f x) (map f (Œ¥ x xs)))‚Åª¬π)
        VI   = ap (Œª - ‚Üí f x ‚Ä¢ Œ¥ (f x) -) (IH (Œ¥ x xs) (Œ¥-length x xs) (Œ¥ x ys) I)
        VII  = ap (f x ‚Ä¢_) (Œ¥-œÅ-swap (f x) (map f (Œ¥ x ys)))
        VIII = ap (Œª - ‚Üí f x ‚Ä¢ œÅ -) (Œ¥-map x ys)
        IX   = ap (f x ‚Ä¢_) ((Œ¥-œÅ-swap (f x) (map f ys))‚Åª¬π)
        XI   = ap (Œª - ‚Üí f - ‚Ä¢ Œ¥ (f -) (œÅ (map f ys))) (equal-heads e)

 œÅ-map : (xs : List X)
       ‚Üí œÅ (map f (œÅ xs)) Ôºù œÅ (map f xs)
 œÅ-map xs = œÅ-map-lemma (œÅ xs) xs (œÅ-idemp xs)

\end{code}
