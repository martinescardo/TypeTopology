Martin Escardo, 17th August 2024 and 18th September 2024.

A develop and generalize a result from 2013/03/13 first advertised in
the IAS Univalent Foundations mailing list in response to a question
by Andrej Bauer [1]:

If A : ‚Ñï ‚Üí ùì§ is a family of decidable types,
then

   ‚à• Œ£ n Íûâ ‚Ñï , A n ‚à• ‚Üí Œ£ n : ‚Ñï , A n.

This may seem surprising at first sight. The original proof in [1]
uses function extensionality and the assumption that A is
proposition-valued to show that the type

  A m √ó ((k : ‚Ñï) ‚Üí A k ‚Üí m ‚â§ k

is a proposition for any m. But, using the results of [2] (or its
extended version [3]), we can remove both assumptions.

Moreover, in [4] we show that, more generally, if A : ‚Ñï ‚Üí ùì§ is a
family of propositions such that A (n + 1) implies that A n is
decidable, then

   ‚à• Œ£ n Íûâ ‚Ñï , A n ‚à• ‚Üí Œ£ n : ‚Ñï , A n,

again with a proof that assumes function extensionality. Here, using
[2], we are able to remove the assumption of function extensionlity,
but not that assumption that A is proposition-valued.

Moreover, we can construct the propositional truncation of the type
Œ£ n Íûâ ‚Ñï , A n in pure Spartan MLTT without assuming that propositional
truncations exist in general, by considering the type of fixed points
of a minimization endomap of Œ£ n Íûâ ‚Ñï , A n. See the module UF.ExitPropTrunc.

1. Martin Escardo. 2013/03/13 message to the IAS Univalent Foundations
   mailing list.
   https://groups.google.com/g/univalent-foundations/c/SA0dzenV1G4/m/d5iIGdKKNxMJ

2. Nicolai Kraus, Mart√≠n Escard√≥, Thierry Coquand & Thorsten Altenkirch.
   Generalizations of Hedberg‚Äôs Theorem.
   TLCA 2013
   https://doi.org/10.1007/978-3-642-38946-7_14

3. Nicolai Kraus, Mart√≠n Escard√≥, Thierry Coquand & Thorsten Altenkirch.
   Notions of Anonymous Existence in Martin-L√∂f Type Theory.
   Logical Methods in Computer Science, March 24, 2017, Volume 13, Issue 1.
   https://doi.org/10.23638/LMCS-13(1:15)2017

4. Mart√≠n H. Escard√≥ and Chuangjie Xu. The inconsistency of a
   Brouwerian continuity principle with the Curry-Howard
   interpretation. 13th International Conference on Typed Lambda
   Calculi and Applications (TLCA 2015).

   https://drops.dagstuhl.de/opus/portals/lipics/index.php?semnr=15006
   https://doi.org/10.4230/LIPIcs.TLCA.2015.153

although it was presented with a different proof that assumes function
extensionlity.

\begin{code}

{-# OPTIONS --safe --without-K #-}

module Naturals.ExitTruncation where

open import MLTT.Spartan
open import Naturals.Order
open import Notation.Order
open import NotionsOfDecidability.Complemented
open import NotionsOfDecidability.Decidable
open import UF.DiscreteAndSeparated
open import UF.Hedberg
open import UF.KrausLemma
open import UF.ExitPropTrunc
open import UF.PropTrunc
open import UF.Subsingletons

module _ (A : ‚Ñï ‚Üí ùì§ Ãá )
         (Œ¥ : (n : ‚Ñï) ‚Üí A n ‚Üí (k : ‚Ñï) ‚Üí k < n ‚Üí is-decidable (A k))
       where

 minimal-witness‚Å∫ : (Œ£ n Íûâ ‚Ñï , A n)
                  ‚Üí Œ£ k Íûâ ‚Ñï , (A k √ó ((i : ‚Ñï) ‚Üí A i ‚Üí k ‚â§ i))
 minimal-witness‚Å∫ = uncurry (Œº A Œ¥)
  where
   Œº : (A : ‚Ñï ‚Üí ùì§ Ãá )
     ‚Üí ((n : ‚Ñï) ‚Üí A n ‚Üí (k : ‚Ñï) ‚Üí k < n ‚Üí is-decidable (A k))
     ‚Üí (n : ‚Ñï)
     ‚Üí A n
     ‚Üí Œ£ k Íûâ ‚Ñï , (A k √ó ((i : ‚Ñï) ‚Üí A i ‚Üí k ‚â§ i))
   Œº A Œ¥ 0        a‚ÇÄ   = 0 , a‚ÇÄ , (Œª i a·µ¢ ‚Üí zero-least i)
   Œº A Œ¥ (succ n) a‚Çô‚Çä‚ÇÅ = II
    where
     IH : Œ£ j Íûâ ‚Ñï , ((A (succ j) √ó ((i : ‚Ñï) ‚Üí A (succ i) ‚Üí j ‚â§ i)))
     IH = Œº (A ‚àò succ) (Œª n a‚Çô‚Çä‚ÇÅ j ‚Üí Œ¥ (succ n) a‚Çô‚Çä‚ÇÅ (succ j)) n a‚Çô‚Çä‚ÇÅ

     I : type-of IH
       ‚Üí Œ£ k Íûâ ‚Ñï , A k √ó ((i : ‚Ñï) ‚Üí A i ‚Üí k ‚â§ i)
     I (j , a‚±º‚Çä‚ÇÅ , b) =
      Cases (Œ¥ (succ n) a‚Çô‚Çä‚ÇÅ 0 (zero-least j))
       (Œª (a‚ÇÄ :    A 0) ‚Üí (0      , a‚ÇÄ   , (Œª i a·µ¢ ‚Üí zero-least i)))
       (Œª (ŒΩ‚ÇÄ  : ¬¨ A 0) ‚Üí (succ j , a‚±º‚Çä‚ÇÅ , I‚ÇÄ ŒΩ‚ÇÄ))
        where
         I‚ÇÄ : ¬¨ A 0 ‚Üí (i : ‚Ñï) (a·µ¢ : A i) ‚Üí j < i
         I‚ÇÄ ŒΩ‚ÇÄ 0        a‚ÇÄ   = ùüò-elim (ŒΩ‚ÇÄ a‚ÇÄ)
         I‚ÇÄ ŒΩ‚ÇÄ (succ i) a·µ¢‚Çä‚ÇÅ = b i a·µ¢‚Çä‚ÇÅ

     II : Œ£ k Íûâ ‚Ñï , (A k √ó  ((i : ‚Ñï) ‚Üí A i ‚Üí k ‚â§ i))
     II = I IH

\end{code}

We name the projections for convenience..

\begin{code}

 minimal-number : Œ£ A ‚Üí ‚Ñï
 minimal-number œÉ = pr‚ÇÅ (minimal-witness‚Å∫ œÉ)

 minimal-number-requirement : (œÉ : Œ£ A) ‚Üí A (minimal-number œÉ)
 minimal-number-requirement œÉ = pr‚ÇÅ (pr‚ÇÇ (minimal-witness‚Å∫ œÉ))

 minimality : (œÉ : Œ£ A) ‚Üí (i : ‚Ñï) ‚Üí A i ‚Üí minimal-number œÉ ‚â§ i
 minimality œÉ = pr‚ÇÇ (pr‚ÇÇ (minimal-witness‚Å∫ œÉ))

 minimal-pair : Œ£ A ‚Üí Œ£ A
 minimal-pair œÉ = minimal-number œÉ , minimal-number-requirement œÉ

 minimal-pair-wconstant : is-prop-valued-family A ‚Üí wconstant minimal-pair
 minimal-pair-wconstant A-prop-valued œÉ œÉ' =
  to-subtype-Ôºù A-prop-valued
   (need
     minimal-number œÉ Ôºù minimal-number œÉ'
    which-is-given-by
     ‚â§-anti _ _
      (minimality œÉ  (minimal-number œÉ') (minimal-number-requirement œÉ'))
      (minimality œÉ' (minimal-number œÉ)  (minimal-number-requirement œÉ)))

\end{code}

A particular case.

\begin{code}

minimal-witness : (A : ‚Ñï ‚Üí ùì§ Ãá )
                ‚Üí ((n : ‚Ñï) ‚Üí is-decidable (A n))
                ‚Üí (Œ£ n Íûâ ‚Ñï , A n)
                ‚Üí Œ£ m Íûâ ‚Ñï , (A m √ó ((k : ‚Ñï) ‚Üí A k ‚Üí m ‚â§ k))
minimal-witness A Œ¥ = minimal-witness‚Å∫ A (Œª n a‚Çô k l ‚Üí Œ¥ k)

\end{code}

We apply the above to exit truncations.

\begin{code}

module exit-truncations (pt : propositional-truncations-exist) where

 open PropositionalTruncation pt
 open split-support-and-collapsibility pt

 module _ (A : ‚Ñï ‚Üí ùì§ Ãá )
          (A-is-prop-valued : is-prop-valued-family A)
          (Œ¥ : (n : ‚Ñï) ‚Üí A n ‚Üí (k : ‚Ñï) ‚Üí k < n ‚Üí is-decidable (A k))
        where

  exit-truncation‚Å∫ : ‚à• Œ£ A ‚à• ‚Üí Œ£ A
  exit-truncation‚Å∫ = collapsible-gives-split-support
                      (minimal-pair A Œ¥ ,
                       minimal-pair-wconstant A Œ¥ A-is-prop-valued)
\end{code}

Not only can be exit the truncation, but also we can say that the
result is minimal.

\begin{code}

  exit-truncation‚Å∫-minimality
   : (s : ‚à• Œ£ A ‚à•) (i : ‚Ñï) ‚Üí A i ‚Üí pr‚ÇÅ (exit-truncation‚Å∫ s) ‚â§ i
  exit-truncation‚Å∫-minimality s = IV
   where
    I : minimal-pair A Œ¥ (exit-truncation‚Å∫ s) Ôºù exit-truncation‚Å∫ s
    I = exit-prop-trunc-is-fixed
         (minimal-pair A Œ¥)
         (minimal-pair-wconstant A Œ¥ A-is-prop-valued)
         s

    II : minimal-number A Œ¥ (exit-truncation‚Å∫ s) Ôºù pr‚ÇÅ (exit-truncation‚Å∫ s)
    II = ap pr‚ÇÅ I

    III : (i : ‚Ñï) ‚Üí A i ‚Üí minimal-number A Œ¥ (exit-truncation‚Å∫ s) ‚â§ i
    III = minimality A Œ¥ (exit-truncation‚Å∫ s)

    IV : (i : ‚Ñï) ‚Üí A i ‚Üí pr‚ÇÅ (exit-truncation‚Å∫ s) ‚â§ i
    IV = transport (Œª - ‚Üí (i : ‚Ñï) ‚Üí A i ‚Üí - ‚â§ i) II III

\end{code}

In the following particular case of interest, the prop-valuedness
assumption can be removed.

\begin{code}

 module _ (A : ‚Ñï ‚Üí ùì§ Ãá )
          (d : (n : ‚Ñï) ‚Üí is-decidable (A n))
        where

  private
    B : ‚Ñï ‚Üí ùì§‚ÇÄ Ãá
    B n = ‚à• A n ‚à•‚ü® d n ‚ü©

    B-is-prop-valued : is-prop-valued-family B
    B-is-prop-valued n = ‚à•‚à•‚ü® d n ‚ü©-is-prop

    Œ¥ : (n : ‚Ñï) ‚Üí B n ‚Üí (k : ‚Ñï) ‚Üí k < n ‚Üí is-decidable (B k)
    Œ¥ n b‚Çô k l = ‚à•‚à•‚ü® d k ‚ü©-is-decidable

    f : Œ£ A ‚Üí Œ£ B
    f (n , a‚Çô) = n , ‚à£ a‚Çô ‚à£‚ü® d n ‚ü©

    g : Œ£ B ‚Üí Œ£ A
    g (n , b‚Çô) = (n , ‚à£‚à£‚ü® d n ‚ü©-exit b‚Çô)

  exit-truncation : ‚à• Œ£ A ‚à• ‚Üí Œ£ A
  exit-truncation t = g (exit-truncation‚Å∫ B B-is-prop-valued Œ¥ (‚à•‚à•-functor f t))

  exit-truncation-minimality
   : (t : ‚à• Œ£ A ‚à•) (i : ‚Ñï) ‚Üí A i ‚Üí pr‚ÇÅ (exit-truncation t) ‚â§ i
  exit-truncation-minimality t i a =
   exit-truncation‚Å∫-minimality
    B
    B-is-prop-valued
    Œ¥
    (‚à•‚à•-functor f t)
    i
    ‚à£ a ‚à£‚ü® d i ‚ü©

\end{code}

TODO. Can we remove the prop-valuedness assumption in general?

Added 19th September 2024.

The following is useful in practice to fulfill a hypothesis of
exit-truncation‚Å∫.

\begin{code}

regression-lemma‚ÇÄ
 : (A : ‚Ñï ‚Üí ùì§ Ãá )
 ‚Üí ((n : ‚Ñï) ‚Üí A (succ n) ‚Üí is-decidable (A n))
 ‚Üí ((n : ‚Ñï) ‚Üí A n ‚Üí A (succ n))
 ‚Üí (n : ‚Ñï) ‚Üí A (succ n) ‚Üí is-decidable (A 0)
regression-lemma‚ÇÄ A f g 0        = f 0
regression-lemma‚ÇÄ A f g (succ n) = I
 where
  IH : A (succ (succ n)) ‚Üí is-decidable (A 1)
  IH = regression-lemma‚ÇÄ (A ‚àò succ) (f ‚àò succ) (g ‚àò succ) n

  I : A (succ (succ n)) ‚Üí is-decidable (A 0)
  I a = Cases (IH a)
         (Œª (a‚ÇÅ :   A 1) ‚Üí f 0 a‚ÇÅ)
         (Œª (ŒΩ  : ¬¨ A 1) ‚Üí inr (contrapositive (g 0) ŒΩ))

regression-lemma
 : (A : ‚Ñï ‚Üí ùì§ Ãá )
 ‚Üí ((n : ‚Ñï) ‚Üí A (succ n) ‚Üí is-decidable (A n))
 ‚Üí ((n : ‚Ñï) ‚Üí A n ‚Üí A (succ n))
 ‚Üí (n : ‚Ñï) ‚Üí A n ‚Üí (k : ‚Ñï) ‚Üí k < n ‚Üí is-decidable (A k)
regression-lemma A f g 0        a k        l = ùüò-elim l
regression-lemma A f g (succ n) a 0        l = regression-lemma‚ÇÄ A f g n a
regression-lemma A f g (succ n) a (succ k) l = regression-lemma
                                                (A ‚àò succ)
                                                (f ‚àò succ)
                                                (g ‚àò succ)
                                                n a k l
\end{code}

Notice that these functions don't actually use the full force of the
assumption

 (n : ‚Ñï) ‚Üí A n ‚Üí A (succ n)

but only its contrapositive. So there is a more general result that
assumes

 (n : ‚Ñï) ‚Üí ¬¨ A (succ n) ‚Üí ¬¨ A n

instead, although I don't think this will ever be needed. If it is, we
can come back here and do a little bit of refactoring.
