Lane Biocini, 12 October 2023

Following the equality case of the triangle inequality, we can define a
partial order on ‚Ñï directly with an identity type, namely by considering
the fixed points of the family of functions indexed by x of the form (Œª y
‚Üí ‚à£ y - x ‚à£ + x). This is because the only inhabitants of these fixed
point equalities are identities where x is less than or equal to y. And
because ‚Ñï is a set, each term of this identity type thereby becomes a
proposition, although in contrast to the standard order definition based
on ùüô each inhabitant of our order type is its own distinct refl term and
hence distinct inequalities will not be equal terms.

In hindsight it is obvious a type such as this ought to be possible,
because the definition for the standard order module essentially
calculates the inhabitation of its type by the same recursion algorithm as
absolute difference, with the provision that the succ x ‚â§ zero case is
defined as the empty type. Our definition leads to a partial order type
with interesting properties. As opposed to the one generated by a function
from ‚Ñï to ùüô, we are able to work directly with the identifications that
specify the order relation, so 'succ-lc' for example will translate an
inequality of 'succ m ‚âº succ n' to 'm ‚âº n', and likewise with 'ap succ'
for the other direction. Negation is directly handled by the standard
negation proofs for the Naturals. The use of transport is ergonomic as
each term is directly an identity term. Our type definition also has
strong computational properties that assist Agda's case matching as
opposed to the standard definition; you will never see it attempt to match
for the case 'succ x ‚âº zero' as Agda can automatically detect this type
is uninhabited.

We use the curly order '‚âº' so as not to conflict with the one already
defined for the Naturals. Although the early portions of this module were
written myself, after I translated Escardo's definition of ‚â§-induction to
this type I decided to go further and have begun translating all the Order
lemmas in the standard module to accommodate this definition. For the most
part, I have attempted to preserve the titles and type definitions
exactly, but in the earlier sections of the modules I took some liberties
as I wanted to tailor the most fundamental lemmas to the character of this
type, and also to make certain operations more ergonomic and reduce the
character count of proofs. Notably, 'equal-gives-less-than-or-equal' is
simply '‚âº-Ôºù' here.

Aside from the fundamental lemmas as well as ones concerning absolute
difference the credit for most of the type definitions that will be listed
here goes to the efforts of Martin Escardo, Tom de Jong, and Andrew Sneap.
Sometimes I needed to tailor their proofs to fit our order definition, but
in many cases I was able to use essentially the same principles from
proofs in the other module to guide the equivalent proofs here.

\begin{code}

{-# OPTIONS --safe --without-K --exact-split #-}

module Naturals.IdOrder where

open import MLTT.Spartan renaming (_+_ to _‚àî_)
open import MLTT.Plus-Properties using (+functor)

open import Naturals.Addition using (_+_; zero-left-neutral; succ-left;
 addition-commutativity; addition-right-cancellable)
open import Naturals.AbsoluteDifference
open import Naturals.Order using (_‚â§‚Ñï_)
open import Naturals.Properties using (positive-not-zero; succ-lc)
open import Naturals.Multiplication using (_*_)

open import Notation.General
open import Notation.Order
open import NotionsOfDecidability.Decidable

open import UF.Base using (transport‚ÇÇ)
open import UF.DiscreteAndSeparated using (discrete-types-are-sets;
 is-discrete; ‚Ñï-is-set; props-are-discrete)
open import UF.Equiv using (_‚âÖ_)
open import UF.Sets using (is-set)
open import UF.Subsingletons using (is-prop)

_‚âº‚Ñï_ : ‚Ñï ‚Üí ‚Ñï ‚Üí ùì§‚ÇÄ Ãá
x ‚âº‚Ñï y = ‚à£ y - x ‚à£ + x Ôºù y

infix 30 _‚âº‚Ñï_

instance
 Curly-Order-‚Ñï-‚Ñï : Curly-Order ‚Ñï ‚Ñï
 _‚âº_ {{Curly-Order-‚Ñï-‚Ñï}} = _‚âº‚Ñï_

private
 example : 0 ‚âº 2
 example = refl

 example2 : ¬¨ (1 ‚âº 0)
 example2 = positive-not-zero 1

‚âº-is-prop-valued : (x y : ‚Ñï) ‚Üí is-prop (x ‚âº y)
‚âº-is-prop-valued x y p q = ‚Ñï-is-set p q

‚âº-is-discrete : (x y : ‚Ñï) ‚Üí is-discrete (x ‚âº y)
‚âº-is-discrete x y = props-are-discrete (‚âº-is-prop-valued x y)

‚âº-is-set : (x y : ‚Ñï) ‚Üí is-set (x ‚âº y)
‚âº-is-set x y p q = discrete-types-are-sets (‚âº-is-discrete x y) p q

‚âº-dichotomous : (x y : ‚Ñï) ‚Üí (x ‚âº y) ‚àî (y ‚âº x)
‚âº-dichotomous x y = +functor (_‚Åª¬π) (_‚Åª¬π) (diff-cancellable x y)

zero-least : (x : ‚Ñï) ‚Üí zero ‚âº x
zero-least x = refl

unique-least : (x : ‚Ñï) ‚Üí x ‚âº zero ‚Üí x Ôºù zero
unique-least zero p = refl

‚âº-intro : (x y m n : ‚Ñï)
        ‚Üí (x Ôºù succ m)
        ‚Üí (y Ôºù succ (succ (m + n)))
        ‚Üí x ‚âº y
‚âº-intro x y zero zero p q = transport‚ÇÇ (_‚âº‚Ñï_) (p ‚Åª¬π) (q ‚Åª¬π) refl
‚âº-intro x y zero (succ n) p q = transport‚ÇÇ (_‚âº‚Ñï_) (p ‚Åª¬π) (q ‚Åª¬π)
 (ap succ (zero-least (succ (succ (0 + n)))))
‚âº-intro (succ x) (succ y) (succ m) n p q = ap succ
 (‚âº-intro x y m n (succ-lc p)
  (succ-lc (q ‚àô ap (succ ^ 2) (succ-left m n))))

‚âº-refl : reflexive _‚âº‚Ñï_
‚âº-refl x = ap (_+ x) (difference-is-zero x) ‚àô zero-left-neutral x

‚âº-anti : antisymmetric _‚âº‚Ñï_
‚âº-anti x zero p q = unique-least x p
‚âº-anti (succ x) (succ y) p q = ap succ
 (‚âº-anti x y (succ-lc p) (succ-lc q))

‚âº-trans : transitive _‚âº‚Ñï_
‚âº-trans zero y z p q = zero-least z
‚âº-trans (succ x) (succ y) (succ z) p q =
 ap succ (‚âº-trans x y z (succ-lc p) (succ-lc q))

‚âº-trans‚ÇÇ : (x y z w : ‚Ñï) ‚Üí x ‚âº y ‚Üí y ‚âº z ‚Üí z ‚âº w ‚Üí x ‚âº w
‚âº-trans‚ÇÇ x y z w p q r = ‚âº-trans x y w p (‚âº-trans y z w q r )

‚âº-transport‚ÇÇ : {x y z w : ‚Ñï} ‚Üí x Ôºù z ‚Üí y Ôºù w ‚Üí x ‚âº y ‚Üí z ‚âº w
‚âº-transport‚ÇÇ p q i = transport‚ÇÇ (_‚âº‚Ñï_) p q i

‚âº-Ôºù : (x y : ‚Ñï) ‚Üí x Ôºù y ‚Üí x ‚âº y
‚âº-Ôºù x y p = transport (x ‚âº‚Ñï_) p (‚âº-refl x)

_‚âº‚ü®_‚ü©_ : (x : ‚Ñï) {y z : ‚Ñï} ‚Üí x ‚âº y ‚Üí y ‚âº z ‚Üí x ‚âº z
(_‚âº‚ü®_‚ü©_) x {y} {z} p q = ‚âº-trans x y z p q

_‚óª : (x : ‚Ñï) ‚Üí x ‚âº x
_‚óª = ‚âº-refl

infixr 0 _‚âº‚ü®_‚ü©_
infix  1 _‚óª

private instance
 Reasoning-Chain-‚âº‚Ñï : Reasoning-Chain ‚Ñï ‚Ñï ‚Ñï (_‚âº‚Ñï_) (_‚âº‚Ñï_) (_‚âº‚Ñï_)
 _‚∏¥_‚ä¢_ {{Reasoning-Chain-‚âº‚Ñï}} = _‚âº‚ü®_‚ü©_

 Reflexive-Order-‚âº‚Ñï : Reflexive-Order ‚Ñï (_‚âº‚Ñï_)
 _‚ñ® {{Reflexive-Order-‚âº‚Ñï}} = ‚âº-refl

\end{code}

Order lemmas for the successor constructor

\begin{code}

‚âº-succ : (x : ‚Ñï) ‚Üí x ‚âº succ x
‚âº-succ zero = refl
‚âº-succ (succ x) = ap succ (‚âº-succ x)

‚âº-succ^ : (n x : ‚Ñï) ‚Üí x ‚âº (succ ^ n) x
‚âº-succ^ zero x = ‚âº-refl x
‚âº-succ^ (succ n) x = ‚âº-trans x (succ x) (succ (rec x succ n))
 (‚âº-succ x) (ap succ (‚âº-succ^ n x))

‚âº-close-left : (x y : ‚Ñï) ‚Üí succ x ‚âº y ‚Üí x ‚âº y
‚âº-close-left x y i = ‚âº-trans x (succ x) y (‚âº-succ x) i

‚âº-close-right : (x y : ‚Ñï) ‚Üí x ‚âº y ‚Üí x ‚âº succ y
‚âº-close-right x y i = ‚âº-trans x y (succ y) i (‚âº-succ y)

succ-monotone : (x y : ‚Ñï) ‚Üí x ‚âº y ‚Üí succ x ‚âº succ y
succ-monotone x y = ap succ

succ-order-injective : (x y : ‚Ñï) ‚Üí succ x ‚âº succ y ‚Üí x ‚âº y
succ-order-injective x y = succ-lc

¬¨‚âº-succ-lc : (x y : ‚Ñï) ‚Üí ¬¨ (succ x ‚âº succ y) ‚Üí ¬¨ (x ‚âº y)
¬¨‚âº-succ-lc x y l = l ‚àò ap succ

succ-not-less-than-zero : (x : ‚Ñï) ‚Üí ¬¨ (succ x ‚âº‚Ñï zero)
succ-not-less-than-zero x = positive-not-zero (succ x + x)

\end{code}

Some general properties of _‚âº_, notably we prove the induction principle
for it as well as the equivalence of our definition to the standard order
definition.

\begin{code}

‚âº-induction : (A : (x y : ‚Ñï) (i : x ‚âº y) ‚Üí ùì§ Ãá )
            ‚Üí ((y : ‚Ñï) ‚Üí A zero y (zero-least y))
            ‚Üí ((x y : ‚Ñï) (i : x ‚âº y)
                    ‚Üí A x y i
                    ‚Üí A (succ x) (succ y) (succ-monotone x y i))
            ‚Üí (x y : ‚Ñï) (i : x ‚âº y) ‚Üí A x y i
‚âº-induction A b f zero y i = transport (A zero y)
 (‚Ñï-is-set refl i) (b y)
‚âº-induction A b f (succ x) (succ y) i = transport (A (succ x) (succ y))
 (‚Ñï-is-set (ap succ (succ-lc i)) i)
 (f x y (succ-lc i) (‚âº-induction A b f x y (succ-lc i)))

‚âº-decidable : (x y : ‚Ñï) ‚Üí is-decidable (x ‚âº y)
‚âº-decidable zero y = inl refl
‚âº-decidable (succ x) zero = inr (succ-not-less-than-zero x)
‚âº-decidable (succ x) (succ y) =
 +functor (ap succ) (Œª u v ‚Üí u (succ-lc v)) (‚âº-decidable x y)

‚â§-‚âÖ-‚âº : (x y : ‚Ñï) ‚Üí (x ‚â§ y) ‚âÖ (x ‚âº y)
‚â§-‚âÖ-‚âº x y = Œ± x y , Œ≤ x y , Œ≥ x y , Œ¥ x y
 where
  Œ± : (x y : ‚Ñï) ‚Üí x ‚â§‚Ñï y ‚Üí x ‚âº‚Ñï y
  Œ± zero y i = zero-least y
  Œ± (succ x) (succ y) i = ap succ (Œ± x y i)

  Œ≤ : (x y : ‚Ñï) ‚Üí x ‚âº‚Ñï y ‚Üí x ‚â§‚Ñï y
  Œ≤ zero y i = ‚ãÜ
  Œ≤ (succ x) (succ y) i = Œ≤ x y (succ-lc i)

  Œ≥ : (x y : ‚Ñï) ‚Üí (Œª i ‚Üí Œ≤ x y (Œ± x y i)) ‚àº id
  Œ≥ zero y i = refl
  Œ≥ (succ x) (succ y) i = I ‚àô Œ≥ x y i
   where
    f : (m n : ‚Ñï) ‚Üí (p : m Ôºù n) ‚Üí succ-lc (ap succ p) Ôºù p
    f m n p = ‚Ñï-is-set (succ-lc (ap succ p)) p

    I : Œ≤ x y (succ-lc (ap succ (Œ± x y i))) Ôºù Œ≤ x y (Œ± x y i)
    I = ap (Œ≤ x y) (f (‚à£ y - x ‚à£ + x) y (Œ± x y i))

  Œ¥ : (x y : ‚Ñï) ‚Üí (Œª i ‚Üí Œ± x y (Œ≤ x y i)) ‚àº id
  Œ¥ zero y i = ‚Ñï-is-set refl i
  Œ¥ (succ x) (succ y) i = ‚Ñï-is-set (ap succ (Œ± x y (Œ≤ x y (succ-lc i)))) i

‚âº-split : (x y : ‚Ñï) ‚Üí x ‚âº succ y ‚Üí (x ‚âº y) ‚àî (x Ôºù succ y)
‚âº-split zero y i = inl refl
‚âº-split (succ x) zero i = inr (ap succ (unique-least x (succ-lc i)))
‚âº-split (succ x) (succ y) i =
 +functor (ap succ) (ap succ) (‚âº-split x y (succ-lc i))

‚âº-join : (x y : ‚Ñï) ‚Üí (x ‚âº y) ‚àî (x Ôºù succ y) ‚Üí x ‚âº succ y
‚âº-join x y (inl i) = ‚âº-close-right x y i
‚âº-join x y (inr l) = ‚âº-Ôºù x (succ y) l

‚âº-down : (x y : ‚Ñï) ‚Üí x ‚âº succ y ‚Üí (x ‚â† succ y) ‚Üí (x ‚âº y)
‚âº-down x y i l = cases id (ùüò-elim ‚àò l) (‚âº-split x y i)

\end{code}

Here we define the strict order and its associated lemmas. As above,
many of the proofs here are heavily guided by the equivalent ones
in the other module, and type definitions and names are preserved
for compatibility.

\begin{code}

_‚â∫‚Ñï_ : ‚Ñï ‚Üí ‚Ñï ‚Üí ùì§‚ÇÄ Ãá
x ‚â∫‚Ñï y = succ x ‚âº y

infix 30 _‚â∫‚Ñï_

instance
 Strict-Curly-Order-‚Ñï-‚Ñï : Strict-Curly-Order ‚Ñï ‚Ñï
 _‚â∫_ {{Strict-Curly-Order-‚Ñï-‚Ñï}} = _‚â∫‚Ñï_

not-less-than-itself : (x : ‚Ñï) ‚Üí ¬¨ (x ‚â∫ x)
not-less-than-itself x e = ùüò-elim (positive-not-zero ‚à£ x - succ x ‚à£
 (addition-right-cancellable (succ ‚à£ x - succ x ‚à£) 0 x
  (succ-left ‚à£ x - succ x ‚à£ x  ‚àô e ‚àô zero-left-neutral x ‚Åª¬π)))

not-less-bigger-or-equal : (x y : ‚Ñï) ‚Üí ¬¨ (y ‚â∫ x) ‚Üí y ‚âΩ x
not-less-bigger-or-equal zero y l = zero-least y
not-less-bigger-or-equal (succ x) zero l = ùüò-elim (l (zero-least (succ x)))
not-less-bigger-or-equal (succ x) (succ y) l =
 ap succ (not-less-bigger-or-equal x y (¬¨‚âº-succ-lc (succ y) x l))

bigger-or-equal-not-less : (x y : ‚Ñï) ‚Üí y ‚âΩ x ‚Üí ¬¨ (y ‚â∫ x)
bigger-or-equal-not-less x y i l =
 not-less-than-itself y (‚âº-trans (succ y) x y l i)

less-not-bigger-or-equal : (x y : ‚Ñï) ‚Üí x ‚â∫ y ‚Üí ¬¨ (y ‚âº x)
less-not-bigger-or-equal x y i l = bigger-or-equal-not-less y x l i

bounded-‚àÄ-next : (A : ‚Ñï ‚Üí ùì§ Ãá ) (n : ‚Ñï)
               ‚Üí A n
               ‚Üí ((k : ‚Ñï) ‚Üí k ‚â∫ n ‚Üí A k)
               ‚Üí (x : ‚Ñï) ‚Üí x ‚â∫ succ n ‚Üí A x
bounded-‚àÄ-next A n a œÜ x i =
 cases (œÜ x) (Œª u ‚Üí transport‚Åª¬π A (succ-lc u) a) (‚âº-split (succ x) n i)

\end{code}

Order lemmas for addition

\begin{code}

‚âº-+ : (x y : ‚Ñï) ‚Üí x ‚âº x + y
‚âº-+ zero y = zero-least (zero + y)
‚âº-+ (succ x) y =
 transport (Œª u ‚Üí succ x ‚âº‚Ñï u) (succ-left x y ‚Åª¬π) (ap succ (‚âº-+ x y))

‚âº-add-right : (x y z : ‚Ñï) ‚Üí x ‚âº y ‚Üí x + z ‚âº y + z
‚âº-add-right x y zero p = p
‚âº-add-right x y (succ z) p = ap succ (‚âº-add-right x y z p)

‚âº-add-left : (x y z : ‚Ñï) ‚Üí x ‚âº y ‚Üí z + x ‚âº z + y
‚âº-add-left zero y z p = ‚âº-+ z y
‚âº-add-left (succ x) y z p =
 transport‚ÇÇ (_‚âº‚Ñï_) (addition-commutativity (succ x) z)
  (addition-commutativity y z)
  (‚âº-add-right (succ x) y z p)

\end{code}

Order lemmas for absolute difference. It is an interesting result
that we can use an order defined by absolute difference to prove lemmas
regarding this same operation, or to put it another way, that lemmas about
absolute difference are directly lemmas about how terms are ordered in ‚Ñï.

\begin{code}

‚âº-diff-split : (x y : ‚Ñï)
             ‚Üí ‚à£ x - y ‚à£ ‚âº ‚à£ x - succ y ‚à£
             ‚àî ‚à£ x - y ‚à£ ‚âº ‚à£ succ x - y ‚à£
‚âº-diff-split zero y = inl (transport (Œª u ‚Üí u ‚âº succ y)
 (minus-nothing y ‚Åª¬π) (‚âº-succ y))
‚âº-diff-split (succ x) zero = inr (ap succ (‚âº-succ x))
‚âº-diff-split (succ x) (succ y) = ‚âº-diff-split x y

‚âº-succ-pred-split : (x y : ‚Ñï)
                  ‚Üí ‚à£ x - succ y ‚à£ ‚âº ‚à£ succ x - y ‚à£
                  ‚àî ‚à£ succ x - y ‚à£ ‚âº ‚à£ x - succ y ‚à£
‚âº-succ-pred-split zero zero = inl refl
‚âº-succ-pred-split zero (succ y) = inr (transport (_‚âº‚Ñï succ (succ y))
 (minus-nothing y ‚Åª¬π) (‚âº-succ^ 2 y))
‚âº-succ-pred-split (succ x) zero = inl (‚âº-succ^ 2 x)
‚âº-succ-pred-split (succ x) (succ y) = ‚âº-succ-pred-split x y

‚âº-diff-sum-left : (x y : ‚Ñï) ‚Üí x ‚âº y + ‚à£ y - x ‚à£
‚âº-diff-sum-left zero y = zero-least (y + y)
‚âº-diff-sum-left (succ x) zero =
 ap succ (‚âº-Ôºù x (zero + x) (zero-left-neutral x ‚Åª¬π))
‚âº-diff-sum-left (succ x) (succ y) =
 ‚âº-trans (succ x) (succ (y + ‚à£ y - x ‚à£)) (succ y + ‚à£ y - x ‚à£)
  (ap succ (‚âº-diff-sum-left x y))
  (‚âº-Ôºù (succ (y + ‚à£ y - x ‚à£)) (succ y + ‚à£ y - x ‚à£)
   (succ-left y ‚à£ y - x ‚à£ ‚Åª¬π))

‚âº-diff-sum-right : (x y : ‚Ñï) ‚Üí x ‚âº ‚à£ x - y ‚à£ + y
‚âº-diff-sum-right x zero = ‚âº-refl x
‚âº-diff-sum-right zero (succ y) = zero-least (succ (succ y + y))
‚âº-diff-sum-right (succ x) (succ y) = ap succ (‚âº-diff-sum-right x y)

diff-succ-less-than-succ-diff : (x y : ‚Ñï) ‚Üí ‚à£ succ x - y ‚à£ ‚âº‚Ñï succ ‚à£ x - y ‚à£
diff-succ-less-than-succ-diff zero zero = refl
diff-succ-less-than-succ-diff zero (succ y) =
 transport‚Åª¬π (Œª u ‚Üí u ‚âº succ (succ y)) (minus-nothing y) (‚âº-succ^ 2 y)
diff-succ-less-than-succ-diff (succ x) zero = ‚âº-refl (succ (succ x))
diff-succ-less-than-succ-diff (succ x) (succ y) =
 diff-succ-less-than-succ-diff x y

diff-pred-less-than-succ-diff : (x y : ‚Ñï)
                              ‚Üí  ‚à£ x - succ y ‚à£ ‚âº‚Ñï succ ‚à£ x - y ‚à£
diff-pred-less-than-succ-diff zero y = transport‚Åª¬π (Œª u ‚Üí succ y ‚âº succ u)
 (minus-nothing y)
 (ap succ (‚âº-refl y))
diff-pred-less-than-succ-diff (succ x) zero = ‚âº-succ^ 2 x
diff-pred-less-than-succ-diff (succ x) (succ y) =
 diff-pred-less-than-succ-diff x y

diff-less-than-succ-diff-pred : (x y : ‚Ñï) ‚Üí ‚à£ x - y ‚à£ ‚âº succ ‚à£ x - succ y ‚à£
diff-less-than-succ-diff-pred zero y = transport‚Åª¬π (_‚âº‚Ñï succ (succ y))
 (minus-nothing y)
 (‚âº-succ^ 2 y)
diff-less-than-succ-diff-pred (succ x) y =
 diff-succ-less-than-succ-diff x y

diff-less-than-sum : (x y : ‚Ñï) ‚Üí ‚à£ x - y ‚à£ ‚âº x + y
diff-less-than-sum x zero = ‚âº-refl x
diff-less-than-sum x (succ y) =
 ‚âº-trans ‚à£ x - succ y ‚à£ (succ ‚à£ x - y ‚à£) (succ (x + y))
 (diff-pred-less-than-succ-diff x y) (ap succ (diff-less-than-sum x y))

triangle-inequality : (x y z : ‚Ñï) ‚Üí ‚à£ x - z ‚à£ ‚âº ‚à£ x - y ‚à£ + ‚à£ y - z ‚à£
triangle-inequality x zero z = transport‚Åª¬π (Œª u ‚Üí ‚à£ x - z ‚à£ ‚âº‚Ñï x + u)
 (minus-nothing z) (diff-less-than-sum x z)
triangle-inequality x (succ y) zero = ‚âº-diff-sum-right x (succ y)
triangle-inequality zero (succ y) (succ z) =
 ‚âº-diff-sum-left (succ z) (succ y)
triangle-inequality (succ x) (succ y) (succ z) = triangle-inequality x y z

\end{code}
